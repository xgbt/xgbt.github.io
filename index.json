[{"content":"架构设计 OS: AlmaLinux 9.1\n节点名 IP 地址 zqf-Master01 10.101.5.110 zqf-Master02 10.101.5.111 zqf-Master03 10.101.5.112 zqf-Worker01 10.101.5.113 zqf-Worker02 10.101.5.114 zqf-Worker03 10.101.5.115 zqf-Worker04 10.101.5.116 1. 所有节点操作 1.1 基础配置 1.1.1 配置镜像源 1sed -e \u0026#39;s|^mirrorlist=|#mirrorlist=|g\u0026#39; \\ 2 -e \u0026#39;s|^#\\s*baseurl=https://repo.almalinux.org/almalinux|baseurl=https://mirrors.zju.edu.cn/almalinux|g\u0026#39; \\ 3 -i.bak \\ 4 /etc/yum.repos.d/almalinux-*.repo 1dnf makecache 1.1.2 配置主机名 1hostnamectl set-hostname \u0026lt;主机名\u0026gt; 添加解析记录，使节点直接使用主机名访问通信\n1cat \u0026lt;\u0026lt; EOF \u0026gt;\u0026gt; /etc/hosts 210.101.5.110 zqf-Master01 310.101.5.111 zqf-Master02 410.101.5.112 zqf-Master03 510.101.5.113 zqf-Worker01 610.101.5.114 zqf-Worker02 710.101.5.115 zqf-Worker03 810.101.5.116 zqf-Worker04 9EOF 1.1.3 免密登录配置（新增/可选） 1ssh-keygen -t rsa -b 2048 1ssh-copy-id root@目标节点IP 1.1.4 禁用防火墙 1systemctl stop firewalld \u0026amp;\u0026amp; systemctl disable firewalld 2systemctl disable --now dnsmasq 1.1.5 禁用 SELINUX 修改配置文件，使 SELINUX=disabled 注意，是 disabled ，不是 disable\n1vim /etc/selinux/config 或者，直接执行下列命令 1sed -i \u0026#39;s#SELINUX=enforcing#SELINUX=disabled#g\u0026#39; /etc/sysconfig/selinux 2sed -i \u0026#39;s#SELINUX=enforcing#SELINUX=disabled#g\u0026#39; /etc/selinux/config 查看系统 SELinux 运行状态 1sestatus 1.1.6 禁用 Swap 分区 Swap 是交换分区，如果机器内存不够，会使用swap分区。\n但是，swap分区性能较低，k8s 默认不允许使用交换分区。\nkubeadm 初始化的时候会检测 swap 状态，未关闭 swap 会导致初始化失败。\n1swapoff -a \u0026amp;\u0026amp; sysctl -w vm.swappiness=0 2sed -ri \u0026#39;/^[^#]*swap/s@^@#@\u0026#39; /etc/fstab 若 swap 为 0， 说明 swap 关闭成功\n1free -mh 1.1.7 时间同步（新增） 所有节点安装 chrony 1dnf -y install chrony 挑一个节点 (10.101.5.110) 修改配置 1# 配置chrony服务 2vim /etc/chrony.conf 3 4# 指定使用的上游时间服务器地址 5pool ntp.aliyun.com iburst 6 7# 允许访问的服务器 8allow 192.168.10.0/24 其他节点修改上游服务器即可 1# 配置chrony服务 2vim /etc/chrony.conf 3 4# 指定 10.101.5.110 为上游服务器 5pool 10.101.5.110 iburst 启用服务 1systemctl restart chronyd 2systemctl enable chronyd 5. 查看同步状态\n1chronyc sources 1.1.8 配置系统资源限制 1vim /etc/security/limits.conf 添加以下配置，包括最大文件描述符数量、最大进程数量和内存锁定限制\n1* soft nofile 65536 2* hard nofile 131072 3* soft nproc 65535 4* hard nproc 655350 5* soft memlock unlimited 6* hard memlock unlimited 1.1.9 配置内核参数 1sysctl net.core.bpf_jit_limit=452534528 配置 K8S 所需内核参数。\n1cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/sysctl.d/k8s.conf 2net.ipv4.ip_forward = 1 3net.bridge.bridge-nf-call-iptables = 1 4net.bridge.bridge-nf-call-ip6tables = 1 5fs.may_detach_mounts = 1 6vm.overcommit_memory=1 7vm.panic_on_oom=0 8fs.inotify.max_user_watches=89100 9fs.file-max=52706963 10fs.nr_open=52706963 11net.netfilter.nf_conntrack_max=2310720 12net.ipv4.tcp_keepalive_time = 600 13net.ipv4.tcp_keepalive_probes = 3 14net.ipv4.tcp_keepalive_intvl =15 15net.ipv4.tcp_max_tw_buckets = 36000 16net.ipv4.tcp_tw_reuse = 1 17net.ipv4.tcp_max_orphans = 327680 18net.ipv4.tcp_orphan_retries = 3 19net.ipv4.tcp_syncookies = 1 20net.ipv4.tcp_max_syn_backlog = 16384 21net.ipv4.ip_conntrack_max = 65536 22net.ipv4.tcp_max_syn_backlog = 16384 23net.ipv4.tcp_timestamps = 0 24net.core.somaxconn = 16384 25vm.swappiness=0 26EOF 其中，\n1net.ipv4.ip_forward = 1 2net.bridge.bridge-nf-call-iptables = 1 3net.bridge.bridge-nf-call-ip6tables = 1 也是 Containerd CRI 所需的内核参数。\n加载上述内核参数生效所需要的模块，并加载生效\n1modprobe -- overlay 2modprobe -- br_netfilter 3sysctl --system 1.3 配置 IPVS K8S 集群将使用 ipvs 模式，因此这里事先安装 ipvs 相关组件。\n安装 ipvs 相关软件包 1dnf install -y ipvsadm ipset sysstat conntrack libseccomp 载入模块 1modprobe -- ip_vs 2modprobe -- ip_vs_rr 3modprobe -- ip_vs_wrr 4modprobe -- ip_vs_sh 5modprobe -- nf_conntrack 创建ipvs.conf，设置内核模块的自动载入 1cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/modules-load.d/ipvs.conf 2ip_vs 3ip_vs_lc 4ip_vs_wlc 5ip_vs_rr 6ip_vs_wrr 7ip_vs_lblc 8ip_vs_lblcr 9ip_vs_dh 10ip_vs_sh 11ip_vs_fo 12ip_vs_nq 13ip_vs_sed 14ip_vs_ftp 15ip_vs_sh 16nf_conntrack 17ip_tables 18ip_set 19xt_set 20ipt_set 21ipt_rpfilter 22ipt_REJECT 23ipip 24EOF 1systemctl enable --now systemd-modules-load.service 1.4 安装 Containerd 安装 Containerd 1dnf install containerd -y 1ctr -v 2ctr containerd.io 1.7.18 生成 containerd 配置文件 1mkdir -p /etc/containerd 2containerd config default | sudo tee /etc/containerd/config.toml 修改 Containerd 使用的 cgroup 为 systemd cgroup driver 1[plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.containerd.runtimes.runc] 2 ... 3 [plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.containerd.runtimes.runc.options] 4 SystemdCgroup = true 修改 Containerd 使用的 sandbox_image 修改 sandbox 的镜像地址\n1sandbox_image = \u0026#34;registry.aliyuncs.com/google_containers/pause:3.9\u0026#34; 配置 Containerd 私服地址跳过 https 验证 1[plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.registry.configs] 2 [plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.registry.configs.\u0026#34;10.101.7.108\u0026#34;.tls] 3 insecure_skip_verify = true 4 [plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.registry.configs.\u0026#34;szharbor.hithium.cn\u0026#34;.tls] 5 insecure_skip_verify = true 6 7[plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.registry.configs.\u0026#34;docker.io\u0026#34;.tls] 8 insecure_skip_verify = true 配置 docker.io 镜像 1 [plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.registry.mirrors] 2 [plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.registry.mirrors.\u0026#34;docker.io\u0026#34;] 3 endpoint = [\u0026#34;https://docker.1panel.live\u0026#34;][plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.registry.mirrors.\u0026#34;10.101.7.108:80\u0026#34;] 4 endpoint = [\u0026#34;http://10.101.7.108\u0026#34;] 使配置生效 1systemctl daemon-reload 2systemctl restart containerd.service 3systemctl enable containerd.service 1.5 安装 K8S 相关组件 https://mirrors.aliyun.com/kubernetes-new/core/stable/v1.29/rpm/\n1cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/yum.repos.d/kubernetes.repo 2[kubernetes] 3name=Kubernetes 4baseurl=https://mirrors.aliyun.com/kubernetes-new/core/stable/v1.29/rpm/ 5enabled=1 6gpgcheck=1 7gpgkey=https://mirrors.aliyun.com/kubernetes-new/core/stable/v1.29/rpm/repodata/repomd.xml.key 8EOF 1dnf -y install kubectl kubelet kubeadm 2. 主节点配置 2.1 高可用配置 2.1.1 安装相关组件 安装keepalived, haproxy\n1dnf -y install keepalived haproxy 2.1.2 配置检测脚本文件 该脚本检测本地 8443 端口(haproxy服务)是否正常，若不正常，则停止本地的 Keepalived 服务，VIP飘逸到其它 haproxy 可用的节点，继续提供服务。\n1vim /etc/keepalived/check_apiserver.sh 1#!/bin/sh 2curl -sfk --max-time 2 https://localhost:8443/healthz -o /dev/null 3if [ $? -nq 0] 4then 5 echo \u0026#34;*** Error GET https://localhost:8443/healthz\u0026#34; 1\u0026gt;\u0026amp;2 6 systemctl stop keepalived 7fi 给脚本文件执行权限\n1chmod +x /etc/keepalived/check_apiserver.sh 2.1.3 配置 keepalived.conf VIP 记得使用节点所在网段，但不使用的 IP 地址\n1vim /etc/keepalived/keepalived.conf 1! Configuration File for keepalived 2global_defs { 3 router_id LVS_DEVEL 4} 5 6# 指定检测脚本: 7# script: 脚本路径; 8# interval: 脚本执行时间; 9# weight: 权重; 10# fall: 连续检测失败多少次之后认定节点不可用; 11# rise: 连续检测成功多少次认为节点恢复正常。 12vrrp_script check_apiserver { 13 script \u0026#34;/etc/keepalived/check_apiserver.sh\u0026#34; 14 interval 3 15 weight -2 16 fall 10 17 rise 2 18} 19 20# state: 指定MASTER身份, 另外两台Keepalived设置成BACKUP 21# interface: 指定网卡; 22# virtual_router_id: VRRP虚拟路由id, 同一集群的Keepalived节点要相同, 用来识别彼此 23# priority: 优先级, 另外两台Keepalived分别设置成90 70 24# auth_type: VRRP组节点之间认证方式为PASS铭文 25# auth_pass: VRRP组节点之间用来认证通信的密码 26# virtual_ipaddress: VIP 27# track_script: 指定使用的检测脚本名称 28 29vrrp_instance VI_1 { 30 state MASTER 31 interface ens192 32 virtual_router_id 51 33 priority 100 34 authentication { 35 auth_type PASS 36 auth_pass 1111 37 } 38 virtual_ipaddress { 39 10.101.5.2 40 } 41 track_script { 42 check_apiserver 43 } 44} 2.1.4 配置 haproxy.cfg 1vim /etc/haproxy/haproxy.cfg 1#--------------------------------------------------------------------- 2# Global settings 3#--------------------------------------------------------------------- 4global 5 log\tstdout\tformat\traw\tlocal0 6 chroot\t/var/lib/haproxy 7 pidfile\t/var/run/haproxy.pid 8 maxconn\t4000 9 user\thaproxy 10 group\thaproxy 11 12 13#--------------------------------------------------------------------- 14# common defaults that all the \u0026#39;listen\u0026#39; and \u0026#39;backend\u0026#39; sections will 15# use if not designated in their block 16#--------------------------------------------------------------------- 17defaults 18 log\tglobal 19 option\thttplog 20 option\tdontlognull 21 timeout\tconnect\t5s 22 timeout\tclient\t35s 23 timeout\tserver\t35s 24 25 26#--------------------------------------------------------------------- 27# apiserver frontend which proxys to the control plane nodes 28#--------------------------------------------------------------------- 29# 主要是这里的bind: 定义haproxy的代理端口为8443。也可以是其它。 30frontend\tapiserver 31\tbind\t*:8443 32\tmode\ttcp 33\toption\ttcplog 34\tdefault_backend\tapiserverbackend 35 36 37#--------------------------------------------------------------------- 38# round robin balancing for apiserver 39#--------------------------------------------------------------------- 40# 以下是后端相关配置, 关键参数解释如下 41# mode tcp: 设置与后端服务通信的模式为TCP 42# balance roundrobin: 轮询方式 43# inter 10s: 检查间隔为10秒。 44# downinter 5s: 当服务被标记为不可用后，每5秒检查一次是否恢复。 45# rise 2: 在将服务器标记为上线之前，服务器必须连续2次成功响应检查。 46# fall 2: 在将服务器标记为下线之前，服务器必须连续2次失败响应检查。 47# slowstart 60s: 慢启动时间为60秒，用于控制新服务器上线后逐渐增加其权重。 48# maxconn 250: 每个服务器的最大并发连接数为250。 49# maxqueue 256: 后端队列的最大长度为256。 50# weight 100: 服务器的默认权重为100。 51# server 定义后端的服务器列表。 52 53 54backend\tapiserverbackend 55\toption\ttcplog 56\toption\ttcp-check 57\tmode\ttcp 58\tbalance\troundrobin 59\tdefault-server inter 10s downinter 5s rise 2 fall 2 slowstart 60s maxconn 250 maxqueue 256 weight 100 60\tserver\tzqf-Master01\t10.101.5.110:6443\tcheck 61\tserver\tzqf-Master02\t10.101.5.111:6443\tcheck 62\tserver\tzqf-Master03\t10.101.5.112:6443\tcheck 2.1.5 启动服务并验证 启动服务 1systemctl enable --now keepalived 2systemctl enable --now haproxy 验证 停止 master01 上的 keepalived 服务后， 虚拟 IP 192.168.10.240/32 会移动到 moster02。 恢复 master01 上的 keepalived 服务后， 虚拟 IP 192.168.10.240/32 会移动回 moster01。\n1[root@zqf-Master01 ~]# ip a | grep ens 22: ens192: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP group default qlen 1000 3 inet 10.101.5.110/24 brd 10.101.5.255 scope global noprefixroute ens192 4 inet 192.168.10.240/32 scope global ens192 5 6[root@zqf-Master02 keepalived]# ip a | grep ens 72: ens192: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP group default qlen 1000 8 inet 10.101.5.111/24 brd 10.101.5.255 scope global noprefixroute ens192 2.2 基于 kubeadm 安装集群 2.2.1 提前拉取镜像 1kubeadm config images pull --image-repository registry.aliyuncs.com/google_containers 2.2.2 修改 kubeadm 配置文件 1kubeadm config print init-defaults \u0026gt; kubeadm-init.yaml 配置项 描述 advertiseAddress 指定本机地址 name 指定本机的主机名 controlPlaneEndpoint 指定控制面的通信地址，这里写 VIP 地址 imageRepository 指定下载 Kubernetes 组件的镜像仓库地址, 默认访问国外的仓库, 这里需要修改为国内的镜像仓库源 kubernetesVersion 指定安装的 kubernetes 版本 serviceSubnet 指定 Kubernetes 的 Service 资源分配的网段, 网段不能与真实机和 Pod 的网段冲突。 podSubnet 指定 Kubernetes 的 Pod 资源分配的网段, 网段不能与真实机和 Service 的网段冲突。 需要修改的部分包括：\nlocalAPIEndpoint.advertiseAddress：主节点 IP 地址 nodeRegistration.name：主节点 hostname imageRepository：镜像仓库地址 networking.podSubnet: pod 子网范围 1apiVersion: kubeadm.k8s.io/v1beta3 2bootstrapTokens: 3- groups: 4 - system:bootstrappers:kubeadm:default-node-token 5 token: abcdef.0123456789abcdef 6 ttl: 24h0m0s 7 usages: 8 - signing 9 - authentication 10kind: InitConfiguration 11localAPIEndpoint: 12 advertiseAddress: 10.101.5.110 13 bindPort: 6443 14nodeRegistration: 15 criSocket: unix:///var/run/containerd/containerd.sock 16 imagePullPolicy: IfNotPresent 17 name: zqf-Master01 18 taints: null 19--- 20apiServer: 21 timeoutForControlPlane: 4m0s 22apiVersion: kubeadm.k8s.io/v1beta3 23certificatesDir: /etc/kubernetes/pki 24clusterName: kubernetes 25controllerManager: {} 26dns: {} 27controlPlaneEndpoint: \u0026#34;10.101.5.2:8443\u0026#34; 28etcd: 29 local: 30 dataDir: /var/lib/etcd 31imageRepository: registry.aliyuncs.com/google_containers 32kind: ClusterConfiguration 33kubernetesVersion: 1.29.6 34networking: 35 dnsDomain: cluster.local 36 serviceSubnet: 10.96.0.0/12 37 podSubnet: 192.168.0.0/16 38scheduler: {} 39 40# 补充 41--- 42apiVersion: kubeproxy.config.k8s.io/v1alpha1 43kind: KubeProxyConfiguration 44mode: ipvs 45--- 46apiVersion: kubelet.config.k8s.io/v1beta1 47kind: KubeletConfiguration 48cgroupDriver: systemd 2.2.3 初始化 K8S 集群 1kubeadm init --config=kubeadm-init.yaml --upload-certs 其中， --upload-certs 会自动将证书从主控制平面节点复制到将要加入的控制平面节点上。\n然后，根据提示将各个节点加入集群。\n1# 添加master节点的命令 2kubeadm token create --print-join-command --certificate-key 3 4# 添加worker节点的命令获取方式 5kubeadm token create --print-join-command kubeadm token create \u0026ndash;print-join-command \u0026ndash;ttl 0\n2.2.4 配置 kubectl 1mkdir -p $HOME/.kube 2sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config 3sudo chown $(id -u):$(id -g) $HOME/.kube/config 4# 将以下命令加到.bashrc 5export KUBECONFIG=/etc/kubernetes/admin.conf 其中，admin.conf 是连接 Kubernetes 的认证文件，通过此文件才能连接到 kubernetes，kubectl 也需要这个文件；在 Linux 中，使用 KUBECONFIG 环境变量知道认证文件的所在。\nLinux 中每个用户的环境变量是不同的，如果切换了用户，则也需要设置 KUBECONFIG 环境变量；如果要在别的节点上连接集群，则可以把这个文件复制过去。\n此时，在 master01 上执行 kubectl get no 应有\n1[root@zqf-Master01 ~]# kubectl get no 2NAME STATUS ROLES AGE VERSION 3zqf-master01 NotReady control-plane 2m23s v1.29.6 4zqf-master02 NotReady control-plane 101s v1.29.6 5zqf-master03 NotReady control-plane 101s v1.29.6 6zqf-worker01 NotReady \u0026lt;none\u0026gt; 67s v1.29.6 7zqf-worker02 NotReady \u0026lt;none\u0026gt; 65s v1.29.6 8zqf-worker03 NotReady \u0026lt;none\u0026gt; 63s v1.29.6 9zqf-worker04 NotReady \u0026lt;none\u0026gt; 60s v1.29.6 2.3 安装 Calico Calico3.28 版本支持: Kubernetesv1.27-v1.30。\nCalico 的安装方式目前有两种：\n基于 Operator 方式安装，能够管理 Calico 集群的安装，升级，生命周期管理等，但不方便管理镜像地址。（优先） 基于静态资源清单安装，方便，简单，但无法像 Opertaor 一样能够自动管理 Calico 的生命周期。 基于静态资源清单的部署常见的也分为两种：\ncalico.yaml：当 Calico 使用 Kubernetes API 作为数据存储，且集群节点少于 50 个。 calico-typha.yaml: 当 Calico 使用 Kubernetes API 作为数据存储，且集群节点大于 50 个。 https://github.com/projectcalico/calico/blob/master/manifests/calico-typha.yaml\nreplicas: 副本数 , 建议每200个节点1个副本, 生产的话建议3个副本。\n其中，镜像推荐提前拉取到私服，然后修改 imageurl\n安装成功后，如下所示\n1[root@zqf-Master01 ~]# kubectl get po -n kube-system 2NAME READY STATUS RESTARTS AGE 3calico-kube-controllers-7884dfffd6-pdj8v 1/1 Running 0 61s 4calico-node-7q2dp 1/1 Running 0 46s 5calico-node-gdtc4 1/1 Running 0 46s 6calico-node-hndr8 1/1 Running 0 46s 7calico-node-jd9zm 1/1 Running 0 46s 8calico-node-n8z5j 1/1 Running 0 46s 9calico-node-pn4l2 1/1 Running 0 46s 10calico-node-wtqtn 1/1 Running 0 46s 11calico-typha-866db88dc4-8njgj 1/1 Running 0 61s 12calico-typha-866db88dc4-8wd57 1/1 Running 0 61s 13calico-typha-866db88dc4-wnjzh 1/1 Running 0 61s 14coredns-66db75cf8c-96t2p 1/1 Running 0 61s 15coredns-66db75cf8c-xgdf9 1/1 Running 0 61s 16etcd-zqf-master01 1/1 Running 1 53m 17etcd-zqf-master02 1/1 Running 0 52m 18etcd-zqf-master03 1/1 Running 0 52m 19kube-apiserver-zqf-master01 1/1 Running 1 53m 20kube-apiserver-zqf-master02 1/1 Running 0 52m 21kube-apiserver-zqf-master03 1/1 Running 0 52m 22kube-controller-manager-zqf-master01 1/1 Running 1 53m 23kube-controller-manager-zqf-master02 1/1 Running 0 52m 24kube-controller-manager-zqf-master03 1/1 Running 0 52m 25kube-proxy-75sbq 1/1 Running 0 37s 26kube-proxy-g2nqd 1/1 Running 0 45s 27kube-proxy-jqd92 1/1 Running 0 40s 28kube-proxy-kwxcb 1/1 Running 0 44s 29kube-proxy-lhtvl 1/1 Running 0 38s 30kube-proxy-vkv5v 1/1 Running 0 43s 31kube-proxy-ws2fl 1/1 Running 0 41s 32kube-scheduler-zqf-master01 1/1 Running 1 53m 33kube-scheduler-zqf-master02 1/1 Running 0 52m 34kube-scheduler-zqf-master03 1/1 Running 0 52m 1[root@zqf-Master01 ~]# kubectl get node 2NAME STATUS ROLES AGE VERSION 3zqf-master01 Ready control-plane 54m v1.29.6 4zqf-master02 Ready control-plane 53m v1.29.6 5zqf-master03 Ready control-plane 53m v1.29.6 6zqf-worker01 Ready \u0026lt;none\u0026gt; 52m v1.29.6 7zqf-worker02 Ready \u0026lt;none\u0026gt; 52m v1.29.6 8zqf-worker03 Ready \u0026lt;none\u0026gt; 52m v1.29.6 9zqf-worker04 Ready \u0026lt;none\u0026gt; 52m v1.29.6 2.4 配置 kubectl 命令补全 1dnf install -y bash-completion 2source /usr/share/bash-completion/bash_completion 3source \u0026lt;(kubectl completion bash) 4echo \u0026#34;source \u0026lt;(kubectl completion bash)\u0026#34; \u0026gt;\u0026gt; ~/.bashrc 3. 清除 kubeadm 环境 1kubeadm reset cleanup-node 2y 3kubeadm reset 4y 5rm -rf /etc/cni/net.d 6ipvsadm --clear 7rm -rf $HOME/.kube/config ","permalink":"/tech/kubernetes/kubernetes-1.29.6-%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/","summary":"\u003ch1 id=\"架构设计\"\u003e架构设计\u003c/h1\u003e\n\u003cp\u003eOS: AlmaLinux 9.1\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e节点名\u003c/th\u003e\n          \u003cth\u003eIP 地址\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ezqf-Master01\u003c/td\u003e\n          \u003ctd\u003e10.101.5.110\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ezqf-Master02\u003c/td\u003e\n          \u003ctd\u003e10.101.5.111\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ezqf-Master03\u003c/td\u003e\n          \u003ctd\u003e10.101.5.112\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ezqf-Worker01\u003c/td\u003e\n          \u003ctd\u003e10.101.5.113\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ezqf-Worker02\u003c/td\u003e\n          \u003ctd\u003e10.101.5.114\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ezqf-Worker03\u003c/td\u003e\n          \u003ctd\u003e10.101.5.115\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ezqf-Worker04\u003c/td\u003e\n          \u003ctd\u003e10.101.5.116\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch1 id=\"1-所有节点操作\"\u003e1. 所有节点操作\u003c/h1\u003e\n\u003ch2 id=\"11-基础配置\"\u003e1.1 基础配置\u003c/h2\u003e\n\u003ch3 id=\"111-配置镜像源\"\u003e1.1.1 配置镜像源\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003esed -e \u003cspan class=\"s1\"\u003e\u0026#39;s|^mirrorlist=|#mirrorlist=|g\u0026#39;\u003c/span\u003e \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e    -e \u003cspan class=\"s1\"\u003e\u0026#39;s|^#\\s*baseurl=https://repo.almalinux.org/almalinux|baseurl=https://mirrors.zju.edu.cn/almalinux|g\u0026#39;\u003c/span\u003e \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e    -i.bak \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e    /etc/yum.repos.d/almalinux-*.repo\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003ednf makecache\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"112-配置主机名\"\u003e1.1.2 配置主机名\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003ehostnamectl set-hostname \u0026lt;主机名\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e添加解析记录，使节点直接使用主机名访问通信\u003c/p\u003e","title":"Kubernetes 1.29.6 高可用集群部署"},{"content":"检查证书是否过期 1kubeadm certs check-expiration 该命令显示 /etc/kubernetes/pki 文件夹中的客户端证书以及 kubeadm（admin.conf、controller-manager.conf 和 scheduler.conf） 使用的 kubeconfig 文件中嵌入的客户端证书的到期时间/剩余时间。\n手动更新证书 在所有 Master 节点上执行证书更新命令 1kubeadm certs renew all 手动重启 Master 节点上的 Pod 由于动态证书重载目前还不被所有组件和证书支持，所有这项操作是必须的。静态 Pod 由本地 kubelet 而不是 API 服务器管理，所以 kubectl 不能用来删除或重启他们。\n首先，将清单文件从 /etc/kubernetes/manifests/ 移除并等待 20 秒 （参考 KubeletConfiguration 中的 fileCheckFrequency 值）。如果 Pod 不在清单目录里，kubelet 将会终止它。 在另一个 fileCheckFrequency 周期之后将文件移回去，kubelet 可以完成 Pod 的重建，而组件的证书更新操作也得以完成。\n参考资料 https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#check-certificate-expiration ","permalink":"/tech/kubernetes/%E5%9F%BA%E4%BA%8E-kubeadm-%E6%89%8B%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%AF%81%E4%B9%A6/","summary":"\u003ch1 id=\"检查证书是否过期\"\u003e检查证书是否过期\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003ekubeadm certs check-expiration\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e该命令显示 \u003ccode\u003e/etc/kubernetes/pki\u003c/code\u003e 文件夹中的客户端证书以及 kubeadm（\u003ccode\u003eadmin.conf\u003c/code\u003e、\u003ccode\u003econtroller-manager.conf\u003c/code\u003e 和 \u003ccode\u003escheduler.conf\u003c/code\u003e） 使用的 kubeconfig 文件中嵌入的客户端证书的到期时间/剩余时间。\u003c/p\u003e","title":"基于 Kubeadm 手动更新证书"},{"content":"Velero 安装步骤 客户端 https://github.com/vmware-tanzu/velero/releases\n下载并安装最新版本二进制客户端。\n1cp velero /usr/local/bin \u0026amp;\u0026amp; chmod +x /usr/local/bin/velero 2 3velero version 4Client: 5 Version: v1.13.2 6 Git commit: 4d961fb6fec384ed7f3c1b7c65c818106107f5a6 7\u0026lt;error getting server version: no matches for kind \u0026#34;ServerStatusRequest\u0026#34; in version \u0026#34;velero.io/v1\u0026#34;\u0026gt; 服务端 准备好秘钥文件 credentials-velero ，即 MinIO 的用户名密码。 1[default] 2aws_access_key_id=\u0026lt;access key id\u0026gt; 3aws_secret_access_key=\u0026lt;secret access key\u0026gt; 使用 velero install 安装服务端 1velero install \\ 2 --provider aws \\ 3 --image velero/velero:v1.13.2 \\ 4 --plugins velero/velero-plugin-for-aws:v1.9.2 \\ 5 --bucket velero \\ 6 --secret-file ./credentials-velero \\ 7 --use-node-agent \\ 8 --use-volume-snapshots=false \\ 9 --namespace velero \\ 10 --backup-location-config region=minio,s3ForcePathStyle=\u0026#34;true\u0026#34;,s3Url=http://10.101.6.118:9000 \\ 11 --wait 1velero version 2Client: 3 Version: v1.13.2 4 Git commit: 4d961fb6fec384ed7f3c1b7c65c818106107f5a6 5Server: 6 Version: v1.13.2 Velero 使用 备份 1velero create backup NAME [flags] backup选项：\n--exclude-namespaces stringArray : 要从备份中排除的名称空间 --exclude-resources stringArray: 要从备份中排除的资源，如storageclasses.storage.k8s.io --include-cluster-resources optionalBool[=true]: 包含集群资源类型 --include-namespaces stringArray: 要包含在备份中的名称空间(默认\u0026rsquo;*') --include-resources stringArray: 备份中要包括的资源 --labels mapStringString: 给这个备份加上标签 -o, --output string: 指定输出格式，支持\u0026rsquo;table\u0026rsquo;、\u0026lsquo;json\u0026rsquo;和\u0026rsquo;yaml\u0026rsquo;； -l, --selector labelSelector: 对指定标签的资源进行备份 --snapshot-volumes optionalBool[=true]: 对 PV 创建快照 --storage-location string: 指定备份的位置 --ttl duration: 备份数据多久删掉 --volume-snapshot-locations strings: 指定快照的位置，也就是哪一个公有云驱动 通常，直接使用默认命令即可。\n1velero backup create \u0026lt;name\u0026gt; 查看备份列表\n1velero backup get 定时备份\n1# 创建定时备份计划 2velero schedule create k8s-daily --schedule=\u0026#34;0 1 * * *\u0026#34; 3 4# 查看定时备份计划 5velero schedule get 恢复 velero restore 的行为不是覆盖，是恢复，不会覆盖已有的资源，只恢复当前集群中不存在的资源。已有的资源不会回滚到之前的版本，如需要回滚，需在restore之前提前删除现有的资源。\n1velero restore create --from-backup \u0026lt;name\u0026gt; 其他命令 1# 查看备份位置 2velero get backup-locations 3 4NAME PROVIDER BUCKET/PREFIX PHASE LAST VALIDATED ACCESS MODE DEFAULT 5default aws finley007 Available 2022-03-10 22:23:28 +0800 CST ReadWrite true 6 7# 查看已有恢复 8velero get restores 9 10# 查看 velero 插件 11velero get plugins 12 13# 删除 velero 备份 14velero backup delete nginx-backup 15 16# 持久卷备份 17velero backup create nginx-backup-volume --snapshot-volumes --include-namespaces nginx-example 18 19# 持久卷恢复 20velero restore create --from-backup nginx-backup-volume --restore-volumes 21 22# 创建集群所有namespaces备份，但排除 velero,metallb-system 命名空间 23velero backup create all-ns-backup --snapshot-volumes=false --exclude-namespaces velero,metallb-system 24 25# 周期性定时备份 26# 每日3点进行备份 27velero schedule create \u0026lt;SCHEDULE NAME\u0026gt; --schedule \u0026#34;0 3 * * *\u0026#34; 28 29# 每日3点进行备份，备份保留48小时，默认保留30天 30velero schedule create \u0026lt;SCHEDULE NAME\u0026gt; --schedule \u0026#34;0 3 * * *\u0026#34; --ttl 48 31 32# 每6小时进行一次备份 33velero create schedule \u0026lt;SCHEDULE NAME\u0026gt; --schedule=\u0026#34;@every 6h\u0026#34; 34 35# 每日对 web namespace 进行一次备份 36velero create schedule \u0026lt;SCHEDULE NAME\u0026gt; --schedule=\u0026#34;@every 24h\u0026#34; --include-namespaces web 迁移 1# 在集群1上做一个备份： 2$ velero backup create \u0026lt;BACKUP-NAME\u0026gt; --snapshot-volumes 3 4# 在集群2上做一个恢复： 5$ velero restore create --from-backup \u0026lt;BACKUP-NAME\u0026gt; --restore-volumes 6 7# velero 清理 8$ kubectl delete namespace/velero clusterrolebinding/velero 9$ kubectl delete crds -l component=velero 参考资料 https://www.cnblogs.com/wubolive/p/17345716.html https://mafeifan.com/DevOps/K8s/k8s-%E5%9F%BA%E7%A1%80-%E4%BD%BF%E7%94%A8Velero%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D%E9%9B%86%E7%BE%A4.html ","permalink":"/tech/kubernetes/%E5%9F%BA%E4%BA%8E-velero-%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D-k8s-%E9%9B%86%E7%BE%A4/","summary":"\u003ch1 id=\"velero-安装步骤\"\u003eVelero 安装步骤\u003c/h1\u003e\n\u003ch2 id=\"客户端\"\u003e客户端\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/vmware-tanzu/velero/releases\"\u003ehttps://github.com/vmware-tanzu/velero/releases\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e下载并安装最新版本二进制客户端。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003ecp velero /usr/local/bin \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e chmod +x /usr/local/bin/velero\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003evelero version\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003eClient:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e5\u003c/span\u003e\u003cspan class=\"cl\"\u003e        Version: v1.13.2\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e6\u003c/span\u003e\u003cspan class=\"cl\"\u003e        Git commit: 4d961fb6fec384ed7f3c1b7c65c818106107f5a6\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e7\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u0026lt;error getting server version: no matches \u003cspan class=\"k\"\u003efor\u003c/span\u003e kind \u003cspan class=\"s2\"\u003e\u0026#34;ServerStatusRequest\u0026#34;\u003c/span\u003e in version \u003cspan class=\"s2\"\u003e\u0026#34;velero.io/v1\u0026#34;\u003c/span\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"服务端\"\u003e服务端\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e准备好秘钥文件 \u003ccode\u003ecredentials-velero\u003c/code\u003e ，即 MinIO 的用户名密码。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e[default]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003eaws_access_key_id=\u0026lt;access key id\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003eaws_secret_access_key=\u0026lt;secret access key\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"2\"\u003e\n\u003cli\u003e使用 \u003ccode\u003evelero install\u003c/code\u003e 安装服务端\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 1\u003c/span\u003e\u003cspan class=\"cl\"\u003evelero install \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e  --provider aws \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e  --image velero/velero:v1.13.2 \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e  --plugins velero/velero-plugin-for-aws:v1.9.2 \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 5\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e  --bucket velero \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e  --secret-file ./credentials-velero \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 7\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e  --use-node-agent \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 8\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e  --use-volume-snapshots\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"nb\"\u003efalse\u003c/span\u003e \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 9\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e  --namespace velero \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e10\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e  --backup-location-config \u003cspan class=\"nv\"\u003eregion\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003eminio,s3ForcePathStyle\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;true\u0026#34;\u003c/span\u003e,s3Url\u003cspan class=\"o\"\u003e=\u003c/span\u003ehttp://10.101.6.118:9000 \u003cspan class=\"se\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e11\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"se\"\u003e\u003c/span\u003e  --wait\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003evelero  version\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003eClient:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e        Version: v1.13.2\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003e        Git commit: 4d961fb6fec384ed7f3c1b7c65c818106107f5a6\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e5\u003c/span\u003e\u003cspan class=\"cl\"\u003eServer:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e6\u003c/span\u003e\u003cspan class=\"cl\"\u003e        Version: v1.13.2\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"velero-使用\"\u003eVelero 使用\u003c/h1\u003e\n\u003ch2 id=\"备份\"\u003e备份\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003evelero create backup NAME [flags]\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003ebackup选项：\u003c/strong\u003e\u003c/p\u003e","title":"基于 Velero 备份与恢复 K8s 集群"},{"content":"Docker 登录私有仓库 首先配置私有仓库免 ssl 验证 1{ 2 \u0026#34;insecure-registries\u0026#34;: [\u0026#34;szharbor.xxx.cn\u0026#34;] 3} 输入用户名密码并登录 1docker login szharbor.xxx.cn 查看登录成功后的 Docker 认证文件 1cat ~/.docker/config.json 1{ 2\t\u0026#34;auths\u0026#34;: { 3\t\u0026#34;szharbor.xxx.cn\u0026#34;: { 4\t\u0026#34;auth\u0026#34;: \u0026#34;cm...nVVM=\u0026#34; 5\t} 6\t} 7} 压缩，base64编码 1{\u0026#34;auths\u0026#34;:{\u0026#34;szharbor.xxx.cn\u0026#34;:{\u0026#34;auth\u0026#34;:\u0026#34;cm9ib3QkaGllbXNfZGV2K3ByaXY6Rk1iSXQ5bFI2RXA5bDd6cU9pUU1MYUg5eVdQWnFnVVM=\u0026#34;}}} 1eyJhdXRocyI6eyJzemhhcmJvci5oaXRoaXVtLmNuIjp7ImF1dGgiOiJjbTlpYjNRa2FHbGxiWE5mWkdWMkszQnlhWFk2UmsxaVNYUTViRkkyUlhBNWJEZDZjVTlwVVUxTVlVZzVlVmRRV25GblZWTT0ifX19 harbor\n1eyJhdXRocyI6eyIxMC4xMDEuNy4xMDg6ODAiOnsiYXV0aCI6ImVtaDFZVzVuY1dZNlFFQXhXR2xoYjNOb1lXZDFZUT09In19fQ== 创建 imagePullSecret 1apiVersion: v1 2kind: Secret 3metadata: 4 name: harbor-secret 5 namespace: szhems 6data: 7 .dockerconfigjson: eyJhdXRocyI6eyJzemhhcmJvci5oaXRoaXVtLmNuIjp7ImF1dGgiOiJjbTlpYjNRa2FHbGxiWE5mWkdWMkszQnlhWFk2UmsxaVNYUTViRkkyUlhBNWJEZDZjVTlwVVUxTVlVZzVlVmRRV25GblZWTT0ifX19 8type: kubernetes.io/dockerconfigjson 将 secret 与 account 绑定\n1apiVersion: v1 2kind: ServiceAccount 3metadata: 4 namespace: szhems 5 name: find-endpoints 6imagePullSecrets: 7 - name: harbor-secret 或者直接将 secret 与 deployment 进行绑定\n1apiVersion: apps/v1 2kind: Deployment 3metadata: 4 name: assets-api 5 namespace: szhems 6 labels: 7 app: assets-api 8spec: 9 selector: 10 matchLabels: 11 app: assets-api 12 template: 13 metadata: 14 labels: 15 app: assets-api 16 spec: 17 serviceAccountName: find-endpoints 18 imagePullSecrets: 19 - name: harbor 20 containers: 21 - name: assets-api 22 image: 10.101.7.108:80/szhems_dev/be_assets_api:0.1.0.210 ","permalink":"/tech/kubernetes/%E5%9F%BA%E4%BA%8E-imagepullsecret-%E4%B8%8B%E8%BD%BD%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E5%88%B6%E5%93%81/","summary":"\u003ch1 id=\"docker-登录私有仓库\"\u003eDocker 登录私有仓库\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e首先配置私有仓库免 ssl 验证\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-json\" data-lang=\"json\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"nt\"\u003e\u0026#34;insecure-registries\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;szharbor.xxx.cn\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e输入用户名密码并登录\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003edocker login szharbor.xxx.cn\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"3\"\u003e\n\u003cli\u003e\u003cstrong\u003e查看登录成功后的 Docker 认证文件\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003ecat ~/.docker/config.json\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-json\" data-lang=\"json\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nt\"\u003e\u0026#34;auths\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026#34;szharbor.xxx.cn\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"nt\"\u003e\u0026#34;auth\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;cm...nVVM=\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e5\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e7\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"4\"\u003e\n\u003cli\u003e\u003cstrong\u003e压缩，base64编码\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e{\u0026#34;auths\u0026#34;:{\u0026#34;szharbor.xxx.cn\u0026#34;:{\u0026#34;auth\u0026#34;:\u0026#34;cm9ib3QkaGllbXNfZGV2K3ByaXY6Rk1iSXQ5bFI2RXA5bDd6cU9pUU1MYUg5eVdQWnFnVVM=\u0026#34;}}}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003eeyJhdXRocyI6eyJzemhhcmJvci5oaXRoaXVtLmNuIjp7ImF1dGgiOiJjbTlpYjNRa2FHbGxiWE5mWkdWMkszQnlhWFk2UmsxaVNYUTViRkkyUlhBNWJEZDZjVTlwVVUxTVlVZzVlVmRRV25GblZWTT0ifX19\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eharbor\u003c/p\u003e","title":"基于 imagePullSecret 下载私有镜像仓库制品"},{"content":"Kubernetes 网络的功能：\n高度耦合的容器间通信：这个已经被 Pods 和 localhost 通信解决了。 Pod 间通信； Pod 和 Service 对象间通信； 外部和 Service 对象间通信； Kubernetes 本身的网络服务自带了一下功能：\nNAT: 网络地址转换 Source NAT: 替换数据包的源 IP, 通常为节点的 IP Destination NAT: 替换数据包的目的 IP, 通常为 Pod 的 IP VIP: 一个虚拟 IP, 例如分配给每个 Kubernetes Service 的 IP Kube-proxy: 一个网络守护程序，在每个节点上协调 Service VIP 管理 可参考 https://kubernetes.io/zh/docs/tutorials/services/source-ip/\n1. Pod IP 对于 Docker 中的 container 网络。多个容器共享一个容器的网络接口，实现多个容器共享网络、同一个 IP、同一个 hostname。\nK8S 中 Pod 内多容器共享网络就是这样创建的，Pod 的 IP 是 Docker 创建和分配的容器 IP，这个 IP 是带虚拟网卡的，因此这个 IP 是可以被 ping 的，但是该 IP 只能在当前节点中被访问。\n首先，创建 Pod 时，Pod 会启动一个 pause 容器，该容器创建了一个虚拟网卡，并被 Docker 分配 IP，接着 Pod 的容器会使用 container 网络模式连接到这个 pause 容器中，pause 容器的生命周期跟 Pod 的生命周期一致。\n在工作节点上使用 docker ps -a | grep pause 命令查看 pause 容器：\n1[root@test-60g ~]# minikube ssh 2docker@minikube:~$ docker ps -a |grep pause 367461274c207 registry.k8s.io/pause:3.9 \u0026#34;/pause\u0026#34; 25 hours ago Up 25 hours k8s_POD_nginx-7cf478bb58-h6zq9_default_4df3bc0f-7efa-4ef1-9d46-e6b300143eeb_2 4... 不过，Docker 中的容器 IP 是 172.17.0.0 地址段，而 Pod IP 的地址段一般是 10.x.x.x 网络，其中用户自定义 Pod 是 10.32.0.0 地址段。\nPod 的 IP 是 Docker 分配的，为什么其地址不是 172.17.0.0 地址段？\n首先，在部署了 Docker 的机器上，都会有一个名为 docker0 的网桥。\n1docker0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 2 inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255 3 inet6 fe80::42:2aff:fe00:6577 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; 4 ether 02:42:2a:00:65:77 txqueuelen 0 (Ethernet) 5 RX packets 4404 bytes 155753 (152.1 KiB) 6 RX errors 0 dropped 0 overruns 0 frame 0 7 TX packets 3340 bytes 158865 (155.1 KiB) 8 TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 docker 的默认网桥叫 docker0，这个网桥的 IP 是 172.17.0.1，基于这个网桥创建的容器的虚拟网卡自然是 172.17.0.0 地址段。\n而如果我们使用 weava 网络插件部署集群，那么使用 ifconfig 命令，可以找到一个 weava 的自定义网桥：\n1weave: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1376 2 inet 10.32.0.1 netmask 255.240.0.0 broadcast 10.47.255.255 3 inet6 fe80::ac45:ebff:fe0a:31ae prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; 4 ether ae:45:eb:0a:31:ae txqueuelen 1000 (Ethernet) 5 RX packets 2905588 bytes 391313728 (391.3 MB) 6 RX errors 0 dropped 0 overruns 0 frame 0 7 TX packets 3179102 bytes 640814125 (640.8 MB) 8 TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 通过 Kubernetes 创建的自定义 Pod，会使用这个网桥创建 IP，其 IP 地址跟网络插件创建的网桥有关。\n更多的 Docker 网络知识: https://docs.docker.com/network/bridge/\n跨节点访问 Pod 既然 Pod 的 IP 是 Docker 创建的，而 Docker 创建的 IP 只能在本地服务器上访问，那么怎么才能在别的节点上访问这个 Pod IP？\n网络插件，除了 weave ，还有很多网络插件可以使用，如 calico、flannel。Kubernetes 网络模型中有个叫 CNI 的标准接口，只要实现了这个接口，用啥网络插件都没问题，使用者不需要关心插件是怎么实现的。\nCNI 的主要功能：\n节点上的 Pod 可以不通过 NAT 和其他任何节点上的 Pod 通信(称为扁平化网络)，即节点间 Pod 的互相访问； 节点上的代理（比如：系统守护进程、kubelet）可以和节点上的所有 Pod 通信，即系统组件访问 Pod； 2. Service Service 是 Kubernetes 的对象，它跟网络有关， Service 不是服务提供者，也不是应用程序接口。\nService 是将运行在一组 Pods 上的应用程序，公开为网络服务的抽象方法。\n如果我们使用 Deployment 、Daemon 等部署 Pod，则可为此控制器创建 Service，Service 会监控此 Deployment 上增加或移除 Pod 的操作，自动为所有 Pod 提供网络服务。当然，Service 并不是指向 Deployment、Daemon 的，而是通过 Label 指向相关的 Pod。\n2.1 Service 的定义和创建 我们创建一个 Deployment 对象，包含三个 Pod 实例。\n1kubectl create deployment nginx --image=nginx:latest --replicas=3 接着，为这些 Pod 创建一个 Service。\n1kubectl expose deployment nginx --type=ClusterIP --port=6666 --target-port=80 查看创建的 Service：\n1[root@zqf-master1 ~]# k get svc -o wide 2NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTOR 3kubernetes ClusterIP 10.96.0.1 \u0026lt;none\u0026gt; 443/TCP 17m \u0026lt;none\u0026gt; 4nginx ClusterIP 10.101.6.208 \u0026lt;none\u0026gt; 6666/TCP 7s app=nginx 可以看到，Service 会生成一个随机 IP 10.101.6.208，我们为 Pod 映射了一个新的端口为 6666，此端口映射到了 Pod 的 80 端口中，我们可以测试这个 IP 和 端口是否可用：\n1[root@zqf-master1 ~]# curl 10.101.6.208:6666 2\u0026lt;!DOCTYPE html\u0026gt; 3\u0026lt;html\u0026gt; 4\u0026lt;head\u0026gt; 5\u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; 6\u0026lt;style\u0026gt; 7html { color-scheme: light dark; } 8body { width: 35em; margin: 0 auto; 9font-family: Tahoma, Verdana, Arial, sans-serif; } 10\u0026lt;/style\u0026gt; 11\u0026lt;/head\u0026gt; 12\u0026lt;body\u0026gt; 13\u0026lt;h1\u0026gt;Welcome to nginx!\u0026lt;/h1\u0026gt; 14\u0026lt;p\u0026gt;If you see this page, the nginx web server is successfully installed and 15working. Further configuration is required.\u0026lt;/p\u0026gt; 16 17\u0026lt;p\u0026gt;For online documentation and support please refer to 18\u0026lt;a href=\u0026#34;http://nginx.org/\u0026#34;\u0026gt;nginx.org\u0026lt;/a\u0026gt;.\u0026lt;br/\u0026gt; 19Commercial support is available at 20\u0026lt;a href=\u0026#34;http://nginx.com/\u0026#34;\u0026gt;nginx.com\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; 21 22\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; 23\u0026lt;/body\u0026gt; 24\u0026lt;/html\u0026gt; 在没有安装网络插件的前提下，假如有 master、slave 两个节点，Pod 都被部署到 slave 节点上，而 master 节点没有部署此 Pod 的话，master 是访问不了此 Service的。\n为了验证这样情况，我们可以消去 master 的污点，使其能够被部署用户自定义的 Pod。\n1kubectl taint node zqf-master1 node-role.kubernetes.io/control-plane:NoSchedule- 然后重新部署 Deployment，但是不需要重新部署 Service。\n1kubectl delete deployyment nginx 2kubectl create deployment nginx --image=nginx:latest --replicas=3 查看这些 Pod 都被部署到哪里：\n1[root@zqf-master1 ~]# k get po -o wide 2NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES 3nginx-56fcf95486-lg4bf 0/1 ContainerCreating 0 5s \u0026lt;none\u0026gt; zqf-slave1 \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 4nginx-56fcf95486-m5v5b 0/1 ContainerCreating 0 5s \u0026lt;none\u0026gt; zqf-master1 \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 5nginx-56fcf95486-vjk2p 0/1 ContainerCreating 0 5s \u0026lt;none\u0026gt; zqf-slave1 \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 现在，master、slave 都部署了 Pod，那么我们在 master 节点上访问此 Service，可以正常访问。\n在 Deployment 对象上创建 Service，会直接关联一个 Deployment 中的所有 Pod，并监控是否有新建或移除 Pod ，无论 Pod 的数量有多少，Service 都可以代理这些 Pod。\n如果我们通过 YAML 定义 Service，其模板如下：\n1apiVersion: v1 2kind: Service 3metadata: 4 name: my-service 5spec: 6 selector: 7 app: MyApp 8 ports: 9 - protocol: TCP 10 port: 6666 11 targetPort: 80 12 type: ClusterIP 由于 Service 的 IP 是虚拟的，因此此 IP 是无法 Ping 通的。\n2.2 Service 外部服务类型 虽然创建了 Service 后，所有的 Pod 可以被一个 IP 地址访问，但是这个 IP 只能在被部署了 Pod 的节点中访问， 不能被集群外访问，这是因为我们创建 Service 的时候，使用了 ClusterIP 类型，如果是 NodePort 类型，则可以被外界访问到。\nKubernetes Service 有个 ServiceType ，允许我们指定如何暴露服务，可以将一个 Service 暴露到集群外部，外界可以通过 IP 访问这个 Service。\nType 有四种类型，其取值说明如下：\nClusterIP：通过集群内部 IP 暴露服务，ClusterIP 是 ServiceType 的默认值。 NodePort：通过每个节点上的 IP 和静态端口（NodePort）暴露服务。由于其是节点上的 ，所以具有通过节点的公网 IP 访问这个服务。 LoadBalancer：使用负载均衡器向外部暴露服务。 外部负载均衡器可以将流量路由到自动创建的 NodePort 服务和 ClusterIP 服务上。需要云平台服务提供商的支持，分配公网 IP 才能使用。 ExternalName：通过返回 CNAME 和对应值，可以将服务映射到 externalName 字段的内容（例如，foo.bar.example.com）。 需要使用 kube-dns 1.7 及以上版本或者 CoreDNS 0.0.8 及以上版本才能使用 ExternalName 类型。\nClusterIP、NodePort、LoadBalancer 三者是有关系的，前者是后者的基础。创建一个 NodePort 类型的 Service，必定带有一个 ClusterIP；创建一个 LoadBalancer，必定带有 ClusterIP、NodePort。\n2.2.1 NodePort 将前面创建的 Service 修改为 NodePort 类型\n1kubectl edit service nginx 然后查看 Service 列表：\n1[root@zqf-master1 ~]# k get svc -o wide 2NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTOR 3kubernetes ClusterIP 10.96.0.1 \u0026lt;none\u0026gt; 443/TCP 33m \u0026lt;none\u0026gt; 4nginx NodePort 10.101.6.208 \u0026lt;none\u0026gt; 6666:31292/TCP 16m app=nginx 此时 Service 会创建一个 随机端口，这个端口映射到每个部署了 Pod 的节点上，样例中是31292，此时外界可以通过使用节点 IP 访问此 Service。\n此时，可以在集群其他机器访问两台节点 IP http://10.101.5.219:31292/ 和 http://10.101.5.220:31292/ 可以正常返回 nginx 网页。\n2.2.2 LoadBalancer 现在 Pod 负载均衡了，但不能只访问一个节点？节点的网络也需要负载均衡，而且节点 IP 这么多，用户总不能记住这么多 IP ？就算使用域名，域名也不能绑定这么多 IP 呀，此时应该使用 LoadBalancer 。\n删除之前的 service ，重新创建。\n1kubectl expose deployment nginx --type=LoadBalancer --port=6666 --target-port=80 如果只填写 \u0026ndash;port ，此时映射的端口跟 Pod 端口一致\n1[root@zqf-master1 ~]# k get svc 2NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE 3kubernetes ClusterIP 10.96.0.1 \u0026lt;none\u0026gt; 443/TCP 54m 4nginx LoadBalancer 10.106.1.221 \u0026lt;pending\u0026gt; 6666:31960/TCP 19s 当使用 LoadBalancer 暴露服务到集群外部网络时，云基础设施需要时间来创建负载均衡器并获取服务中的 IP 地址。如果使用的是 minikube、kubeadm 等创建的自定义 Kubernetes 集群，没有集成 LoadBalancer ，则会一直处于 \u0026lt;Pending\u0026gt; 状态。\n2.3 Service 如何选择 Pod 通过命令查看 iptables 配置：\n1iptables-save 在终端控制台中查找 random 关键字：\n1-A KUBE-SVC-2CMXP7HKUVJN7L6M -m comment --comment \u0026#34;default/nginx -\u0026gt; 172.16.41.201:80\u0026#34; -m statistic --mode random --probability 0.33333333349 -j KUBE-SEP-KVETUJWAGOYJMI5D 2-A KUBE-SVC-2CMXP7HKUVJN7L6M -m comment --comment \u0026#34;default/nginx -\u0026gt; 172.16.41.202:80\u0026#34; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-OGCI3CVDD3KXHXYJ 3-A KUBE-SVC-2CMXP7HKUVJN7L6M -m comment --comment \u0026#34;default/nginx -\u0026gt; 172.16.41.203:80\u0026#34; -j KUBE-SEP-PEONUJMSH5W46AFI 有三个 default/nginx， 第一个 pod 被访问的机会是 0.33333...。在剩下的 2/3 的概率中，有 0.5 的概率选择第二个 Pod，剩下的 1/3 概率选择第三个 Pod。这种随机选择的模式称为 iptables 代理模式，也就是 kube-proxy 的默认模式。\n2.4 kube-proxy 三种代理模式 当我们使用命令创建一个 Service 时，可看到每个 Service 都有一个 IP 地址，这是由 kube-proxy 负责为 Service 实现的一种虚拟 IP ，即 ClusterIP。\nkube-proxy 可以为多个 Pod 创建一个统一的代理，在访问 Service 时，自动选择一个 Pod 提供服务，至于如何选择 Pod，kube-proxy 有三种模式。\nuserspace 代理模式 iptables 代理模式(默认) IPVS 代理模式（Kubernetes v1.11 ，如果要使用 IPVS，需要修改配置激活） 在这些代理模式中，客户端可以在不了解 Kubernetes 服务或 Pod 的任何信息的情况下，将 Port 代理到适当的后端。\n2.4.1 userspace 代理模式 userspace 模式下， kube-proxy 通过轮转算法选择 pod。\n对每个 Service，它会在本地 Node 上打开一个端口(端口号大于 30000)。 任何连接到此端口的请求，都会被代理到 Service 后端的某个 Pod 上。 使用哪个后端 Pod，是 kube-proxy 基于 YAML 的 SessionAffinity 终端来确定的。\n最后，配置 iptables 规则，捕获到达该 Service 的 clusterIP 和 Port 的请求，并重定向到代理端口，代理端口再代理请求到后端 Pod。\n1访问 -\u0026gt; clusterIP -\u0026gt; 代理 -\u0026gt; 任一 Pod 2.4.2 iptables 代理模式 kube-proxy 默认模式。iptables 代理模式的策略随机选择一个 Pod。\n它会为每个 Service 配置 iptables 规则，捕获所有访问此 Service clusterIP 的请求，进而将请求重定向到 Service 的一组后端中的某个 Pod 上面。 对于每个 Endpoints 对象，它也会配置 iptables 规则，这个规则会选择一个后端组合。\n使用 iptables 处理流量具有较低的系统开销，因为流量由 Linux netfilter 处理， 而无需在用户空间和内核空间之间切换， 这种方法也可能更可靠。\n如果 kube-proxy 在 iptables 模式下运行，如果随机所选的第一个 Pod 没有响应， 则连接会失败，在这种情况下，会自动使用其他后端 Pod 重试 。\n2.4.3 IPVS 代理模式 与其他代理模式相比，IPVS 模式支持更高的网络流量吞吐量。与 iptables 模式下的 kube-proxy 相比，IPVS 模式下的 kube-proxy 重定向通信的延迟要短，并且在同步代理规则时具有更好的性能。\nIPVS 提供了更多选项来平衡后端 Pod 的流量。 这些是：\nrr：轮替（Round-Robin） lc：最少链接（Least Connection），即打开链接数量最少者优先 dh：目标地址哈希（Destination Hashing） sh：源地址哈希（Source Hashing） sed：最短预期延迟（Shortest Expected Delay） nq：从不排队（Never Queue） Service 暴露多端口\n如果要在 Service 中暴露多个端口，则每个端口都需要设置一个名字。\n1 ports: 2 - name: p1 3 port: 2323 4 protocol: TCP 5 targetPort: 81 6 - name: p2 7 port: 6666 8 protocol: TCP 9 targetPort: 82 ","permalink":"/tech/kubernetes/k8s-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","summary":"\u003cp\u003eKubernetes 网络的功能：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e高度耦合的容器间通信：这个已经被 Pods 和 \u003ccode\u003elocalhost\u003c/code\u003e 通信解决了。\u003c/li\u003e\n\u003cli\u003ePod 间通信；\u003c/li\u003e\n\u003cli\u003ePod 和 Service 对象间通信；\u003c/li\u003e\n\u003cli\u003e外部和 Service 对象间通信；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eKubernetes 本身的网络服务自带了一下功能：\u003c/p\u003e","title":"K8s 网络模型基础知识"},{"content":"1. 基础配置 首先，在所有 master 节点和 worker 节点上安装 nfs-utils.\n1sudo yum -y install nfs-utils 2systemctl enable nfs-utils 2. NFS Server 配置 服务端安装 nfs-utils 和 rpcbind 1sudo yum -y install nfs-utils rpcbind 2systemctl enable nfs-utils 3systemctl enable rpcbind 创建共享目录 1mkdir /hc-data/nfs **创建并修改配置文件 配置文件为 /etc/exports\n1sudo vim /etc/exports 2# 添加配置 3/hc-data/nfs 172.24.71.32/24(rw,no_root_squash,no_all_squash,sync) 4/hc-data/nfs 172.24.71.34/24(rw,no_root_squash,no_all_squash,sync) 5/hc-data/nfs 172.24.71.35/24(rw,no_root_squash,no_all_squash,sync) 6/hc-data/nfs 172.24.71.36/24(rw,no_root_squash,no_all_squash,sync) 7/hc-data/nfs 172.24.71.37/24(rw,no_root_squash,no_all_squash,sync) 8/hc-data/nfs 172.24.71.38/24(rw,no_root_squash,no_all_squash,sync) 9/hc-data/nfs 172.24.71.39/24(rw,no_root_squash,no_all_squash,sync) /opt/nfs 10.101.5.111/24(rw,no_root_squash,no_all_squash,sync) /opt/nfs 10.101.5.112/24(rw,no_root_squash,no_all_squash,sync) /opt/nfs 10.101.5.113/24(rw,no_root_squash,no_all_squash,sync) /opt/nfs 10.101.5.114/24(rw,no_root_squash,no_all_squash,sync) /opt/nfs 10.101.5.115/24(rw,no_root_squash,no_all_squash,sync) /opt/nfs 10.101.5.116/24(rw,no_root_squash,no_all_squash,sync) /opt/nfs 10.101.5.117/24(rw,no_root_squash,no_all_squash,sync)\n对于 /hc-data/nfs 172.24.71.32/24(rw,no_root_squash,no_all_squash,sync) ，表示服务端允许 IP 地址为 172.24.71.32 的主机进行访问 /hc-data/nfs 目录，参数的含义表示可读写、数据同步写入等。\n保存后，使配置生效，并重启服务\n1sudo exportfs -r 2sudo service rpcbind restart 3sudo service nfs-server restart 查看服务端挂载情况 1showmount -e localhost 1# showmount -e localhost 2Export list for localhost: 3/hc-data/nfs 172.24.71.39/24,172.24.71.38/24,172.24.71.37/24,172.24.71.36/24,172.24.71.35/24,172.24.71.34/24,172.24.71.32/24 3. K8s 主节点配置 3.1 K8s NFS 插件安装 仓库地址： https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner\nHelm 添加仓库 1helm repo add nfs-subdir-external-provisioner https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner/ 安装 nfs-subdir-external-provisioner helm 安装 1helm install nfs-subdir-external-provisioner nfs-subdir-external-provisioner/nfs-subdir-external-provisioner \\ 2--set nfs.server=172.24.71.33 \\ 3--set nfs.path=/hc-data/nfs 本地安装 下载 nfs-subdir-external-provisioner 到本地目录后 1helm pull nfs-subdir-external-provisioner/nfs-subdir-external-provisioner 修改 values.yaml 文件 然后执行\n1helm install nfs-client-provisioner . 配置默认 StorageClass 配置默认 StorageClass 命令如下\n1kubectl patch storageclass nfs-client -p \u0026#39;{\u0026#34;metadata\u0026#34;: {\u0026#34;annotations\u0026#34;:{\u0026#34;storageclass.kubernetes.io/is-default-class\u0026#34;:\u0026#34;true\u0026#34;}}}\u0026#39; 然后，查看当前集群 StorageClass 情况，名为 nfs-client 的 sc 已经成功创建，并已设置为默认 sc。\n1kubectl get sc 2NAME PROVISIONER RECLAIMPOLICY VOLUMEBINDINGMODE ALLOWVOLUMEEXPANSION AGE 3nfs-client (default) cluster.local/nfs-client-provisioner-nfs-subdir-external-provisioner Delete Immediate true 30m 3.2 创建 PVC PVC 的 yaml 文件如下所示：\n1apiVersion: v1 2kind: PersistentVolumeClaim 3metadata: 4 name: prometheus-pvc 5 namespace: monitoring 6spec: 7 storageClassName: nfs-client 8 accessModes: 9 - ReadWriteOnce 10 resources: 11 requests: 12 storage: 50Gi # 请求与 PersistentVolume 匹配的存储容量 执行 kubectl apply 后， 查看 PVC 构建情况， prometheus-pvc 的状态 bound， 构建成功。\n1kubectl get pvc -n monitoring 2NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE 3prometheus-pvc Bound pvc-6003bba1-95f7-43b0-a3f8-5bdce01f2c98 50Gi RWO nfs-client 58m ","permalink":"/tech/kubernetes/%E4%BD%BF%E7%94%A8-nfs-%E4%BD%9C%E4%B8%BA-k8s-%E5%AD%98%E5%82%A8%E6%8F%92%E4%BB%B6/","summary":"\u003ch1 id=\"1-基础配置\"\u003e1. 基础配置\u003c/h1\u003e\n\u003cp\u003e首先，在所有 master 节点和 worker 节点上安装 nfs-utils.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003esudo yum -y install nfs-utils\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003esystemctl \u003cspan class=\"nb\"\u003eenable\u003c/span\u003e nfs-utils\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"2-nfs-server-配置\"\u003e2. NFS Server 配置\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e服务端安装 nfs-utils 和 rpcbind\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003esudo yum -y install nfs-utils rpcbind\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003esystemctl \u003cspan class=\"nb\"\u003eenable\u003c/span\u003e nfs-utils\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003esystemctl \u003cspan class=\"nb\"\u003eenable\u003c/span\u003e rpcbind\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e创建共享目录\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003emkdir /hc-data/nfs\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"3\"\u003e\n\u003cli\u003e**创建并修改配置文件\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e配置文件为 \u003ccode\u003e/etc/exports\u003c/code\u003e\u003c/p\u003e","title":"使用 NFS 作为 K8s 存储插件"},{"content":"核心参数\n1proxy_buffering off; 该指令使 Nginx 不缓冲来自上游服务器的响应，而是立即将其发送给客户端。适合需要实时或流式传输数据的场景非常有用，比如实时聊天、流媒体等。\n1proxy_buffering off; 表示启用代理缓冲，Nginx 将缓冲来自后端服务器的响应，并在接收完整响应后才将其发送给客户端。这可以提高性能并减少对后端服务器的请求频率，但可能会导致延迟。\n","permalink":"/tech/ops/nginx-%E5%AE%9E%E7%8E%B0-gpt-%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93/","summary":"\u003cp\u003e\u003cstrong\u003e核心参数\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003eproxy_buffering off;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e该指令使 Nginx 不缓冲来自上游服务器的响应，而是立即将其发送给客户端。适合需要实时或流式传输数据的场景非常有用，比如实时聊天、流媒体等。\u003c/p\u003e","title":"Nginx 实现 GPT 流式传输"},{"content":"堆内存与栈内存 Go 在 2 个位置为变量分配内存，全局堆(heap)空间，和每个 goroutine 的栈(stack)空间。\nGo 语言实现 GC 机制，因此开发者不需要关心内存分配在栈上，还是堆上。但是从性能的角度出发，在栈上分配内存和在堆上分配内存，性能差异是非常大的。\n在函数中申请一个对象，如果分配在栈中，函数执行结束时自动回收；如果分配在堆中，则在函数结束后某个时间点进行垃圾回收。\n在栈上分配和回收内存的开销很低，只需要 2 个 CPU 指令：PUSH 和 POP，也就是说，在栈上分配内存，消耗的仅是将数据拷贝到内存的时间，而内存的 I/O 通常能够达到 30GB/s。\n在堆上分配内存主要的开销是垃圾回收。Go 语言使用标记清除算法，并且在此基础上使用了三色标记法和写屏障技术，提高了效率。\n逃逸分析 Go 语言中堆内存由 GC 机制自动管理的。编译器决定内存分配位置的方式，就称之为逃逸分析(escape analysis)。逃逸分析由编译器完成，作用于编译阶段。\n指针 函数中创建了一个对象，返回了这个对象的指针。这种情况下，函数虽然退出了，但是因为指针的存在，该对象的内存不能随着函数结束而回收，因此只能分配在堆上。\n1package main 2 3import \u0026#34;fmt\u0026#34; 4 5type Demo struct { 6\tname string 7} 8 9func createDemo(name string) *Demo { 10\td := new(Demo) // 局部变量 d 逃逸到堆 11\td.name = name 12\treturn d 13} 14 15func main() { 16\tdemo := createDemo(\u0026#34;demo\u0026#34;) 17\tfmt.Println(demo) 18} 其中，局部变量 d 发生了逃逸。d 作为返回值在 main 函数中继续使用，因此 d 指向的内存不能够分配在栈上随着函数结束而回收，只能分配在堆上。\n编译时借助选项 -gcflags=-m 可以查看变量逃逸的情况：\n1go build -gcflags=-m cmd/main.go 2# command-line-arguments 3cmd/main.go:9:6: can inline createDemo 4cmd/main.go:16:20: inlining call to createDemo 5cmd/main.go:17:13: inlining call to fmt.Println 6cmd/main.go:9:17: leaking param: name 7cmd/main.go:10:10: new(Demo) escapes to heap 8cmd/main.go:16:20: new(Demo) escapes to heap 9cmd/main.go:17:13: ... argument does not escape interface 空接口即 interface{} 可以表示任意的类型，如果函数参数为 interface{}，编译期间很难确定其参数的具体类型，也会发生逃逸。\n1func main() { 2\tdemo := createDemo(\u0026#34;demo\u0026#34;) 3\tfmt.Println(demo) 4} demo 是 main 函数中的一个局部变量，该变量作为实参传递给 fmt.Println()，但是因为 fmt.Println() 的参数类型定义为 interface{}，因此也发生了逃逸。\n栈空间不足 操作系统对内核线程使用的栈空间是有大小限制的，64 位系统上通常是 8 MB。\n可以使用 ulimit -a 命令查看机器上栈允许占用的内存的大小。\n1# ulimit -a 2real-time non-blocking time (microseconds, -R) unlimited 3core file size (blocks, -c) 0 4data seg size (kbytes, -d) unlimited 5scheduling priority (-e) 0 6file size (blocks, -f) unlimited 7pending signals (-i) 127151 8max locked memory (kbytes, -l) unlimited 9max memory size (kbytes, -m) unlimited 10open files (-n) 131072 11pipe size (512 bytes, -p) 8 12POSIX message queues (bytes, -q) 819200 13real-time priority (-r) 0 14stack size (kbytes, -s) 8192 15cpu time (seconds, -t) unlimited 16max user processes (-u) 65535 17virtual memory (kbytes, -v) unlimited 18file locks (-x) unlimited 1stack size (kbytes, -s) 8192 因为栈空间通常比较小，因此递归函数实现不当时，容易导致栈溢出。\n对于 Go 语言来说，运行时(runtime) 尝试在 goroutine 需要的时候动态地分配栈空间，goroutine 的初始栈大小为 2 KB。当 goroutine 被调度时，会绑定内核线程执行，栈空间大小也不会超过操作系统的限制。\n对 Go 编译器而言，超过一定大小的局部变量将逃逸到堆上，不同的 Go 版本的大小限制可能不一样。\n1package main 2 3import \u0026#34;math/rand\u0026#34; 4 5func generate8192() { 6\tnums := make([]int, 8192) // = 64KB 7\tfor i := 0; i \u0026lt; 8192; i++ { 8\tnums[i] = rand.Int() 9\t} 10} 11 12func generate8193() { 13\tnums := make([]int, 8193) // \u0026gt; 64KB 14\tfor i := 0; i \u0026lt; 8193; i++ { 15\tnums[i] = rand.Int() 16\t} 17} 18 19func generate(n int) { 20\tnums := make([]int, n) // 不确定大小 21\tfor i := 0; i \u0026lt; n; i++ { 22\tnums[i] = rand.Int() 23\t} 24} 25 26func main() { 27\tgenerate8192() 28\tgenerate8193() 29\tgenerate(1) 30} 1# go build -gcflags=-m main.go 2# command-line-arguments 3cmd/main.go:6:14: make([]int, 8192) does not escape 4cmd/main.go:13:14: make([]int, 8193) escapes to heap 5cmd/main.go:20:14: make([]int, n) escapes to heap make([]int, 8192) 没有发生逃逸，make([]int, 8193) 和make([]int, n) 逃逸到堆上。\n也就是说，当切片占用内存超过一定大小，或无法确定当前切片长度时，对象占用内存将在堆上分配。\n闭包 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。\n1func Increase() func() int { 2\tn := 0 3\treturn func() int { 4\tn++ 5\treturn n 6\t} 7} 8 9func main() { 10\tin := Increase() 11\tfmt.Println(in()) // 1 12\tfmt.Println(in()) // 2 13} Increase() 返回值是一个闭包函数，该闭包函数访问了外部变量 n，那变量 n 将会一直存在，直到 in 被销毁。很显然，变量 n 占用的内存不能随着函数 Increase() 的退出而回收，因此将会逃逸到堆上。\n1./main.go:6:2: moved to heap: n 2./main.go:7:9: func literal escapes to heap 3./main.go:14:16: func literal does not escape 4./main.go:15:13: ... argument does not escape 5./main.go:15:16: ~R0 escapes to heap 6./main.go:16:13: ... argument does not escape 7./main.go:16:16: ~R0 escapes to heap 传值 VS 传指针 传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。\n传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加 GC 开销。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。\n一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的、占用内存较小的结构体，直接传值能够获得更好的性能。\n","permalink":"/tech/golang/golang-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/","summary":"\u003ch1 id=\"堆内存与栈内存\"\u003e堆内存与栈内存\u003c/h1\u003e\n\u003cp\u003eGo 在 2 个位置为变量分配内存，全局堆(heap)空间，和每个 goroutine 的栈(stack)空间。\u003c/p\u003e\n\u003cp\u003eGo 语言实现 GC 机制，因此开发者不需要关心内存分配在栈上，还是堆上。但是从性能的角度出发，在栈上分配内存和在堆上分配内存，性能差异是非常大的。\u003c/p\u003e","title":"Golang 逃逸分析"},{"content":"在 Go 语言中，空结构体 struct{} 是一个非常特殊的类型，它不包含任何字段且不占用任何内存空间。\n空结构体不占用内存空间 1type Empty struct{} 2 3func main() { 4 5\tvar s1 struct{} 6\ts2 := Empty{} 7\ts3 := struct{}{} 8 9\tfmt.Printf(\u0026#34;s1 addr: %p, size: %d\\n\u0026#34;, \u0026amp;s1, unsafe.Sizeof(s1)) 10\tfmt.Printf(\u0026#34;s2 addr: %p, size: %d\\n\u0026#34;, \u0026amp;s2, unsafe.Sizeof(s2)) 11\tfmt.Printf(\u0026#34;s3 addr: %p, size: %d\\n\u0026#34;, \u0026amp;s3, unsafe.Sizeof(s3)) 12\tfmt.Printf(\u0026#34;s1 == s2 == s3: %t\\n\u0026#34;, s1 == s2 \u0026amp;\u0026amp; s2 == s3) 13} 得到输出如下\n1s1 addr: 0x1048507c0, size: 0 2s2 addr: 0x1048507c0, size: 0 3s3 addr: 0x1048507c0, size: 0 4s1 == s2 == s3: true 由上可得：\n多个空结构体内存地址相同。 空结构体占用字节数为 0，即不占用内存空间。 空结构体之间的值相等。 但是，对于结论 1，有一些特殊情况。\n1func main() { 2 3\tvar ( 4\ta struct{} 5\tb struct{} 6\tc struct{} 7\td struct{} 8\t) 9 10\tprintln(\u0026#34;\u0026amp;a:\u0026#34;, \u0026amp;a) 11\tprintln(\u0026#34;\u0026amp;b:\u0026#34;, \u0026amp;b) 12\tprintln(\u0026#34;\u0026amp;c:\u0026#34;, \u0026amp;c) 13\tprintln(\u0026#34;\u0026amp;d:\u0026#34;, \u0026amp;d) 14 15\tprintln(\u0026#34;\u0026amp;a == \u0026amp;b:\u0026#34;, \u0026amp;a == \u0026amp;b) 16\tx := \u0026amp;a 17\ty := \u0026amp;b 18\tprintln(\u0026#34;x == y:\u0026#34;, x == y) 19 20\tfmt.Printf(\u0026#34;\u0026amp;c(%p) == \u0026amp;d(%p): %t\\n\u0026#34;, \u0026amp;c, \u0026amp;d, \u0026amp;c == \u0026amp;d) 21} 这段代码中定义了 4 个空结构体，依次打印它们的内存地址，然后又分别对比了 a 与 b 的内存地址，和 c 与 d 的内存地址两两是否相等。输出结果如下：\n1go run -gcflags=\u0026#39;-m -N -l\u0026#39; main.go 使用 -gcflags 选项向 Go 编译器传递标志，这些标志会影响编译器的行为。\n-m 标志用于启动编译器的内存逃逸分析。 -N 标志用于禁用编译器优化。 -l 标志用于禁用函数内联。\n1# command-line-arguments 2./main.go:12:3: moved to heap: c 3./main.go:13:3: moved to heap: d 4./main.go:26:12: ... argument does not escape 5./main.go:26:50: \u0026amp;c == \u0026amp;d escapes to heap 6\u0026amp;a: 0x1400011ae84 7\u0026amp;b: 0x1400011ae84 8\u0026amp;c: 0x1048987e0 9\u0026amp;d: 0x1048987e0 10\u0026amp;a == \u0026amp;b: false 11x == y: true 12\u0026amp;c(0x1048987e0) == \u0026amp;d(0x1048987e0): true 根据输出可以发现，变量 c 和 d 发生了内存逃逸，并且最终二者的内存地址相同，相等比较结果为 true。\n而 a 和 b 两个变量的输出结果就比较有意思了，两个变量没有发生内存逃逸，并且二者打印出来的内存地址相同，但内存地址相等比较结果却为 false。\nA struct or array type has size zero if it contains no fields (or elements, respectively) that have a size greater than zero. Two distinct zero-size variables may have the same address in memory. Size and alignment guarantees¶\n因此，正确结论为：「多个空结构体内存地址可能相同」。\n空结构体影响内存对齐 空结构体也并不是什么时候都不会占用内存空间，比如空结构体作为另一个结构体字段时，根据位置不同，可能因内存对齐原因，导致外层结构体大小不一样：\n1func main() { 2 3\ttype A struct { 4\tx int 5\ty string 6\tz struct{} 7\t} 8 9\ttype B struct { 10\tx int 11\tz struct{} 12\ty string 13\t} 14 15\ttype C struct { 16\tz struct{} 17\tx int 18\ty string 19\t} 20 21\ta := A{} 22\tb := B{} 23\tc := C{} 24\tfmt.Printf(\u0026#34;struct a size: %d\\n\u0026#34;, unsafe.Sizeof(a)) 25\tfmt.Printf(\u0026#34;struct b size: %d\\n\u0026#34;, unsafe.Sizeof(b)) 26\tfmt.Printf(\u0026#34;struct c size: %d\\n\u0026#34;, unsafe.Sizeof(c)) 27} 执行示例代码，输出结果如下：\n1struct a size: 32 2struct b size: 24 3struct c size: 24 由上可得，当空结构体放在另一个结构体最后一个字段时，会触发内存对齐。\n此时外层结构体会占用更多的内存空间，所以如果你的程序对内存要求比较严格，则在使用空结构体作为字段时需要考虑这一点。\n空结构体常见用法 实现 Set 结构体最常用的地方，就是用来实现 set(集合) 类型。\nGo 语言在语法层面没有提供 set 类型。不过我们可以很方便的使用 map + struct{} 来实现 set 类型，代码如下：\n1// Set 基于空结构体实现 set 2type Set map[string]struct{} 3 4// Add 添加元素到 set 5func (s Set) Add(element string) { 6\ts[element] = struct{}{} 7} 8 9// Remove 从 set 中移除元素 10func (s Set) Remove(element string) { 11\tdelete(s, element) 12} 13 14// Contains 检查 set 中是否包含指定元素 15func (s Set) Contains(element string) bool { 16\t_, exists := s[element] 17\treturn exists 18} 19 20// Size 返回 set 大小 21func (s Set) Size() int { 22\treturn len(s) 23} 24 25// String implements fmt.Stringer 26func (s Set) String() string { 27\tformat := \u0026#34;(\u0026#34; 28\tfor element := range s { 29\tformat += element + \u0026#34; \u0026#34; 30\t} 31\tformat = strings.TrimRight(format, \u0026#34; \u0026#34;) + \u0026#34;)\u0026#34; 32\treturn format 33} 使用 map 和空结构体，可以非常容易实现 set 类型。map 的 key 实际上与 set 不重复的特性刚好一致，一个不需要关心 value 的 map 即为 set。\n空结构体类型最适合作为这个不需要关心的 value 的 map 了，因为它不占空间，没有语义。\n也许有人会认为使用 any 作为 map 的 value 也可以实现 set。但 any 是会占用内存空间。\n1func main() { 2\ts := make(map[string]any) 3\ts[\u0026#34;t1\u0026#34;] = nil 4\ts[\u0026#34;t2\u0026#34;] = struct{}{} 5\tfmt.Printf(\u0026#34;set t1 value: %v, size: %d\\n\u0026#34;, s[\u0026#34;t1\u0026#34;], unsafe.Sizeof(s[\u0026#34;t1\u0026#34;])) 6\tfmt.Printf(\u0026#34;set t2 value: %v, size: %d\\n\u0026#34;, s[\u0026#34;t2\u0026#34;], unsafe.Sizeof(s[\u0026#34;t2\u0026#34;])) 7} 执行示例代码，输出结果如下：\n1set t1 value: \u0026lt;nil\u0026gt;, size: 16 2set t2 value: {}, size: 16 可以发现，any 类型的 value 是有大小的，所以并不合适。\n日常中，还有另一种 set 的常见用法：\n1s := map[string]struct{}{ 2 \u0026#34;one\u0026#34;: {}, 3 \u0026#34;two\u0026#34;: {}, 4 \u0026#34;three\u0026#34;: {}, 5} 6for element := range s { 7 fmt.Println(element) 8} 这种用法也比较常见，无需声明一个 set 类型，直接通过字面量定义一个 value 为空结构体的 map，非常方便。\n信号通知 空结构体另一个经常使用的方法是与 channel 结合，当作信号来使用：\n1func main() { 2\tdone := make(chan struct{}) 3 4\tgo func() { 5\ttime.Sleep(1 * time.Second) // 执行一些操作... 6\tfmt.Printf(\u0026#34;goroutine done\\n\u0026#34;) 7\tdone \u0026lt;- struct{}{} // 发送完成信号 8\t}() 9 10\tfmt.Printf(\u0026#34;waiting...\\n\u0026#34;) 11\t\u0026lt;-done // 等待完成 12\tfmt.Printf(\u0026#34;main exit\\n\u0026#34;) 13} 这段代码中声明了一个长度为 0 的 channel，其类型为 chan struct{}。\n然后启动一个 goroutine 执行业务逻辑，主协程等待信号退出，二者使用 channel 进行通信。由于 struct{} 并不占用内存，所以实际上 channel 内部只需要将计数器加一即可，不涉及数据传输，故没有额外内存开销。\n在 Go 语言 context 源码中也使用了 struct{} 作为完成信号：\n1type Context interface { 2 Deadline() (deadline time.Time, ok bool) 3 // See https://blog.golang.org/pipelines for more examples of how to use 4 // a Done channel for cancellation. 5 Done() \u0026lt;-chan struct{} 6 Err() error 7 Value(key any) any 8} 接口实现 用 struct{} 作为作为接口的实现。\n1// Discard is a [Writer] on which all Write calls succeed 2// without doing anything. 3var Discard Writer = discard{} 4 5type discard struct{} 6 7func (discard) Write(p []byte) (int, error) { 8 return len(p), nil 9} 标识符 Go 中的 sync.Pool 其定义如下：\n1type Pool struct { 2 noCopy noCopy 3 4 local unsafe.Pointer 5 localSize uintptr 6 7 victim unsafe.Pointer 8 victimSize uintptr 9 10 New func() any 11} 其中， noCopy 属性定义如下：\n1type noCopy struct{} 2 3func (*noCopy) Lock() {} 4func (*noCopy) Unlock() {} noCopy 即为一个空结构体，其实现也非常简单，仅定义了两个空方法。该字段的主要作用是阻止 sync.Pool 被意外复制。\n它通过编译器静态分析，来防止结构体被不当复制，以确保正确的使用和内存安全性。\n通过 go vet 命令检可以测出 sync.Pool 是否被意外复制。所以，有了 noCopy 这个标记，就代表结构体不可复制。\n1package main 2 3type noCopy struct{} 4 5func (*noCopy) Lock() {} 6func (*noCopy) Unlock() {} 7 8func main() { 9\ttype A struct { 10\tnoCopy noCopy 11\ta string 12\t} 13 14\ttype B struct { 15\tb string 16\t} 17 18\ta := A{a: \u0026#34;a\u0026#34;} 19\tb := B{b: \u0026#34;b\u0026#34;} 20 21\t_ = a 22\t_ = b 23} 使用 go vet 命令检查是否存在意外的结构体复制：\n1go vet main.go 2# command-line-arguments 3# [command-line-arguments] 4./main.go:21:6: assignment copies lock value to _: command-line-arguments.A contains command-line-arguments.noCopy 可以发现，go vet 已经检测出我们通过 _ = a 复制了 noCopy 结构体 A。\n参考资料 https://mp.weixin.qq.com/s/o3-yPO-OfdVlXvEtVPIzRw ","permalink":"/tech/golang/golang-%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93/","summary":"\u003cp\u003e在 Go 语言中，空结构体 \u003ccode\u003estruct{}\u003c/code\u003e 是一个非常特殊的类型，它\u003cstrong\u003e不包含任何字段\u003c/strong\u003e且\u003cstrong\u003e不占用任何内存空间\u003c/strong\u003e。\u003c/p\u003e\n\u003ch1 id=\"空结构体不占用内存空间\"\u003e空结构体不占用内存空间\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003etype\u003c/span\u003e \u003cspan class=\"nx\"\u003eEmpty\u003c/span\u003e \u003cspan class=\"kd\"\u003estruct\u003c/span\u003e\u003cspan class=\"p\"\u003e{}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 5\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"kd\"\u003evar\u003c/span\u003e \u003cspan class=\"nx\"\u003es1\u003c/span\u003e \u003cspan class=\"kd\"\u003estruct\u003c/span\u003e\u003cspan class=\"p\"\u003e{}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003es2\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"nx\"\u003eEmpty\u003c/span\u003e\u003cspan class=\"p\"\u003e{}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 7\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003es3\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"kd\"\u003estruct\u003c/span\u003e\u003cspan class=\"p\"\u003e{}{}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 8\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 9\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ePrintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;s1 addr: %p, size: %d\\n\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"nx\"\u003es1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eunsafe\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eSizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003es1\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e10\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ePrintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;s2 addr: %p, size: %d\\n\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"nx\"\u003es2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eunsafe\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eSizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003es2\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e11\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ePrintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;s3 addr: %p, size: %d\\n\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"nx\"\u003es3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eunsafe\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eSizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003es3\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e12\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ePrintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;s1 == s2 == s3: %t\\n\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003es1\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"nx\"\u003es2\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"nx\"\u003es2\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"nx\"\u003es3\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e13\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e得到输出如下\u003c/p\u003e","title":"Golang 空结构体"},{"content":" 将节点设置为不可调度，防止新的Pod调度到该节点上。 1kubectl cordon \u0026lt;节点名\u0026gt; 排空节点上的Pod 1 kubectl drain \u0026lt;节点名\u0026gt; --ignore-daemonsets --delete-emptydir-data \u0026ndash;ignore-daemonsets：允许跳过DaemonSet管理的Pod \u0026ndash;delete-emptydir-data：允许删除使用emptyDir卷的Pod 可以直接执行kubectl drain操作，省略cordon步骤。 drain会先cordon之后，再尝试优雅地终止该节点上地Pod（排空）。\n确定节点已排空 1kubectl describe node \u0026lt;节点名\u0026gt; ` 其中，\nUnschedulabel：应该显示为true Taints：包含node.kubernetes.io/unschedulable:NoSchedule 污点 Non-terminated Pods：这里应该只列出DaemonSet管理的Pod（如果有的话），其它类型都已驱逐。 从集群中删除节点 1kubectl delete node \u0026lt;节点名\u0026gt; ","permalink":"/tech/kubernetes/k8s-%E4%B8%8B%E7%BA%BF%E8%8A%82%E7%82%B9%E6%B5%81%E7%A8%8B/","summary":"\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e将节点设置为不可调度\u003c/strong\u003e，防止新的Pod调度到该节点上。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003ekubectl cordon \u0026lt;节点名\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e排空节点上的Pod\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e kubectl drain \u0026lt;节点名\u0026gt; --ignore-daemonsets --delete-emptydir-data\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u0026ndash;ignore-daemonsets：允许跳过DaemonSet管理的Pod\u003c/li\u003e\n\u003cli\u003e\u0026ndash;delete-emptydir-data：允许删除使用emptyDir卷的Pod\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e可以直接执行kubectl drain操作，省略cordon步骤。\ndrain会先cordon之后，再尝试优雅地终止该节点上地Pod（排空）。\u003c/p\u003e","title":"K8s 下线节点流程"},{"content":" 安装 ipvs 1# 安装 ipvs 相关软件包 2yum install ipvsadm ipset sysstat conntrack libseccomp 3 4# 载入模块 5modprobe -- ip_vs 6modprobe -- ip_vs_rr 7modprobe -- ip_vs_wrr 8modprobe -- ip_vs_sh 9modprobe -- nf_conntrack 10 11# 创建ipvs.conf，设置内核模块的自动载入。 12cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/modules-load.d/ipvs.conf 13ip_vs 14ip_vs_lc 15ip_vs_wlc 16ip_vs_rr 17ip_vs_wrr 18ip_vs_lblc 19ip_vs_lblcr 20ip_vs_dh 21ip_vs_sh 22ip_vs_fo 23ip_vs_nq 24ip_vs_sed 25ip_vs_ftp 26ip_vs_sh 27nf_conntrack 28ip_tables 29ip_set 30xt_set 31ipt_set 32ipt_rpfilter 33ipt_REJECT 34ipip 35EOF 1systemctl enable --now systemd-modules-load.service 修改 kube-proxy configmap 1# 将 mode 改为 \u0026#39;ipvs\u0026#39; 2kubectl edit cm kube-proxy -n kube-system 重启 kube-proxy 1kubectl -n kube-system rollout restart daemonset kube-proxy 查看新 Kube-proxy pod 的日志 会出现 Using ipvs Proxier\n1# 检查 kube-proxy 模式 2curl 127.0.0.1:10249/proxyMode ","permalink":"/tech/kubernetes/k8s-%E5%90%AF%E7%94%A8-ipvs-%E6%A8%A1%E5%BC%8F/","summary":"\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e安装 ipvs\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 安装 ipvs 相关软件包\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 2\u003c/span\u003e\u003cspan class=\"cl\"\u003eyum install ipvsadm ipset sysstat conntrack libseccomp\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 载入模块\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 5\u003c/span\u003e\u003cspan class=\"cl\"\u003emodprobe -- ip_vs\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 6\u003c/span\u003e\u003cspan class=\"cl\"\u003emodprobe -- ip_vs_rr\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 7\u003c/span\u003e\u003cspan class=\"cl\"\u003emodprobe -- ip_vs_wrr\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 8\u003c/span\u003e\u003cspan class=\"cl\"\u003emodprobe -- ip_vs_sh\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 9\u003c/span\u003e\u003cspan class=\"cl\"\u003emodprobe -- nf_conntrack\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e10\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e11\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 创建ipvs.conf，设置内核模块的自动载入。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e12\u003c/span\u003e\u003cspan class=\"cl\"\u003ecat \u003cspan class=\"s\"\u003e\u0026lt;\u0026lt;EOF \u0026gt; /etc/modules-load.d/ipvs.conf \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e13\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eip_vs\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e14\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eip_vs_lc\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e15\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eip_vs_wlc\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e16\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eip_vs_rr\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e17\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eip_vs_wrr\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e18\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eip_vs_lblc\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e19\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eip_vs_lblcr\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e20\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eip_vs_dh\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e21\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eip_vs_sh\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e22\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eip_vs_fo\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e23\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eip_vs_nq\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e24\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eip_vs_sed\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e25\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eip_vs_ftp\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e26\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eip_vs_sh\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e27\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003enf_conntrack\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e28\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e29\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eip_set\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e30\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003ext_set\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e31\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eipt_set\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e32\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eipt_rpfilter\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e33\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eipt_REJECT\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e34\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eipip\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e35\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eEOF\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003esystemctl \u003cspan class=\"nb\"\u003eenable\u003c/span\u003e --now systemd-modules-load.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e修改 kube-proxy configmap\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 将 mode 改为 \u0026#39;ipvs\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003ekubectl edit cm kube-proxy -n kube-system\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"3\"\u003e\n\u003cli\u003e\u003cstrong\u003e重启 kube-proxy\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003ekubectl -n kube-system rollout restart daemonset kube-proxy\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"4\"\u003e\n\u003cli\u003e\u003cstrong\u003e查看新 Kube-proxy pod 的日志\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e会出现 \u003ccode\u003eUsing ipvs Proxier\u003c/code\u003e\u003c/p\u003e","title":"K8s 启用 ipvs 模式"},{"content":"MQTT 连接过程 MQTT 连接由客户端向服务器端发起。\n任何运行了 MQTT 客户端库的程序或设备都是一个 MQTT 客户端，而 MQTT 服务器 负责接收客户端发起的连接，并将客户端发送的消息转发到另外一些符合条件的客户端。\n客户端与服务器建立网络连接后，需要先发送一个 CONNECT 数据包给服务器。\n服务器收到 CONNECT 包后会回复一个 CONNACK 给客户端，客户端收到 CONNACK 包后表示 MQTT 连接建立成功。\n如果客户端在超时时间内未收到服务器的 CONNACK 数据包，就会主动关闭连接。\n大多数场景下，MQTT 通过 TCP/IP 协议 进行网络传输，但是 MQTT 同时也支持通过 WebSocket 或者 UDP 进行网络传输。\nMQTT over TCP TCP/IP 应用广泛，是一种面向连接的、可靠的、基于字节流的传输层通信协议。它通过 ACK 确认和重传机制，能够保证发送的所有字节在接收时是完全一样的，并且字节顺序也是正确的。\nMQTT 通常基于 TCP 进行网络通信，它继承了 TCP 的很多优点，能稳定运行在低带宽、高延时、及资源受限的环境下。\nMQTT over WebSocket 很多物联网应用需要以 Web 的方式被使用，比如很多设备监控系统需要使用浏览器实时显示设备数据。但是浏览器是基于 HTTP 协议传输数据的，也就无法使用 MQTT over TCP。\nMQTT 协议在创建之初便考虑到了 Web 应用的重要性，它支持通过 MQTT over WebSocket 的方式进行 MQTT 通信。\nMQTT 连接参数 连接地址 MQTT 的连接地址通常包含 ：服务器 IP 或者域名、服务器端口、连接协议。\n基于 TCP 的 MQTT 连接 mqtt 是普通的 TCP 连接，端口一般为 1883。\nmqtts 是基于 TLS/SSL 的安全连接，端口一般为 8883。\n比如 mqtt://broker.emqx.io:1883 是一个基于普通 TCP 的 MQTT 连接地址。\n基于 WebSocket 的连接 ws 是普通的 WebSocket 连接，端口一般为 8083。\nwss 是基于 WebSocket 的安全连接，端口一般为 8084。\n当使用 WebSocket 连接时，连接地址还需要包含 Path，EMQX 默认配置的 Path 是 /mqtt。比如 ws://broker.emqx.io:8083/mqtt 是一个基于 WebSocket 的 MQTT 连接地址。\nClient ID MQTT 服务器使用 Client ID 识别客户端，连接到服务器的每个客户端都必须要有唯一的 Client ID。Client ID 的长度通常为 1 至 23 个字节的 UTF-8 字符串。\n如果客户端使用一个重复的 Client ID 连接至服务器，将会把已使用该 Client ID 连接成功的客户端踢下线。 g\nUsername \u0026amp; Password MQTT 协议基于用户名和密码来进行相关的认证和授权，但是如果此信息未加密，则用户名和密码将以明文方式传输。如果设置了用户名与密码认证，那么最好要使用 mqtts 或 wss 协议。\n大多数 MQTT 服务器默认为匿名认证，匿名认证时用户名与密码设置为空字符串即可。\nConnect Timeout 连接超时时长，收到服务器连接确认前的等待时间，等待时间内未收到连接确认则为连接失败。\nKeep Alive 保活周期，是一个以秒为单位的时间间隔。客户端在无报文发送时，将按 Keep Alive 设定的值定时向服务端发送心跳报文，确保连接不被服务端断开。\n在连接建立成功后，如果服务器没有在 Keep Alive 的 1.5 倍时间内收到来自客户端的任何包，则会认为和客户端之间的连接出现了问题，此时服务器便会断开和客户端的连接。\nClean Session Clean Session 为 false 时表示创建一个持久会话，在客户端断开连接时，会话仍然保持并保存离线消息，直到会话超时注销；为 true 时表示创建一个新的临时会话，在客户端断开时，会话自动销毁。\n持久会话避免了客户端掉线重连后消息丢失，也避免了客户端连接后重复的订阅开销。这一功能在带宽小，网络不稳定的物联网场景中非常实用。\n服务器为持久会话保存的消息数量取决于服务器的配置。\n注意： 持久会话恢复的前提是客户端使用固定的 Client ID 再次连接，如果 Client ID 是动态的，那么连接成功后将会创建一个新的持久会话。\nLast Will 遗嘱消息是 MQTT 为那些可能出现意外断线的设备提供的将遗嘱优雅地发送给其他客户端的能力。设置了遗嘱消息消息的 MQTT 客户端异常下线时，MQTT 服务器会发布该客户端设置的遗嘱消息。\n意外断线包括：因网络故障，连接被服务端关闭；设备意外掉电；设备尝试进行不被允许的操作而被服务端关闭连接等。\n遗嘱消息可以看作是一个简化版的 MQTT 消息，它也包含 Topic、Payload、QoS、Retain 等信息。\n当设备意外断线时，遗嘱消息将被发送至遗嘱 Topic； 遗嘱 Payload 是待发送的消息内容； 遗嘱 QoS 与普通 MQTT 消息的 QoS 一致。 遗嘱 Retain 为 true 时表明遗嘱消息是保留消息。MQTT 服务器会为每个主题存储最新一条保留消息，以方便消息发布后才上线的客户端在订阅主题时仍可以接收到该消息。 协议版本 使用较多的 MQTT 协议版本有 MQTT v3.1、MQTT v3.1.1 及 MQTT v5.0。\n目前，MQTT 5.0 已成为绝大多数物联网企业的首选协议，我们建议初次接触 MQTT 的开发者直接使用该版本。但是，paho.mqtt.golang 目前只支持v3.1.1。\n参考资料 https://www.emqx.com/zh/blog/how-to-set-parameters-when-establishing-an-mqtt-connection ","permalink":"/tech/iot/mqtt-%E8%BF%9E%E6%8E%A5%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/","summary":"\u003ch1 id=\"mqtt-连接过程\"\u003eMQTT 连接过程\u003c/h1\u003e\n\u003cp\u003eMQTT 连接由客户端向服务器端发起。\u003c/p\u003e\n\u003cp\u003e任何运行了 MQTT 客户端库的程序或设备都是一个 MQTT 客户端，而 MQTT 服务器 负责接收客户端发起的连接，并将客户端发送的消息转发到另外一些符合条件的客户端。\u003c/p\u003e","title":"MQTT 连接参数配置"},{"content":"K8S 集群中 NodePort 默认范围为 30000-32767。\n若要修改此范围，依次修改 Master 节点上的 /etc/kubernetes/manifests/kube-apiserver.yaml 文件。\n1# 备份配置文件 2cp kube-apiserver.yaml kube-apiserver.yaml.bak 3vi kube-apiserver.yaml 4..... 5 Host Port: \u0026lt;none\u0026gt; 6 Command: 7 kube-apiserver 8 - --service-cluster-ip-range=10.96.0.0/12 9# 插入 10 - --service-node-port-range=1-65535 然后, kube-apiserver 会自动重启生效。\n注意，备份 kube-apiserver.yaml 时，不要备份为kube-apiserver.yaml/bak\n","permalink":"/tech/kubernetes/k8s-%E4%BF%AE%E6%94%B9-nodeport-%E9%BB%98%E8%AE%A4%E8%8C%83%E5%9B%B4/","summary":"\u003cp\u003eK8S 集群中 NodePort 默认范围为 30000-32767。\u003c/p\u003e\n\u003cp\u003e若要修改此范围，依次修改 Master 节点上的 \u003ccode\u003e/etc/kubernetes/manifests/kube-apiserver.yaml\u003c/code\u003e 文件。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 备份配置文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 2\u003c/span\u003e\u003cspan class=\"cl\"\u003ecp kube-apiserver.yaml kube-apiserver.yaml.bak\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 3\u003c/span\u003e\u003cspan class=\"cl\"\u003evi kube-apiserver.yaml\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 4\u003c/span\u003e\u003cspan class=\"cl\"\u003e.....\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 5\u003c/span\u003e\u003cspan class=\"cl\"\u003e    Host Port:     \u0026lt;none\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 6\u003c/span\u003e\u003cspan class=\"cl\"\u003e    Command:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 7\u003c/span\u003e\u003cspan class=\"cl\"\u003e      kube-apiserver\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 8\u003c/span\u003e\u003cspan class=\"cl\"\u003e      - --service-cluster-ip-range\u003cspan class=\"o\"\u003e=\u003c/span\u003e10.96.0.0/12\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 9\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 插入\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e10\u003c/span\u003e\u003cspan class=\"cl\"\u003e      - --service-node-port-range\u003cspan class=\"o\"\u003e=\u003c/span\u003e1-65535\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e然后, \u003ccode\u003ekube-apiserver\u003c/code\u003e 会自动重启生效。\u003c/p\u003e","title":"K8s 修改 NodePort 默认范围"},{"content":"MQTT 发布/订阅模式 发布-订阅模式（Publish-Subscribe Pattern）是一种消息传递模式，将发送消息的客户端（发布者）与接收消息的客户端（订阅者）解耦，使得两者不需要建立直接的联系也不需要知道对方的存在。\nMQTT 发布/订阅模式关键在于代理（Broker） ，代理负责所有消息的路由和分发工作，发布者将带有主题的消息发送给代理，订阅者则向代理订阅主题来接收感兴趣的消息。\n在 MQTT 中，主题和订阅无法被提前注册或创建，所以代理也无法预知某一个主题之后是否会有订阅者，以及会有多少订阅者，所以只能将消息转发给当前的订阅者，如果当前不存在任何订阅，那么消息将被直接丢弃。\nMQTT 发布/订阅模式有 4 个主要组成部分：发布者、订阅者、代理和主题。\n发布者（Publisher）： 发布者将消息发布到主题上，发布者一次只能向一个主题发送数据，发布者发布消息时不关心订阅者是否在线。\n订阅者（Subscriber）： 订阅者通过订阅主题接收消息，且可一次订阅多个主题。MQTT 支持通过共享订阅的方式在多个订阅者之间实现负载均衡。\n代理（Broker）: 代理负责接收发布者的消息，并将消息转发至符合条件的订阅者。另外，代理也需要负责处理客户端发起的连接、断开连接、订阅、取消订阅等请求。\n主题（Topic）: 主题是 MQTT 进行消息路由的基础，它类似 URL 路径，使用斜杠 / 进行分层，比如 sensor/1/temperature。一个主题可以有多个订阅者，代理会将该主题下的消息转发给所有订阅者；一个主题也可以有多个发布者，代理将按照消息到达的顺序转发。MQTT 还支持订阅者使用主题通配符一次订阅多个主题。\nMQTT 发布/订阅中的消息路由 在 MQTT 发布/订阅模式中，一个客户端既可以是发布者，也可以是订阅者，也可以同时具备这两个身份。 当客户端发布一条消息时，它会被发送到代理，然后代理将消息路由到该主题的所有订阅者。 当客户端订阅一个主题时，它会收到代理转发到该主题的所有消息。\n一般来说，大多数发布/订阅系统主要通过以下两种方式过滤并路由消息。\n根据主题： 订阅者向代理订阅自己感兴趣的主题，发布者发布的所有消息中都会包含自己的主题，代理根据消息的主题判断需要将消息转发给哪些订阅者。\n根据消息内容： 订阅者定义其感兴趣的消息的条件，只有当消息的属性或内容满足订阅者定义的条件时，消息才会被投递到该订阅者。\nMQTT 协议是基于主题进行消息路由的。\nMQTT 与 HTTP 请求响应 基于请求响应的 HTTP 在物联网领域的应用却有一定的局限性。\n首先，协议层面 HTTP 报文相较与 MQTT 需要占用更多的网络开销； 其次，HTTP 是一种无状态协议，这意味着服务器在处理请求时不会记录客户端的状态，也无法实现从连接异常断开中恢复； 最后，请求响应模式需要通过轮询才能获取数据更新，而 MQTT 通过订阅即可获取实时数据更新。 发布订阅模式的松耦合特性，也给 MQTT 带来了一些副作用。由于发布者并不知晓订阅者的状态，因此发布者也无法得知订阅者是否收到了消息，或者是否正确处理了消息。\nMQTT 5.0 增加了请求响应特性，以实现订阅者收到消息后向某个主题发送应答，发布者收到应答后再进行后续操作。\nMQTT 与消息队列 尽管 MQTT 与消息队列的很多行为和特性非常接近，比如都采用发布/订阅模式，但是他们面向的场景却有着显著的不同。\n消息队列主要用于服务端应用之间的消息存储与转发，这类场景往往数据量大但客户端数量少。\nMQTT 是一种消息传输协议，主要用于物联网设备之间的消息传递，这类场景的特点是海量的设备接入、管理与消息传输。\n在一些实际的应用场景中，MQTT 与消息队列往往会被结合起来使用，以使 MQTT 服务器能专注于处理设备的连接与设备间的消息路由。比如先由 MQTT 服务器接收物联网设备上报的数据，然后再通过消息队列将这些数据转发到不同的业务系统进行处理。\n不同于消息队列，MQTT 主题不需要提前创建。MQTT 客户端在订阅或发布时即自动的创建了主题，开发者无需再关心主题的创建，并且也不需要手动删除主题。\n参考资料 https://www.emqx.com/zh/blog/mqtt-5-introduction-to-publish-subscribe-model ","permalink":"/tech/iot/mqtt-%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/","summary":"\u003ch1 id=\"mqtt-发布订阅模式\"\u003eMQTT 发布/订阅模式\u003c/h1\u003e\n\u003cp\u003e发布-订阅模式（Publish-Subscribe Pattern）是一种消息传递模式，将发送消息的客户端（发布者）与接收消息的客户端（订阅者）解耦，使得两者不需要建立直接的联系也不需要知道对方的存在。\u003c/p\u003e","title":"MQTT 发布-订阅模式"},{"content":"什么是 QoS 使用 MQTT 协议的设备一般运行在网络受限的环境下，只依靠底层TCP 传输协议并不能完全保证消息的可靠到达。\n因此，MQTT 提供了 QoS（Quality of service） 机制，其核心是设计了多种消息交互机制来提供不同的服务质量，来满足用户在各种场景下对消息可靠性的要求。\nMQTT 定义了三个 QoS 等级，分别为：\nQoS 0，最多交付一次。 QoS 1，至少交付一次。 QoS 2，只交付一次。 其中，使用 QoS 0 可能丢失消息，使用 QoS 1 可以保证收到消息，但消息可能重复，使用 QoS 2 可以保证消息既不丢失也不重复。\nQoS 等级从低到高，不仅意味着消息可靠性的提升，也意味着传输复杂程度的提升。\n在一个完整的从发布者到订阅者的消息投递流程中，QoS 等级是由发布者在 PUBLISH 报文中指定，大部分情况下 Broker 向订阅者转发消息时都会维持原始的 QoS 不变。不过也有一些例外的情况，根据订阅者的订阅要求，消息的 QoS 等级可能会在转发的时候发生降级。\n例如，订阅者在订阅时要求 Broker 可以向其转发的消息的最大 QoS 等级为 QoS 1，那么后续所有 QoS 2 消息都会降级至 QoS 1 转发给此订阅者，而所有 QoS 0 和 QoS 1 消息则会保持原始的 QoS 等级转发。\nQoS 0 - 最多交付一次 QoS 0 是最低的 QoS 等级。\nQoS 0 消息即发即弃，不需要等待确认，不需要存储和重传，对于接收方来说，不需要担心收到重复的消息。\n为什么 QoS 0 消息会丢失？\n使用 QoS 0 传递消息时，消息的可靠性完全依赖于底层的 TCP 协议。\n而 TCP 只能保证在连接稳定不关闭的情况下消息的可靠到达，一旦出现连接关闭、重置，仍有可能丢失当前处于网络链路或操作系统底层缓冲区中的消息。这也是 QoS 0 消息最主要的丢失场景。\nQoS 1 - 至少交付一次 为了保证消息到达，QoS 1 加入了应答与重传机制。\n发送方只有在收到接收方的 PUBACK 报文以后，才能认为消息投递成功，在此之前，发送方需要存储该 PUBLISH 报文以便下次重传。\nQoS 1 需要在 PUBLISH 报文中设置 Packet ID，而作为响应的 PUBACK 报文，则会使用与 PUBLISH 报文相同的 Packet ID，以便发送方收到后删除正确的 PUBLISH 报文缓存。\n为什么 QoS 1 消息会重复？\n对于发送方，没收到 PUBACK 报文分为以下两种情况：\nPUBLISH 未到达接收方 PUBLISH 已经到达接收方，接收方的 PUBACK 报文还未到达发送方 对于CASE 1，发送方虽然重传了 PUBLISH 报文，但是对于接收方来说，实际上仍然仅收到了一次消息。\n对于CASE 2，在发送方重传时，接收方已经收到过了这个 PUBLISH 报文，这就导致接收方将收到重复的消息。虽然重传时 PUBLISH 报文中的 DUP 标志会被设置为 1，用以表示这是一个重传的报文。但是接收方并不能因此假定自己曾经接收过这个消息，仍然需要将其视作一个全新的消息。\n对于接收方，可能存在以下两种情况： 对于CASE 1，发送方由于没有收到 PUBACK 报文而重传了 PUBLISH 报文。此时，接收方收到的前后两个 PUBLISH 报文使用了相同的 Packet ID，并且第二个 PUBLISH 报文的 DUP 标志为 1，此时它确实是一个重复的消息。\n对于CASE 2，第一个 PUBLISH 报文已经完成了投递，1024 这个 Packet ID 重新变为可用状态。发送方使用这个 Packet ID 发送了一个全新的 PUBLISH 报文，但这一次报文未能到达对端，所以发送方后续重传了这个 PUBLISH 报文。这就使得虽然接收方收到的第二个 PUBLISH 报文同样是相同的 Packet ID，并且 DUP 为 1，但确实是一个全新的消息。\n由于我们无法区分这两种情况，所以只能让接收方将这些 PUBLISH 报文都当作全新的消息来处理。因此当我们使用 QoS 1 时，消息的重复在协议层面上是无法避免的。\n极端情况下，Broker 从发布方收到了重复的 PUBLISH 报文，而在将这些报文转发给订阅方的过程中，再次发生重传，这将导致订阅方最终收到更多的重复消息。\n以上，就是 QoS 1 保证消息到达，导致的消息重复。\nQoS 2 - 只交付一次 QoS 2 解决了 QoS 0、1 消息可能丢失或者重复的问题，但相应地，它也带来了最复杂的交互流程和最高的开销。每一次的 QoS 2 消息投递，都要求发送方与接收方进行至少两次请求/响应流程。\n发送方存储并发送 QoS 为 2 的 PUBLISH 报文启动一次 QoS 2 消息的传输，并等待接收方回复 PUBREC 报文。这一部分与 QoS 1 基本一致，但响应报文从 PUBACK 变成了 PUBREC。 当发送方收到 PUBREC 报文，即确认接收方收到了 PUBLISH 报文，发送方将不再需要重传这个报文，并且也不能再重传这个报文。此时发送方删除本地存储的 PUBLISH 报文，并存储并发送 PUBREL 报文，通知接受方本次使用的 Packet ID 将被标记为可用。与 PUBLISH 报文相同，所以也需要收到响应报文以确保 PUBREL 报文到达对端。 当接收方收到 PUBREL 报文，可以确认本次传输流程中不会再有重传的 PUBLISH 报文到达，因此回复 PUBCOMP 报文表示确认当前 Packet ID 可以用于新的消息。 当发送方收到 PUBCOMP 报文，本次 QoS 2 消息传输正式完成。之后，发送方可以再次使用当前的 Packet ID 发送新的消息，而接收方再次收到使用这个 Packet ID 的 PUBLISH 报文时，也会将它视为一个全新的消息。 为什么 QoS 2 消息不会重复？\nQoS 2 与 QoS 1 相同，通过响应报文保证消息不会丢失。与 QoS 1 相比，QoS 2 新增了 PUBREL 报文和 PUBCOMP 报文的流程，以保证消息不重复。\n首先回顾一下 QoS 1 消息无法避免重复的原因：使用 QoS 1 消息时，对接收方来说，回复完 PUBACK 响应报文后 Packet ID 就重新可用了，也不管响应是否确实到达了发送方。所以无法得知之后到达的，携带了相同 Packet ID 的 PUBLISH 报文是发送方没有收到响应而重传的，还是发送方收到了响应所以重新使用了这个 Packet ID 发送了一个全新的消息。\n![[https://assets.emqx.com/images/81b397e0a44a6abd3adbe411d1219272.png?x-image-process=image/resize,w_1520/format,webp]]\n所以，消息去重的关键就在于通信双方如何正确地同步释放 Packet ID，换句话说，不管发送方是重传消息还是发布新消息，一定是和对端达成共识了的。\nQoS 2 增加的 PUBREL 流程提供了帮助通信双方协商 Packet ID 何时可以重用的能力。\nQoS 2 规定，发送方只有在收到 PUBREC 报文之前可以重传 PUBLISH 报文。 一旦收到 PUBREC 报文并发出 PUBREL 报文，发送方就进入了 Packet ID 释放流程，不可以再使用当前 Packet ID 重传 PUBLISH 报文。同时，在收到对端回复的 PUBCOMP 报文确认双方都完成 Packet ID 释放之前，也不可以使用当前 Packet ID 发送新的消息。\n因此对于接收方来说，以 PUBREL 报文为界限，凡是在 PUBREL 报文之前到达的 PUBLISH 报文，都必然是重复的消息；而凡是在 PUBREL 报文之后到达的 PUBLISH 报文，都必然是全新的消息。\n一旦有了这个前提，我们就能够在协议层面完成 QoS 2 消息的去重。\n不同 QoS 的适用场景和注意事项 QoS 0 QoS 0 的缺点是可能会丢失消息，消息丢失的频率依赖于你所处的网络环境，并且可能使你错过断开连接期间的消息，不过优点是投递的效率较高。\n所以我们通常选择使用 QoS 0 传输一些高频且不那么重要的数据，比如传感器数据，周期性更新，即使遗漏几个周期的数据也可以接受。\nQoS 1 QoS 1 可以保证消息到达，所以适合传输一些较为重要的数据，比如下达关键指令、更新有实时性要求的状态等。\n但因为 QoS 1 还可能会导致消息重复，所以当我们选择使用 QoS 1 时，还需要能够处理消息的重复，或者能够允许消息的重复。\n在我们决定使用 QoS 1 并且不对其进行去重处理之前，我们需要先了解，允许消息的重复，可能意味着什么。\n如果我们不对 QoS 1 进行去重处理，我们可能会遭遇这种情况，发布方以 1、2 的顺序发布消息，但最终订阅方接收到的消息顺序可能是 1、2、1、2。 如果 1 表示开灯指令，2 表示关灯指令，我想大部分用户都不会接受自己仅仅进行了开灯然后关灯的操作，结果灯在开和关的状态来回变化。\nQoS 2 QoS 2 既可以保证消息到达，也可以保证消息不会重复，但传输成本最高。\n如果我们不愿意自行实现去重方案，并且能够接受 QoS 2 带来的额外开销，那么 QoS 2 将是一个合适的选择。金融、航空等行业场景下会更多地见到 QoS 2 的使用。\n参考资料 https://www.emqx.com/zh/blog/introduction-to-mqtt-qos ","permalink":"/tech/iot/mqtt-qos--%E7%AE%80%E4%BB%8B/","summary":"\u003ch1 id=\"什么是-qos\"\u003e什么是 QoS\u003c/h1\u003e\n\u003cp\u003e使用 MQTT 协议的设备一般运行在网络受限的环境下，只依靠底层TCP 传输协议并不能完全保证消息的可靠到达。\u003c/p\u003e\n\u003cp\u003e因此，MQTT 提供了 QoS（\u003cstrong\u003eQuality of service\u003c/strong\u003e） 机制，其核心是设计了多种消息交互机制来提供不同的服务质量，来满足用户在各种场景下对消息可靠性的要求。\u003c/p\u003e","title":"MQTT QoS 简介"},{"content":"在使用 K8S 过程中，偶尔会遇到如下所示的一段配置：\n1securityContext: 2 capabilities: 3 drop: 4 - ALL 5 add: 6 - NET_BIND_SERVICE 实际上这是配置对应的容器的 Capabilities，在我们使用 docker run 的时候可以通过 --cap-add 和 --cap-drop 命令来给容器添加 Linux Capabilities。\nLinux Capabilities Linux 使用 Capabilities 机制来对 root 权限进行了更加细粒度的控制，实现按需进行授权，减小了系统的安全隐患。Linux 将传统上与超级用户 root 关联的特权划分为不同的、可以独立启用禁用的单元，称为 Capabilities。\n这样当系统在作权限检查的时候就变成了：在执行特权操作时，如果进程的有效身份不是 root，就去检查是否具有该特权操作所对应的 Capabilities，并以此决定是否可以进行该特权操作。比如，如果要设置系统时间，就得具有 CAP_SYS_TIME 这个 Capabilities。\nCapabilities 详细描述可参考 capabilities man page\n使用 Capabilities 通过 getcap 和 setcap 两条命令来分别查看和设置程序文件的 capabilities 属性。\n1# 查看 cap 2root@iZwz9c8vxak6iz0pol8de3Z:~# getcap /bin/ping 3/bin/ping cap_net_raw=ep 4 5# 删除 ping 的 cap 6setcap cap_net_admin,cap_net_raw-p /bin/ping 7 8getcap /bin/ping 9/bin/ping = 10 11# 恢复 ping 的 cap 12setcap cap_net_admin,cap_net_raw+p /bin/ping 13 14getcap /bin/ping 15/bin/ping cap_net_admin,cap_net_raw=p Docker 配置 Capabilities 在 Docker 中，可以通过 --cap-add 和 --cap-drop 这两个参数来动态调整权限， 最大限度地保证容器的使用安全。下面表格中列出的 Capabilities 是 Docker 默认给容器添加的，我们可以通过 --cap-drop 去除其中一个或者多个：\n--cap-add和--cap-drop 这两参数都支持ALL值，比如如果你想让某个容器拥有除了MKNOD之外的所有内核权限，那么可以执行下面的命令： 1$ sudo docker run --cap-add=ALL --cap-drop=MKNOD ... 假如需要修改网络接口数据，默认情况下是没有权限的，因为需要的 NET_ADMIN 这个 Capabilities 默认被移除了：\n1$ docker run -it --rm busybox /bin/sh 2/ # ip link add dummy0 type dummy 3ip: RTNETLINK answers: Operation not permitted 4/ # 所以在不使用 --privileged 的情况下（不建议）我们可以使用 --cap-add=NET_ADMIN 将这个 Capabilities 添加回来：\n1$ docker run -it --rm --cap-add=NET_ADMIN busybox /bin/sh 2/ # ip link add dummy0 type dummy 3/ # K8S 配置 Capabilities 在 Kubernetes 中也可以很方便的来定义，我们只需要添加到 Pod 定义的 spec.containers.sercurityContext.capabilities中即可，也可以进行 add 和 drop 配置，同样上面的示例，我们要给 busybox 容器添加 NET_ADMIN 这个 Capabilities，对应的 YAML 文件可以这样定义：\n1apiVersion: v1 2kind: Pod 3metadata: 4 name: cpb-demo 5spec: 6 containers: 7 - name: cpb 8 image: busybox 9 args: 10 - sleep 11 - \u0026#34;3600\u0026#34; 12 securityContext: 13 capabilities: 14 add: # 添加 15 - NET_ADMIN 16 drop: # 删除 17 - KILL 在 Kubernetes 中通过 sercurityContext.capabilities 进行配置容器的 Capabilities，当然最终还是通过 Docker 的 libcontainer 去借助 Linux kernel capabilities 实现的权限管理。\n参考资料：\nhttps://www.qikqiak.com/post/capabilities-on-k8s/ ","permalink":"/tech/kubernetes/%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8-container-capabilities/","summary":"\u003cp\u003e在使用 K8S 过程中，偶尔会遇到如下所示的一段配置：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003esecurityContext\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"nt\"\u003ecapabilities\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003edrop\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003eALL\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e5\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eadd\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e- \u003cspan class=\"l\"\u003eNET_BIND_SERVICE\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e实际上这是配置对应的容器的 \u003ccode\u003eCapabilities\u003c/code\u003e，在我们使用 \u003ccode\u003edocker run\u003c/code\u003e 的时候可以通过 \u003ccode\u003e--cap-add\u003c/code\u003e 和 \u003ccode\u003e--cap-drop\u003c/code\u003e 命令来给容器添加 \u003ccode\u003eLinux Capabilities\u003c/code\u003e。\u003c/p\u003e","title":"理解与使用 Container Capabilities"},{"content":"数据卷（Volume）是 Pod 与外部存储设备进行数据传递的通道，也是 Pod 内部容器间、Pod 与Pod 间、Pod 与外部环境进行数据共享的方式。\nVolume 定义了外置存储的细节，并内嵌到 Pod 中作为 Pod 的一部分。其实质是外置存储在Kubernetes 系统的一个资源映射，当负载需要使用外置存储的时候，可以从数据卷（Volume）中查到相关信息并进行存储挂载操作。\nVolume 的生命周期和 Pod 一致，Pod 被删除时，Volume也会被删除，Volume 中的数据是否丢失取决于 Volume 的具体类型。\n常用的Volume类型分类如下：\n分类 描述 本地存储 适用于本地存储的数据卷，例如 HostPath、emptyDir等。本地存储卷的特点是数据保存在集群的特定节点上，并且不能随着应用漂移，节点停机时数据即不再可用。 网络存储 适用于网络存储的数据卷，例如Ceph、GlusterFS、NFS、iSCSI等。网络存储卷的特点是数据不在集群的某个节点上，而是在远端的存储服务上，使用存储卷时需要将存储服务挂载到本地使用。 Secret和ConfigMap Secret和ConfigMap是特殊的数据卷，其数据是集群的一些对象信息，该对象数据以卷的形式被挂载到节点上供应用使用。 PVC 一种数据卷定义方式，将数据卷抽象成一个独立于Pod的对象，这个对象定义（关联）的存储信息即存储卷对应的真正存储信息，供Kubernetes负载挂载使用。 Volume 使用原则 一个 Pod 可以挂载多个 Volume 一个 Pod 可以挂载多种类型的 Volume 每个被 Pod 挂载的 Volume，可以被该 Pod 内不同的容器间共享。 K8S 环境推荐使用 PVC 和 PV 方式挂载 Volume Volume 类型 emptyDir emptyDir 类型的 Volume 在 Pod 分配到 Node 上时被创建，Kubernetes会在 Node 上自动分配一个目录，因此无需指定宿主机Node上对应的目录文件，该目录的初始内容为空，当 Pod 从 Node 上被删除时，emptyDir 中的数据会被永久删除。\n特别的，容器崩溃不会导致 Pod 被从节点上移除，因此容器崩溃期间 emptyDir 卷中的数据是安全的。\n常见使用场景：\nemptyDir 卷适合用于 Pod 中的容器共享文件。 缓存空间，例如基于磁盘的归并排序算法。 为耗时较长的计算任务提供检查点，以便任务能方便地从崩溃前状态恢复执行。 在 Web 服务器容器服务数据时，保存内容管理器容器获取的文件。 例如前后端容器，前端容器是辅助进程，不对外提供任何服务，前端文件通过 emptyDir 共享到 Web 的 wwwroot 目录中。由 Web 对外提供 8080 端口服务，用户访问 Web 时，可以访问到前端静态文件。这样前后端可以分开更新和部署，存放前端文件的辅助容器只负责提供静态文件，最终由 Web 后端程序对外提供静态页面和 API。\n1apiVersion: v1 2kind: Pod 3metadata: 4 name: pod-demo 5 namespace: default 6 labels: 7 app: myapp 8 tier: frontend 9spec: 10 containers: 11 - name: myapp 12 image: ikubernetes/myapp:v1 13 imagePullPolicy: IfNotPresent 14 ports: 15 - name: http 16 containerPort: 80 17 volumeMounts: #在容器内定义挂载存储名称和挂载路径 18 - name: html 19 mountPath: /usr/share/nginx/html/ 20 - name: busybox 21 image: busybox:latest 22 imagePullPolicy: IfNotPresent 23 volumeMounts: 24 - name: html 25 mountPath: /data/ #在容器内定义挂载存储名称和挂载路径 26 command: [\u0026#39;/bin/sh\u0026#39;,\u0026#39;-c\u0026#39;,\u0026#39;while true;do echo $(date) \u0026gt;\u0026gt; /data/index.html;sleep 2;done\u0026#39;] 27 volumes: #定义存储卷 28 - name: html #定义存储卷名称 29 emptyDir: {} #定义存储卷类型 hostPath hostPath 卷将主机节点文件系统上的文件或目录挂载到 Pod 中，类似 Docker 的 -v 挂载。hostPath 卷依赖于节点上的目录或文件，不同节点的 Pod 无法共享相同的文件内容。\n常见使用场景:\n挂载宿主机的时区文件到容器内，保持和宿主机时区一致。 1 volumeMounts: 2 - name: timezone # 卷名称 3 mountPath: /etc/localtime # 挂载到容器中的路径目录 4 volumes: 5 - name: timezone 6 hostPath: 7 path: /usr/share/zoneinfo/Asia/Shanghai configmap ConfigMap 可以用来存储非机密性的数据到键值对中，这些信息会被存储到 etcd，不会分节点，任何节点都可以使用到。使用时，将其用作环境变量、命令行参数或者存储卷中的配置文件送入到 Pod 中，主要目的是解耦应用程序和配置，这样不必维护那些 .json 等配置文件，也可以避免不小心将带有机密信息的配置文件上传到代码仓库中。\n假设有配置文件 c.txt 如下：\n1enemies=aliens 2lives=3 3enemies.cheat=true 4enemies.cheat.level=noGoodRotten 5secret.code.passphrase=UUDDLRLRBABAS 6secret.code.allowed=true 7secret.code.lives=30 创建 configMap：\n1# 基于单个配置文件创建 ConfigMap 2kubectl create configmap my-config1 --from-file=c.txt 3 4# 基于多个配置文件创建 ConfigMap 5kubectl create configmap my-config --from-file=key1=/path/to/bar/file1.txt --from-file=key2=/path/to/bar/file2.txt 6 7# 基于目录创建 ConfigMap： 8kubectl create configmap my-config2 --from-file=config/ 在 pod 中挂载 configMap：\n1apiVersion: v1 2kind: Pod 3metadata: 4 name: configmap-pod 5spec: 6 containers: 7 - name: configmap-pod 8 image: busybox 9 command: [\u0026#34;ls\u0026#34;] 10 args: [\u0026#34;/etc/config\u0026#34;] 11 volumeMounts: 12 - name: config-vol 13 mountPath: /etc/config 14 volumes: 15 - name: config-vol 16 configMap: 17 name: my-config secret Secret 卷用来给 Pod 传递敏感信息，例如密码、密钥等。Secret卷实际上不是用于存储的，Secret 中存储的信息，会以环境变量、文件等的形式显示在 Pod 中。最常用的情况是使用 Secret 为 Ingress 增加 TLS 加密访问。\nSecret 主要包括以下类型：\n内置类型 用法 Opaque 用户定义的任意数据 kubernetes.io/service-account-token 服务账号令牌 kubernetes.io/dockercfg ~/.dockercfg 文件的序列化形式 kubernetes.io/dockerconfigjson ~/.docker/config.json 文件的序列化形式 kubernetes.io/basic-auth 用于基本身份认证的凭据 kubernetes.io/ssh-auth 用于 SSH 身份认证的凭据 kubernetes.io/tls 用于 TLS 客户端或者服务器端的数据 bootstrap.kubernetes.io/token 启动引导令牌数据 使用 kubectl 命令创建 Secret：\n1kubectl create secret {类型} {secret名称} 通过证书创建 Secret：\n1kubectl create secret tls tls-secret --cert=1_k1.whuanle.cn_bundle.crt --key=2_k1.whuanle.cn.key 使用 YAML 表示：\n1apiVersion: v1 2data: 3 tls.crt: ... 4 tls.key: ... 5kind: Secret 6metadata: 7 name: tls-secret 8type: kubernetes.io/tls Nginx 配置 Https 证书，使用的便是 crt、key 文件。\nPV \u0026amp; PVC 详细部署方式：PV \u0026amp; PVC 声明样例\nK8S 引入了 PV 和 PVC 两个资源对象，将存储实现的细节从其如何被使用中抽象出来，并解耦存储使用者和系统管理员的职责。\nPV和PVC的概念如下：\nPV（PersistentVolume） 在 K8S 中代表一个具体存储类型的卷，其对象中定义了具体存储类型和卷参数。 PVC（PersistentVolumeClaim）是在 K8S 中一种抽象的存储卷类型，代表了某个具体类型存储的数据卷表达。 PV 属于整个 K8S 集群，而 PVC 属于某个命名空间\nPVC与PV是一一对应关系，不能一个PVC挂载多个PV，也不能一个PV挂载多个PVC。 PVC只有绑定了PV之后才能被Pod使用，而PVC绑定PV的过程即是消费PV的过程，这个过程是有一定规则的。为应用配置存储时，需要声明一个 PVC，而 K8S 会通过最佳匹配的方式选择一个满足PVC需求的PV，并与之绑定。\nPV 有两种提供方式：\n静态分配:\n集群管理员预先创建一些 PV。它们携带可供集群用户使用的真实存储的详细信息。 它们存在于Kubernetes API中，可用于消费。 用户创建PVC与PV绑定 动态分配: 通过存储类进行动态创建存储空间。当现有的 PV 都不匹配用户的 PVC 时，K8S 基于 StorageClasses 动态地为 PVC 配置卷。\n","permalink":"/tech/kubernetes/volume-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","summary":"\u003cp\u003e数据卷（Volume）是 Pod 与外部存储设备进行数据传递的通道，也是 Pod 内部容器间、Pod 与Pod 间、Pod 与外部环境进行数据共享的方式。\u003c/p\u003e\n\u003cp\u003eVolume 定义了外置存储的细节，并内嵌到 Pod 中作为 Pod 的一部分。其实质是外置存储在Kubernetes 系统的一个资源映射，当负载需要使用外置存储的时候，可以从数据卷（Volume）中查到相关信息并进行存储挂载操作。\u003c/p\u003e","title":"Volume 基础知识"},{"content":"1. WaitGroup WaitGroup 等待一组 Goroutine 完成。主 Goroutine 调用 Add(delta) 来设置要等待的 Goroutine 的数量。然后每个 Goroutine 运行并在完成时调用 Done()。同时，可以使用 Wait() 来阻塞，直到所有 Goroutine 完成。\n1type WaitGroup struct { 2\tnoCopy noCopy 3 4\t// 64-bit value: high 32 bits are counter, low 32 bits are waiter count. 5\t// 64-bit atomic operations require 64-bit alignment, but 32-bit 6\t// compilers do not ensure it. So we allocate 12 bytes and then use 7\t// the aligned 8 bytes in them as state, and the other 4 as storage 8\t// for the sema. 9\tstate1 [3]uint32 10} wg.Add(delta int)：Add 将 delta（可能为负）添加到 WaitGroup 计数器。如果计数器变为 0，所有在 Wait 时阻塞的 Goroutine 将被释放。如果计数器变成负值，Add 会 panic。 wg.Done()：当 WaitGroup 同步等待组中的某个 Goroutine 执行完毕后，设置这个 WaitGroup 的 counter 数值减 1，其实就是调用了 Add(-1)。 wg.Wait()：表示让当前的 Goroutine 等待，进入阻塞状态。一直到 WaitGroup 的计数器为 0，才能解除阻塞，这个 Goroutine 才能继续执行。 总之，WaitGroup 让某个协程等待其它若干协程都先完成它们各自的任务。\n1func main() { 2\tconst N = 5 3\tvar values [N]int64 4\tvar wg sync.WaitGroup 5\tfor i := 0; i \u0026lt; N; i++ { 6\ti := i 7\twg.Add(1) 8\tgo func() { 9\tvalues[i] = 50 + rand.Int63n(50) 10\tfmt.Println(\u0026#34;Done:\u0026#34;, i) 11\twg.Done() // \u0026lt;=\u0026gt; wg.Add(-1) 12\t}() 13\t} 14 15\twg.Wait() 16\t// 所有的元素都保证被初始化了。 17\tfmt.Println(\u0026#34;values:\u0026#34;, values) 18} 2. Once Once 是只执行一次的对象。Once 使用后不能复制。\n1type Once struct { 2 // done indicates whether the action has been performed. 3 // It is first in the struct because it is used in the hot path. 4 // The hot path is inlined at every call site. 5 // Placing done first allows more compact instructions on some architectures (amd64/386), 6 // and fewer instructions (to calculate offset) on other architectures. 7 done uint32 8 m Mutex 9} Once 只有一个 Do(f func()) 方法，该方法只有一个类型为func()的参数。\n1func (o *Once) Do(f func()) { 2\tif atomic.LoadUint32(\u0026amp;o.done) == 0 { 3\t// Outlined slow-path to allow inlining of the fast-path. 4\to.doSlow(f) 5\t} 6} 对一个可寻址的sync.Once值 o，o.Do() 方法调用可以在多个协程中被多次并发地执行，方法调用的实参应该为同一个函数值。最终，有且只有一个调用的实参函数被调用。被调用的实参函数内的代码将在任何o.Do()方法返回调用之前被执行。\n简单来说，sync.Once被用来确保一段代码在一个并发程序中被执行且仅被执行一次，常用于单例模式。\n1func main() { 2\tvar once sync.Once 3\tonceBody := func() { 4\tfmt.Println(\u0026#34;Only Once\u0026#34;) 5\t} 6\tdoneChan := make(chan bool) 7\tfor i := 0; i \u0026lt; 10; i++ { 8\tgo func() { 9\tonce.Do(onceBody) 10\tdoneChan \u0026lt;- true 11\t}() 12\t} 13 14\tfor i := 0; i \u0026lt; 10; i++ { 15\t\u0026lt;- doneChan 16\t} 17} 18 19// Only Once 3. Mutex Go 语言包中的 sync 包提供了两种锁类型：sync.Mutex 和 sync.RWMutex。\nMutex 是最简单的一种锁类型 —— 互斥锁，同时也比较暴力，当一个 Goroutine 获得了 Mutex 后，其他 Goroutine 就只能等到该 Goroutine 释放 Mutex。\n互斥锁是传统并发编程对共享资源进行访问控制的主要手段，它由标准库 sync 中的 Mutex 结构体类型表示。sync.Mutex 类型只有两个公开的指针方法：Lock 和 Unlock。\nLock 锁定当前的共享资源 Unlock 进行解锁 1// A Mutex is a mutual exclusion lock. 2// The zero value for a Mutex is an unlocked mutex. 3// 4// A Mutex must not be copied after first use. 5type Mutex struct { 6 state int32 7 sema uint32 8} 9 10// Lock locks m. 11// If the lock is already in use, the calling goroutine 12// blocks until the mutex is available. 13func (m *Mutex) Lock() { 14\t// Fast path: grab unlocked mutex. 15\tif atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) { 16\tif race.Enabled { 17\trace.Acquire(unsafe.Pointer(m)) 18\t} 19\treturn 20\t} 21\t// Slow path (outlined so that the fast path can be inlined) 22\tm.lockSlow() 23} 24 25// Unlock unlocks m. 26// It is a run-time error if m is not locked on entry to Unlock. 27// 28// A locked Mutex is not associated with a particular goroutine. 29// It is allowed for one goroutine to lock a Mutex and then 30// arrange for another goroutine to unlock it. 31func (m *Mutex) Unlock() { 32\tif race.Enabled { 33\t_ = m.state 34\trace.Release(unsafe.Pointer(m)) 35\t} 36 37\t// Fast path: drop lock bit. 38\tnew := atomic.AddInt32(\u0026amp;m.state, -mutexLocked) 39\tif new != 0 { 40\t// Outlined slow path to allow inlining the fast path. 41\t// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock. 42\tm.unlockSlow(new) 43\t} 44} 3.1 RWMutex RWMutex 是读写锁，该锁可以由任意数量的读者或单个写者持有。RWMutex 的零值是未锁定的互斥锁。RWMutex 被第一次使用后不得复制。\n如果一个 Goroutine 持有一个 RWMutex 的读锁并且另一个 Goroutine 可能会调用 Lock，那么在前面的读锁被释放之前，任何 Goroutine 都不应该期望能够获取读锁。\n特别的，禁止递归占有读锁，这是为了确保锁最终会被释放；被阻塞的 Lock 调用会将新的读者排除在获取锁之外。\nrwm.RLock()：上读锁 rwm.RUnlock()：解读锁 rwm.Lock()：上锁 rwm.Unlock()：解锁 总结为如下三条：\n同时只能有一个 Goroutine 能够获得写锁 同时可以有任意多个 Gorouinte 获得读锁 同时只能存在写锁或读锁（读和写互斥） 因此，RWMutex 经常用于读远远多于写的场景。\n4. Map sync.Map 对于多个 Goroutine 并发使用是安全的，无需额外的锁定或协调。Load、Store 和 Delete 在分摊常数时间内运行。\nsync.Map 针对两种常见用例进行了优化：\n当给定 key 的条目只写入一次但读取多次 当多个 Goroutine 读取、写入和覆盖不相交的 key 集的条目 在这两种情况下，与使用单独的 Mutex 或 RWMutex 配对的 Go map 相比，使用 Map 可以显着减少锁的竞争。\n1type Map struct { 2\tmu Mutex 3\tread atomic.Value // readOnly 4\tdirty map[interface{}]*entry 5\tmisses int 6} m.Load(k) (v, ok)：并发安全的 get。 m.Store(k, v)：并发安全的 put。 m.Delete(k)：并发安全的 delete。 m.LoadAndDelete(k) (v, loaded)：LoadAndDelete 删除键的值，如果之前有值，则返回之前的值，loaded 表示是否有之前的值。 m.LoadAndStore(k, v) (actual, loaded)：LoadOrStore 返回键的现有值（如果存在）。否则，它存储并返回给定的值。loaded 为 true 表示返回现有值，loaded 为 false 表示存储给定值。 m.Range(func(k, v) bool)：按照传入的 func 规则遍历 Map。 1func main() { 2\tm := sync.Map{} 3\tgo func() { 4\tm.Store(1,2) 5\tfmt.Println(m.Load(1)) 6\t}() 7\tgo func() { 8\tm.Store(1,2) 9\tfmt.Println(m.Load(1)) 10\t}() 11\tfmt.Println(m.Load(1)) 12\ttime.Sleep(5 * time.Second) 13} 参考资料 https://hedon954.github.io/noteSite/backend/golang/standard_packages/sync.html ","permalink":"/tech/golang/golang-%E6%A0%87%E5%87%86%E5%BA%93-sync/","summary":"\u003ch1 id=\"1-waitgroup\"\u003e1. WaitGroup\u003c/h1\u003e\n\u003cp\u003eWaitGroup 等待一组 Goroutine 完成。主 Goroutine 调用 Add(delta) 来设置要等待的 Goroutine 的数量。然后每个 Goroutine 运行并在完成时调用 Done()。同时，可以使用 Wait() 来阻塞，直到所有 Goroutine 完成。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003etype\u003c/span\u003e \u003cspan class=\"nx\"\u003eWaitGroup\u003c/span\u003e \u003cspan class=\"kd\"\u003estruct\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003enoCopy\u003c/span\u003e \u003cspan class=\"nx\"\u003enoCopy\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"c1\"\u003e// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 5\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"c1\"\u003e// 64-bit atomic operations require 64-bit alignment, but 32-bit\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"c1\"\u003e// compilers do not ensure it. So we allocate 12 bytes and then use\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 7\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"c1\"\u003e// the aligned 8 bytes in them as state, and the other 4 as storage\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 8\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"c1\"\u003e// for the sema.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 9\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"nx\"\u003estate1\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"kt\"\u003euint32\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e10\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ewg.Add(delta int)\u003c/strong\u003e：Add 将 delta（可能为负）添加到 WaitGroup 计数器。如果计数器变为 0，所有在 Wait 时阻塞的 Goroutine 将被释放。如果计数器变成负值，Add 会 panic。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ewg.Done()\u003c/strong\u003e：当 WaitGroup 同步等待组中的某个 Goroutine 执行完毕后，设置这个 WaitGroup 的 counter 数值减 1，其实就是调用了 Add(-1)。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ewg.Wait()\u003c/strong\u003e：表示让当前的 Goroutine 等待，进入阻塞状态。一直到 WaitGroup 的计数器为 0，才能解除阻塞，这个 Goroutine 才能继续执行。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e总之，\u003cstrong\u003eWaitGroup 让某个协程等待其它若干协程都先完成它们各自的任务\u003c/strong\u003e。\u003c/p\u003e","title":"Golang 标准库丨sync"},{"content":"1. 基础特性 1.1 先进后出 对于多个defer语句，类似栈，按先进后出的顺序执行。\n1func main() { 2 var whatever [5]struct{} 3 for i := range whatever { 4 defer fmt.Print(i) 5 } 6} 7 8// 43210 1.2 实时解析函数参数 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func test(a int) {//无返回值函数 6\tdefer fmt.Println(\u0026#34;1、a =\u0026#34;, a) //方法 7\tdefer func(v int) { fmt.Println(\u0026#34;2、a =\u0026#34;, v)} (a) //有参函数 8\tdefer func() { fmt.Println(\u0026#34;3、a =\u0026#34;, a)} () //无参函数 9\ta++ 10} 11func main() { 12\ttest(1) 13} 14 15// 3、a = 2 16// 2、a = 1 17// 1、a = 1 1.3 return 返回机制 defer、return、返回值三者的执行逻辑应该是：\n首先，return 最先执行，return将结果写入返回值中； 接着，defer 执行收尾工作； 最后，函数携带当前返回值（可能和最初的返回值不相同）退出。 defer 在 return 后 defer放在return后面时，不会被执行。\n1func f(i int) int{ 2\treturn i 3\tdefer fmt.Print(\u0026#34;i =\u0026#34;, i) 4\treturn i+1 5} 6 7func main() { 8\tf(1) 9} 没有输出，因为return i之后函数就已经结束了，不会执行defer。\n无名返回值 🎓 1func a() int { 2\tvar i int 3\tdefer func() { 4\ti++ 5\tfmt.Println(\u0026#34;defer2:\u0026#34;, i) 6\t}() 7\tdefer func() { 8\ti++ 9\tfmt.Println(\u0026#34;defer1:\u0026#34;, i) 10\t}() 11\treturn i 12} 13 14func main() { 15\tfmt.Println(\u0026#34;return:\u0026#34;, a()) 16} 1defer1: 1 2defer2: 2 3return: 0 返回值由变量 i 赋值，相当于返回值=i=0。\n第二个defer中i++ = 1， 第一个defer中i++ = 2，所以最终i的值是2。\n但返回值已经被赋值了，即使后续修改i也不会影响返回值。最终返回值返回，所以main中打印0。\n有名返回值 🎓 1func b() (i int) { 2\tdefer func() { 3\ti++ 4\tfmt.Println(\u0026#34;defer2:\u0026#34;, i) 5\t}() 6\tdefer func() { 7\ti++ 8\tfmt.Println(\u0026#34;defer1:\u0026#34;, i) 9\t}() 10\treturn i //或者直接写成return 11} 12 13func main() { 14\tfmt.Println(\u0026#34;return:\u0026#34;, b()) 15} 1defer1: 1 2defer2: 2 3return: 2 此处指明了返回值就是i，所以后续对 i 进行修改都相当于在修改返回值，所以最终函数的返回值是2。\n特殊情况\n注意下列代码，返回值 r 作为参数传入 defer，虽然有 r = r + 5 ，但这是局部变量，与 f() 中的返回值 r 无关，因此该函数仍然返回 1\n1func f() (r int) { 2 defer func(r int) { 3 r = r + 5 4 }(r) 5 return 1 6} 函数返回值为地址 本质上和有名返回值一样。\n1func c() *int { 2\tvar i int 3\tdefer func() { 4\ti++ 5\tfmt.Println(\u0026#34;defer2:\u0026#34;, i) 6\t}() 7\tdefer func() { 8\ti++ 9\tfmt.Println(\u0026#34;defer1:\u0026#34;, i) 10\t}() 11\treturn \u0026amp;i 12} 13 14func main() { 15\tfmt.Println(\u0026#34;return:\u0026#34;, *(c())) 16} 1defer1: 1 2defer2: 2 3return: 2 2. Defer 与闭包 for 结束时 t.name=\u0026quot;c\u0026quot;，接下来执行的那些defer语句中用到的t.name的值均为\u0026quot;c\u0026quot;。\n1type Test struct { 2\tname string 3} 4func (t *Test) pp() { 5\tfmt.Println(t.name) 6} 7func main() { 8\tts := []Test{{\u0026#34;a\u0026#34;}, {\u0026#34;b\u0026#34;}, {\u0026#34;c\u0026#34;}} 9\tfor _, t := range ts { 10\tdefer t.pp() 11\t} 12} 13// c 14// c 15// c 修改代码，使用有参参数\ndefer语句中的参数会实时解析，所以在碰到defer语句的时候就把该时的t代入了。\n1type Test struct { 2\tname string 3} 4func pp(t Test) { 5\tfmt.Println(t.name) 6} 7func main() { 8\tts := []Test{{\u0026#34;a\u0026#34;}, {\u0026#34;b\u0026#34;}, {\u0026#34;c\u0026#34;}} 9\tfor _, t := range ts { 10\tdefer pp(t) 11\t} 12} 13// c 14// b 15// a 修改代码，在循环中声明新变量\n每次都有一个新的变量tt:=t，所以每次在执行defer语句时，对应的 tt 不是同一个，所以输出的结果也不相同。\n1type Test struct { 2\tname string 3} 4func (t *Test) pp() { 5\tfmt.Println(t.name) 6} 7 8func main() { 9\tts := []Test{{\u0026#34;a\u0026#34;}, {\u0026#34;b\u0026#34;}, {\u0026#34;c\u0026#34;}} 10\tfor _, t := range ts { 11\ttt := t 12\tprintln(\u0026amp;tt) 13\tdefer tt.pp() 14\t} 15} 10xc000010200 20xc000010210 30xc000010220 4c 5b 6a 3. Defer 常见使用场景 3.1 关闭文件 开启文件后，使用 defer 关闭文件。\n1func ReadFile(filename string) ([]byte, error) { 2 f, err := os.Open(filename) 3 if err != nil { 4 return nil, err 5 } 6 defer f.close() 7 return ReadAll() 8} 3.2 互斥锁 加锁后，使用 defer 解锁。\n1var mu sync.Mutex 2var m = make(map[string]int) 3 4func lookup(key string) int { 5 mu.Lock() 6 defer mu.Unlock() 7 return m[key] 8} 调用os.Exit时defer不会被执行\n1func deferExit() { 2 defer func() { 3 fmt.Println(\u0026#34;defer\u0026#34;) 4 }() 5 os.Exit(0) 6} 参考资料 https://blog.csdn.net/Cassie_zkq/article/details/108567205 ","permalink":"/tech/golang/golang-defer/","summary":"\u003ch1 id=\"1-基础特性\"\u003e1. 基础特性\u003c/h1\u003e\n\u003ch2 id=\"11-先进后出\"\u003e1.1 先进后出\u003c/h2\u003e\n\u003cp\u003e对于多个defer语句，类似栈，按\u003cstrong\u003e先进后出\u003c/strong\u003e的顺序执行。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kd\"\u003evar\u003c/span\u003e \u003cspan class=\"nx\"\u003ewhatever\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e5\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"kd\"\u003estruct\u003c/span\u003e\u003cspan class=\"p\"\u003e{}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"nx\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"k\"\u003erange\u003c/span\u003e \u003cspan class=\"nx\"\u003ewhatever\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003edefer\u003c/span\u003e \u003cspan class=\"nx\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ePrint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e5\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e7\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e8\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 43210\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"12-实时解析函数参数\"\u003e1.2 实时解析函数参数\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003epackage\u003c/span\u003e \u003cspan class=\"nx\"\u003emain\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;fmt\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 5\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"nf\"\u003etest\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ea\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"c1\"\u003e//无返回值函数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"k\"\u003edefer\u003c/span\u003e \u003cspan class=\"nx\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ePrintln\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;1、a =\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"c1\"\u003e//方法\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 7\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"k\"\u003edefer\u003c/span\u003e \u003cspan class=\"kd\"\u003efunc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ev\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nx\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ePrintln\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;2、a =\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ev\u003c/span\u003e\u003cspan class=\"p\"\u003e)}\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"c1\"\u003e//有参函数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 8\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"k\"\u003edefer\u003c/span\u003e \u003cspan class=\"kd\"\u003efunc\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nx\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ePrintln\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;3、a =\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)}\u003c/span\u003e \u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"c1\"\u003e//无参函数\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 9\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"nx\"\u003ea\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e10\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e11\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e12\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nf\"\u003etest\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e13\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e14\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e15\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 3、a = 2\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e16\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 2、a = 1\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e17\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 1、a = 1\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"13-return-返回机制\"\u003e1.3 return 返回机制\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003edefer、return、返回值三者的执行逻辑应该是：\u003c/strong\u003e\u003c/p\u003e","title":"Golang Defer"},{"content":"Pod 是 K8s 集群中创建和管理的、最小的可部署的计算单元。K8s 不会直接操作容器，而是通过 Pod 封装了容器，集群通过管控 Pod ，便可控制容器的存储、网络等资源，实现资源隔离或共享。\nK8s Pod 中的所有容器共享一个相同的 Linux 命名空间(network、UTS、IPC)，而不是每个容器一个命名空间，这一点与 Docker 不同，因此 Pod 中的多个容器使用相同的网络、主机名称，看到的是同一个 IP 地址。\n不过进程还是按照容器进行隔离。由于 Mount、User 命名空间不共享，因此在容器中，文件系统和用户是隔离的。\n启动流程 在 Kubernetes 中，当创建 Pod 时，会先启动一个 pause 容器，pause 容器创建了网络，然后应用容器以 Container 模式连接到该 pause 容器的网络。\n生命周期 当 Pod 被分配到某个节点时， Pod 会一直在该节点运行，直到停止或被终止，Pod 在整个生命周期中只会被调度一次。\nPod 的整个生命周期可能有四种状态：\nPending，尝试启动容器，如果容器正常启动，则进入下一个阶段； Running，处于运行状态； Succeeded、Failed，正常结束或故障等导致容器结束； Unknown，因为某些原因无法取得 Pod 的状态。 部署方式 Deployment Deployment 管理部署 Pod，维持 Pod 的副本数量以及 Pod 监控和维护。\n1kubectl apply -f nginx.yaml kubectl apply 命令将会把推送的版本与以前的版本进行比较，并应用你所做的更改，并且不会自动覆盖任何你没有指定更改的属性。根据 Kubernetes 官方的文档，应始终使用 kubectl apply 或 kubectl create --save-config 创建资源。\n1kubectl create deployment testnginx --image=nginx:latest --dry-run=client -o yaml --dry-run 取值必须为none、server或client。如果客户端策略，只打印将要发送的对象，而不发送它。如果是服务器策略，提交服务器端请求而不持久化资源。\nReplicaSet Deployment 的 YAML 文件中有 replicas 字段，表示维持多少个 Pod 实例。\n1spec: 2 progressDeadlineSeconds: 600 3 replicas: 1 创建一个 Deployment 时，Deployment 会自动创建一个 ReplicaSet ，ReplicaSet 管理的副本数量跟 YAML 文件中 replicas 字段值一致。\nDaemonSet DaemonSet 确保一个节点只运行一个 Pod。\nDaemonSet 无视节点的排斥性，即节点可以排斥调度器在此节点上部署 Pod，DaemonSet 则会绕过调度器，强行部署。\nDaemonSet 的一些典型用法：\n在每个节点上运行集群守护进程 在每个节点上运行日志收集守护进程 在每个节点上运行监控守护进程 StatefulSet todo 扩容、缩容 scale 使用 kubectl scale 命令直接设置：\n1kubectl scale deployment nginx --replicas=10 autoscale Pod 水平自动扩缩可以基于 CPU 利用率自动扩缩 ReplicationController、Deployment、ReplicaSet 和 StatefulSet 中的 Pod 数量。Pod 自动扩缩不适用于无法扩缩的对象，比如 DaemonSet。\n除了 CPU 利用率，也可以基于其他应程序提供的自定义度量指标 来执行自动扩缩。\n参考资料： https://kubernetes.io/zh/docs/tasks/run-application/horizontal-pod-autoscale/\n1kubectl autoscale deployment nginx --min=10 --max=15 --cpu-percent=80 表示目标 CPU 使用率为 80%(期望指标)，副本数量配置应该为 10 到 15 之间，CPU 是动态缩放 pod 的指标，会根据具体的 CPU 使用率计算副本数量，其计算公式如下。\n1期望副本数 = ceil[当前副本数 * (当前指标 / 期望指标)] 按照算法计算，若当前副本数量为 12，且 CPU 使用率达到 90%，则期望副本数为 12*(90%/80%) = 13.5，那么理论上会部署 14 个 Pod，但是 CPU 再继续增加的话，最多 15 个副本数量。如果在机器管够的情况下，可以去掉 min 和 max 参数。\n比例缩放 比例缩放指的是在上线 Deployment 时，临时运行着应用程序的多个版本(共存)，比例缩放是控制上线时多个 Pod 服务可用数量的方式。\n水平缩放只关心最终的期望 Pod 数量，直接修改副本数和水平缩放，决定最终 Pod 数量有多少个。\n而比例缩放是控制对象上线过程中，新 Pod 的创建速度和旧 Pod 的销毁速度、 Pod 的可用程度，跟上线过程中新旧版本的 Pod 替换数量有关。\n查看上一章中创建的 Deployment 的部分 YAML 如下：\n1spec: 2 progressDeadlineSeconds: 600 3 replicas: 1 4 revisionHistoryLimit: 10 5 selector: 6 matchLabels: 7 app: nginx 8 strategy: 9 rollingUpdate: 10 maxSurge: 25% 11 maxUnavailable: 25% 12 type: RollingUpdate maxUnavailable：最大不可用数量或比例，旧的 Pod 会以这个数量或比例逐渐减少。 maxSurge：最大峰值，新的 Pod 会按照这个数量或比例逐渐创建。 如果想新版本的 Pod 上线速度更快，则可以把 maxSurge 数量或比例设置大一些；为了保证上线过程稳定、服务可用程度高，可以把 maxUnavailable 设置小一些。\nstrategy 可以配置 Pod 是怎么更新的。当我们设置.spec.strategy.type==RollingUpdate时，便会采取滚动更新的方式更新 Pods，此时可以指定 maxUnavailable 和 maxSurge 来控制滚动更新 过程。这个我们之前提到过，就是 Deployment 默认会保证一直有 75% 的 pod处于可用状态，在完成更新前可能有多个版本的 pod 共存。\n标签与选择 label Label 是附加到 Kubernetes 对象上的键值对，例如 Pod 可通过 kubectl describe pods 查询，可以看到每个 Pod 都带有 Labels: app=...。\n1... ... 2Labels: app=nginx 3 pod-template-hash=85b45874d9 4... ... 创建 Deployment 时，如果没有指定 Pod 的 app 标签值，那么一般跟 Deployment 名称一致。\n在 Deployment 中，selector 字段设置了如何查找属于此对象的 Pod。\n1 selector: 2 matchLabels: 3 app: nginx 命令式 label 选择 查询 Pod 所有的 Label：\n1kubectl get pods --show-labels 查找符合条件的 pod\n1kubectl get pods -l app=nginx 2kubectl get pods -l app!=nginx 列出不包含某个标签的 Pod：\n1kubectl get pods -l \u0026#39;!env\u0026#39; 2kubectl get pods -l \u0026#39;!app\u0026#39; 获取同时包含两个标签的 Pod：\n1kubectl get pods -l app,env 标签选择有等值和集合两种，其中等值选择有 =、==、!= 三种符号，= 和 == 无任何区别，所以实际只有 等于 、不等于 两种选择情况。\n在多个需求(多个label)的情况下，可以使用 \u0026amp;\u0026amp; 运算符，表示需要同时符合多个条件，但是选择器不存在 || 这种逻辑或运算符。\n查看符合两个条件的节点：\n1# 多个条件使用 逗号\u0026#34;,\u0026#34;\u0026#34; 隔开，而不是 \u0026#34;\u0026amp;\u0026amp;\u0026#34;。 2kubectl get nodes -l disktype=ssd,disksize!=big selector 1spec: 2 selector: 3 matchLabels: 4 app: nginx 5 template: 6 metadata: 7 labels: 8 app: nginx spec.template 是定义所有 Pod 的模板，template.metadata 可以为所有 Pod 设置一些元数据，例如 labels。\nspec.selector 定义 Deployment 如何查找要管理的 Pods。matchLabels 中的标签表示集合运算的 in，Pod 只需要包含这些标签，就会被此 Deployment 管理。\n若 matchLabels 还可进一步使用 matchExpressions\n注解 Kubernetes 注解为对象附加任意的非标识的元数据，注解使用 annotations 标识。客户端程序（例如工具和库）能够获取这些元数据信息。\nannotations 由 key/value 组成，类似 label，但是 annotations 支持一些特殊字符，可以用作构建发布镜像时的信息、日志记录等。\n1Annotations: meta.helm.sh/release-name: kubernetes-dashboard 2 meta.helm.sh/release-namespace: kubernetes-dashboard 亲和性、反亲和性 节点亲和性类似于 nodeSelector ，根据节点上的标签约束 Pod 可以调度到哪些节点。\nPod 亲和性有两种别为：\nrequiredDuringSchedulingIgnoredDuringExecution：必须满足 preferredDuringSchedulingIgnoredDuringExecution：尽力满足 1apiVersion: v1 2kind: Pod 3metadata: 4 name: with-node-affinity 5spec: 6 affinity: 7 nodeAffinity: 8 requiredDuringSchedulingIgnoredDuringExecution: 9 nodeSelectorTerms: 10 - matchExpressions: 11 - key: kubernetes.io/e2e-az-name 12 operator: In 13 values: 14 - e2e-az1 15 - e2e-az2 16 preferredDuringSchedulingIgnoredDuringExecution: 17 - weight: 1 18 preference: 19 matchExpressions: 20 - key: another-node-label-key 21 operator: In 22 values: 23 - another-node-label-value 24 containers: 25 - name: with-node-affinity 26 image: k8s.gcr.io/pause:2.0 如果我们设置了多个 nodeSelectorTerms ：\n1requiredDuringSchedulingIgnoredDuringExecution: 2 nodeSelectorTerms: 3 ... 4 nodeSelectorTerms: 则只需要满足其中一种表达式即可调度 Pod 到 节点上。\n我们再回忆一下，节点选择器叫 nodeSelector，而节点亲和性叫 nodeAffinity，它们都可以让 Deployment 等对象部署 Pod 时选择合适的节点，它们都是使用标签(Label)来完成选择工作。\n如果你同时指定了 nodeSelector 和 nodeAffinity ，则两者必须同时满足条件， 才能将 Pod 调度到候选节点上。\n亲和性和反亲和性的 YAML 很复杂，需要使用时查看文档。\nhttps://kubernetes.io/zh/docs/concepts/scheduling-eviction/assign-pod-node\n污点、容忍度 当节点添加一个污点后，除非 Pod 声明能够容忍这个污点，否则 Pod 不会被调度到这个 节点上。\n如果节点存在污点，那么 Pod 可能不会被分配到此节点上；如果节点一开始没有设置污点，然后部署了 Pod，后面节点设置了污点，节点可能会删除已部署的 Pod，这种行为称为驱逐。\n节点污点(taint) 可以排斥一类特定的 Pod，而 容忍度(Toleration)则表示能够容忍这个对象的污点。\n节点的污点可以设置为以下三种效果：\nNoSchedule：不能容忍此污点的 Pod 不会被调度到节点上；不会影响已存在的 pod。 PreferNoSchedule：Kubernetes 会避免将不能容忍此污点的 Pod 安排到节点上。 NoExecute：如果 Pod 已在节点上运行，则会将该 Pod 从节点中逐出；如果尚未在节点上运行，则不会将其调度到此节点上。 当节点设置污点后，无论其效果是哪一种，只要 Pod 没有设置相关的容忍度，Pod 就不会调度到此节点上。\n系统默认污点 尽管一个节点上的污点完全排斥 Pod，但是某些系统创建的 Pod 可以容忍所有 NoExecute 和 NoSchedule 污点，因此不会被逐出。\n例如 master 节点是不会被 Deployment 等分配 Pod 的，因为 master 有个污点，表面它只应该运行kube-system 命名空间中的很多系统 Pod，用户 Pod 会被排斥部署到 master 节点上。\n当然我们通过修改污点，可以让用户的 Pod 部署到 master 节点中。\nmaster 节点上会有一个 node-role.kubernetes.io/master:NoSchedule 的污点，Kubernetes 部署用户的 Pod 时会检查节点是否存在此污点，如果有，则不会在此节点上部署 Pod。\n除了 node-role.kubernetes.io/master ，某些情况下节点控制器会自动给节点添加一个污点。当前内置的污点包括：\nnode.kubernetes.io/not-ready：节点未准备好。这相当于节点状态 Ready 的值为 \u0026ldquo;False\u0026quot;。 node.kubernetes.io/unreachable：节点控制器访问不到节点. 这相当于节点状态 Ready 的值为 \u0026ldquo;Unknown\u0026quot;。 node.kubernetes.io/out-of-disk：节点磁盘耗尽。 node.kubernetes.io/memory-pressure：节点存在内存压力。 node.kubernetes.io/disk-pressure：节点存在磁盘压力。 node.kubernetes.io/network-unavailable：节点网络不可用。 node.kubernetes.io/unschedulable: 节点不可调度。 node.cloudprovider.kubernetes.io/uninitialized：如果 kubelet 启动时指定了一个 \u0026ldquo;外部\u0026rdquo; 云平台驱动， 它将给当前节点添加一个污点将其标志为不可用。在 cloud-controller-manager 的一个控制器初始化这个节点后，kubelet 将删除这个污点。 当节点上的资源不足时，会添加一个污点，排斥后续 Pod 在此 节点上部署，但不会驱逐已存在的 Pod。如果我们的 Pod 对机器资源有要求，可以排斥相关的污点，如果没要求，则需要容忍相关污点。\n容忍度 污点和容忍度相互配合，用来避免 Pod 被分配到不合适的节点上；也可以让真正合适的 Pod 部署到有污点的节点上。\n1// 容忍带有 key1 标签的污点，且无论是什么值。 2tolerations: 3- key: \u0026#34;key1\u0026#34; 4 operator: \u0026#34;Exists\u0026#34; 5 effect: \u0026#34;NoSchedule\u0026#34; 也可以设置带 value 的容忍。\n1tolerations: 2- key: \u0026#34;key1\u0026#34; 3 operator: \u0026#34;Equal\u0026#34; 4 value: \u0026#34;value1\u0026#34; 5 effect: \u0026#34;NoSchedule\u0026#34; 如果 Pod 的容忍度设置为以下 YAML：\n1tolerations: 2 operator: \u0026#34;Exists\u0026#34; 则表示此 Pod 能够容忍任意的污点，无论节点怎么设置 key、value 、effect ，此 Pod 都不会介意。\n如果要在 master 上也能部署 Pod，则可以修改 Pod 的容忍度：\n1 spec: 2 tolerations: 3 # this toleration is to have the daemonset runnable on master nodes 4 # remove it if your masters can\u0026#39;t run pods 5 - key: node-role.kubernetes.io/master 6 effect: NoSchedule 如果 operator 是 Exists 此时不需要填写 value 字段；如果存在 key 为 key1 的 label，且污点效果为 NoSchedule，无论是什么值都容忍。 如果 operator 是 Equal 则它们的 value 应该相等，如果相同的话，则容忍， 如果 effect 留空 则表示只要是 label 为 key1 的节点，都可以容忍。 Jobs、CronJobs Job、Cronjob 它们用于创建一个或多个 Pod，来完成某些任务，它们创建的 Pod 不会长久的运行在节点中。\nJob Job 是用来只运行一次任务的对象，Job 对象以一种可靠的方式运行某 Pod 直到完成，适合用于批处理，例如编译程序、执行运算任务。Job 适合一次完整的流程，完成后即可抛弃的任务。\n当 Job 启动时，Job 会跟踪成功完成的 Pod 的个数，当成功数量达到某个阈值时，Job 会被终结。当 Job 运行过程中，我们 暂停/挂起 Job，Job 会删除正在运行的 Pod，保留已完成的 Pod 数量，当恢复 Job 时，会创建新的 Pod，继续完成任务。\nJob 的结构很简单，下面是一个示例，这个 Job 只有一个镜像，启动后执行 sleep 3 命令，容器会在3秒后自动退出，Job 标记其已经完成。\n1apiVersion: batch/v1 2kind: Job 3metadata: 4 name: busybox 5spec: 6 template: 7 spec: 8 containers: 9 - name: busybox 10 image: busybox 11 command: [\u0026#34;/bin/sleep\u0026#34;] 12 args: [\u0026#34;3\u0026#34;] 13 restartPolicy: Never 对于这种简单的 Job，称为非并行的，它的特点有：\n只启动一个 Pod，除非该 Pod 失败； 当 Pod 成功终止时，立即视 Job 为完成状态； 完成数 使用.spec.completions 来设置完成数时，Job 控制器所创建的每个 Pod 使用完全相同的 spec 模板。 这意味着任务的所有 Pod 都有相同的命令行，都使用相同的镜像和数据卷，甚至连 环境变量都（几乎）相同。\n我们继续使用上次的 Job 模板，这里增加一个 completions ：\n1apiVersion: batch/v1 2kind: Job 3metadata: 4 name: busybox 5spec: 6 completions: 5 7 template: 8 spec: 9 containers: 10 - name: busybox 11 image: busybox 12 command: [\u0026#34;/bin/sleep\u0026#34;] 13 args: [\u0026#34;3\u0026#34;] 14 restartPolicy: Never 查看 Job 和 Pod：\n1root@instance-1:~# kubectl get jobs 2NAME COMPLETIONS DURATION AGE 3busybox 5/5 36s 38s 4root@instance-2:~# kubectl get pods 5NAME READY STATUS RESTARTS AGE 6busybox-rfhcj 0/1 Completed 0 9s 7busybox-stkbg 0/1 Completed 0 23s 8busybox-xk6sb 0/1 Completed 0 30s 9busybox-z6h9x 0/1 Completed 0 40s 10busybox-zqgcb 0/1 Completed 0 16s Pod 的创建是串行的，每次只运行一个 Pod，当一个 Pod 处于 Completed 状态时，创建下一个 Pod。当有 5 个 Pod 处于 Completed 状态时，此 Job 标记完成。\n并行 1kubectl get job busybox -o yaml 2... ... 3spec: 4 backoffLimit: 6 5 completions: 5 6 parallelism: 1 7 selector: 8 ... ... 可以看到 parallelism=1，是控制并行度的字段，由于这个字段默认为 1，所以这个 Job 每次只能运行一个 Pod。\nspec.completions 和 spec.parallelism，这两个属性都不设置时，均取默认值 1。\n带类型的 Job Job 中的 Pod 都是一样的，因此如果要 Job 处理不同的工作任务，则需要外界帮忙。\n举个例子，平台是一个电商系统，消息队列中有评论、订单等五类消息，那么应该设计五种程序去处理这些消息，但是 Pod 只有一种。此时可以设置原子性的任务领取中心，Job 启动 Pod 后，Pod 便向任务中心领取任务类型，领取到后，开始工作。\n那么 Job 中的 Pod 可能是这样完成工作的：\n![[Pasted image 20230827163440.png]]\n在 Job 创建的 Pod 中，会有个名为 JOB_COMPLETION_INDEX 的环境变量，此环境变量标识了 Pod 的索引，Pod 可以通过此索引标识自己的身份。\n示例 YAML 如下：\n1apiVersion: batch/v1 2kind: Job 3metadata: 4 name: busybox 5spec: 6 parallelism: 1 7 completions: 5 8 completionMode: Indexed 9 template: 10 spec: 11 containers: 12 - name: busybox 13 image: busybox 14 command: [\u0026#34;env\u0026#34;] 15 restartPolicy: Never completionMode: Indexed 表明当前 Pod 是带索引的，如果 completionMode: NonIndexed 则不带索引。\n索引会按照 0，1，2，3 这样递增。\n执行 kubectl apply -f job.yaml 启动此 Job，会发现：\n1root@master:~# kubectl get pods 2NAME READY STATUS RESTARTS AGE 3busybox-0-j8gvz 0/1 Completed 0 29s 4busybox-1-k4kfx 0/1 Completed 0 25s 5busybox-2-zplxl 0/1 Completed 0 14s 6busybox-3-pj4jk 0/1 Completed 0 10s 7busybox-4-q5fq9 0/1 Completed 0 6s Job 终止和清理 如果我们不希望 Job 运行太长时间，可以为 Job 的 .spec.activeDeadlineSeconds 设置一个秒数值。 在 Job 的整个生命期，无论 Job 创建了多少个 Pod。 一旦 Job 运行时间达到 activeDeadlineSeconds 秒，其所有运行中的 Pod 都会被终止，并且 Job 的状态更新为 type: Failed 及 reason: DeadlineExceeded。\nYAML 示例：\n1apiVersion: batch/v1 2kind: Job 3metadata: 4 name: busybox 5spec: 6 completions: 5 7 activeDeadlineSeconds: 2 8 template: 9 spec: 10 containers: 11 - name: busybox 12 image: busybox 13 command: [\u0026#34;/bin/sleep\u0026#34;] 14 args: [\u0026#34;3\u0026#34;] 15 restartPolicy: Never CronJob CronJobs 对于创建周期性的、反复重复的任务很有用，例如执行数据备份或者发送邮件。 CronJobs 也可以用来计划在指定时间时来执行的独立任务，例如计划当集群看起来很空闲时 执行某个 Job。\n可供实验的 YAML 示例如下：\n1apiVersion: batch/v1beta1 2kind: CronJob 3metadata: 4 name: hello 5spec: 6 schedule: \u0026#34;*/1 * * * *\u0026#34; 7 jobTemplate: 8 spec: 9 template: 10 spec: 11 containers: 12 - name: hello 13 image: busybox 14 imagePullPolicy: IfNotPresent 15 command: 16 - /bin/sh 17 - -c 18 - date; echo Hello from the Kubernetes cluster 19 restartPolicy: OnFailure 此 CronJob 会每分钟执行一次。\n","permalink":"/tech/kubernetes/pod-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","summary":"\u003cp\u003ePod 是 K8s 集群中创建和管理的、最小的可部署的计算单元。K8s 不会直接操作容器，而是通过 Pod 封装了容器，集群通过管控 Pod ，便可控制容器的存储、网络等资源，实现资源隔离或共享。\u003c/p\u003e","title":"K8s Pod 基础知识"},{"content":"升级 OpenSSH 从选择一个最新的版本 https://cdn.openbsd.org/pub/OpenBSD/OpenSSH/portable/\n1# 获取最新版本 openssh 2wget --no-check-certificate https://cdn.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-9.7p1.tar.gz 3 4# 解压 5tar -zxvf openssh-9.7p1.tar.gz 6 7# 安装相关需要组件 8yum -y install pam-devel gcc zlib-devel openssl-devel 9 10# 检查配置 11./configure --prefix=/usr --sysconfdir=/etc/ssh --with-zlib --with-ssl-dir=/usr/local/ssl --with-md5-passwords --mandir=/usr/share/man --with-pam 12 13# 编译安装 14make \u0026amp;\u0026amp; make install 编译完成之后会有部分文件中的参数例如 GSSAPIAuthentication 显示不支持，将其删掉即可。\n最后，重启 ssh 服务。\n1service sshd restart 取消 CBC 连接模式 这边的服务器版本太旧了，升级 OpenSSH 非常麻烦，可以直接不使用 CBC。\n1vim /etc/ssh/sshd_config 2 3 4# 如果已经有 Ciphers，则将aes128-cbc和3des-cbc等带有cbc后缀的删除 5# 否则添加 Ciphers 6Ciphers aes256-gcm@openssh.com,chacha20-poly1305@openssh.com,aes256-ctr,aes128-gcm@openssh.com,aes128-ctr 7 8 9# 重启 ssh 10systemctl restart sshd 测试生效\n1ssh -vv -oCiphers=aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,aes192-cbc,aes256-cbc 127.0.0.1 此时应该显示 1... 2Unable to negotiate with 127.0.0.1 port 22: no matching cipher found. Their offer: aes256-gcm@openssh.com,chacha20-poly1305@openssh.com,aes256-ctr,aes128-gcm@openssh.com,aes128-ctr Reference https://openfind.zendesk.com/hc/zh-tw/articles/5337454837519-%E6%9B%B4%E6%96%B0-CentOS-OpenSSH-%E7%89%88%E6%9C%AC https://www.cnblogs.com/niway/p/16808877.html ","permalink":"/tech/ops/cve-2008-5161-openssh-cbc%E6%A8%A1%E5%BC%8F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/","summary":"\u003ch1 id=\"升级-openssh\"\u003e升级 OpenSSH\u003c/h1\u003e\n\u003cp\u003e从选择一个最新的版本\n\u003ca href=\"https://cdn.openbsd.org/pub/OpenBSD/OpenSSH/portable/\"\u003ehttps://cdn.openbsd.org/pub/OpenBSD/OpenSSH/portable/\u003c/a\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 获取最新版本 openssh\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 2\u003c/span\u003e\u003cspan class=\"cl\"\u003ewget --no-check-certificate https://cdn.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-9.7p1.tar.gz\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 解压\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 5\u003c/span\u003e\u003cspan class=\"cl\"\u003etar -zxvf openssh-9.7p1.tar.gz\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 7\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 安装相关需要组件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 8\u003c/span\u003e\u003cspan class=\"cl\"\u003eyum -y install pam-devel gcc zlib-devel openssl-devel\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 9\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e10\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 检查配置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e11\u003c/span\u003e\u003cspan class=\"cl\"\u003e./configure --prefix\u003cspan class=\"o\"\u003e=\u003c/span\u003e/usr --sysconfdir\u003cspan class=\"o\"\u003e=\u003c/span\u003e/etc/ssh --with-zlib --with-ssl-dir\u003cspan class=\"o\"\u003e=\u003c/span\u003e/usr/local/ssl --with-md5-passwords --mandir\u003cspan class=\"o\"\u003e=\u003c/span\u003e/usr/share/man --with-pam\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e12\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e13\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 编译安装\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e14\u003c/span\u003e\u003cspan class=\"cl\"\u003emake \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e make install\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e编译完成之后会有部分文件中的参数例如 GSSAPIAuthentication 显示不支持，将其删掉即可。\u003c/p\u003e","title":"CVE-2008-5161 OpenSSH CBC模式信息泄露漏洞"},{"content":"使用golang标准库中的html/template时，在默认情况下渲染模版时为了安全等原因，会将字符串中的部分符号进行转义。\n注册自定义转义处理函数 1func unescapeHTML(s string) template.HTML { 2\treturn template.HTML(s) 3} 在定义转义处理函数后，我们需要使用Funcs()将其注册到模版中。需要注意，注册自定义函数需要在调用Parse()前进行。在注册时我们需要定义一个函数标识符，并在模版文本中使用。在下面例子中我们使用了名为unescapeHTML的函数标识符。\n1t, err := template.New(\u0026#34;wg_config\u0026#34;).Funcs(template.FuncMap{ 2\t\u0026#34;unescapeHTML\u0026#34;: unescapeHTML, 3\t}).Parse(tmplWireguardConf) 4... 5 6\tconfig := map[string]interface{}{ 7\t\u0026#34;now\u0026#34;: now, 8\t\u0026#34;wireGuardServer\u0026#34;: l.svcCtx.Config.WireGuardServer, 9\t\u0026#34;clientDataList\u0026#34;: nil, // todo 传[]Client 10\t} 11 12\terr = t.Execute(f, config) 另外在模版文本内容中，对于需要避免转义的部分需要使用上面定义的函数。 1PrivateKey = {{ unescapeHTML .wireGuardServer.PrivateKey }} 参考资料：\nhttps://www.ghosind.com/2022/06/28/go-template-escape-html ","permalink":"/tech/golang/golang-template-%E8%B7%B3%E8%BF%87-html-%E8%BD%AC%E4%B9%89/","summary":"\u003cp\u003e使用golang标准库中的\u003ccode\u003ehtml/template\u003c/code\u003e时，在默认情况下渲染模版时为了安全等原因，会将字符串中的部分符号进行转义。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e注册自定义转义处理函数\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"nf\"\u003eunescapeHTML\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003es\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"nx\"\u003etemplate\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eHTML\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003etemplate\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eHTML\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在定义转义处理函数后，我们需要使用\u003ccode\u003eFuncs()\u003c/code\u003e将其注册到模版中。需要注意，注册自定义函数需要在调用\u003ccode\u003eParse()\u003c/code\u003e前进行。在注册时我们需要定义一个函数标识符，并在模版文本中使用。在下面例子中我们使用了名为\u003ccode\u003eunescapeHTML\u003c/code\u003e的函数标识符。\u003c/p\u003e","title":"Golang template 跳过 HTML 转义"},{"content":" 安装 Jaeger Operator 1kubectl create namespace observability 2kubectl create -f https://github.com/jaegertracing/jaeger-operator/releases/download/v1.52.0/jaeger-operator.yaml -n observability 若 rbac-proxy 安装失败，则修改 kube-rbac-prox 镜像地址为 10.101.7.108:80/open_source/kubebuilder/kube-rbac-proxy:v0.13.0\n安装 Jaeger 1apiVersion: jaegertracing.io/v1 2kind: Jaeger 3metadata: 4 name: jaeger-prod 5 namespace: observability 6spec: 7 strategy: production 8 storage: 9 type: elasticsearch 10 esIndexCleaner: 11 enabled: true # turn the cron job deployment on and off 12 numberOfDays: 7 # number of days to wait before deleting a record 13 schedule: \u0026#34;55 23 * * *\u0026#34; # cron expression for it to run 14 options: 15 es: 16 server-urls: http://elasticsearch.szhems.svc:9200 17 index-prefix: dev 18 # tls: 19 # ca: /es/certificates/ca.crt 20 # secretName: jaeger-secret 21 # volumeMounts: 22 # - name: certificates 23 # mountPath: /es/certificates/ 24 # readOnly: true 25 # volumes: 26 # - name: certificates 27 # secret: 28 # secretName: quickstart-es-http-certs-public go-zero 每个服务的配置文件下添加Telemetry配置 1Log: 2 ServiceName: platform-api 3 Level: info 4 Stat: false 5 TimeFormat: 2006-01-02 15:04:05 参考资料：\nhttps://www.jaegertracing.io/docs/1.52/operator/#installing-the-operator-on-kubernetes ","permalink":"/tech/ops/jaeger-%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/","summary":"\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e安装 Jaeger Operator\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003ekubectl create namespace observability\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003ekubectl create -f https://github.com/jaegertracing/jaeger-operator/releases/download/v1.52.0/jaeger-operator.yaml -n observability\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e若 rbac-proxy 安装失败，则修改 kube-rbac-prox 镜像地址为 \u003ccode\u003e10.101.7.108:80/open_source/kubebuilder/kube-rbac-proxy:v0.13.0\u003c/code\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e安装 Jaeger\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003eapiVersion\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003ejaegertracing.io/v1\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"nt\"\u003ekind\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eJaeger\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"nt\"\u003emetadata\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003ejaeger-prod\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 5\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"nt\"\u003enamespace\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eobservability\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"nt\"\u003espec\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 7\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"nt\"\u003estrategy\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eproduction\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 8\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"nt\"\u003estorage\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 9\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003etype\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eelasticsearch\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e10\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eesIndexCleaner\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e11\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"nt\"\u003eenabled\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kc\"\u003etrue\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c\"\u003e# turn the cron job deployment on and off\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e12\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"nt\"\u003enumberOfDays\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"m\"\u003e7\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c\"\u003e# number of days to wait before deleting a record\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e13\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"nt\"\u003eschedule\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;55 23 * * *\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c\"\u003e# cron expression for it to run\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e14\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eoptions\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e15\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"nt\"\u003ees\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e16\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"nt\"\u003eserver-urls\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003ehttp://elasticsearch.szhems.svc:9200\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e17\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"nt\"\u003eindex-prefix\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003edev\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e18\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"c\"\u003e#     tls:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e19\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"c\"\u003e#       ca: /es/certificates/ca.crt\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e20\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"c\"\u003e# secretName: jaeger-secret\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e21\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"c\"\u003e# volumeMounts:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e22\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"c\"\u003e#   - name: certificates\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e23\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"c\"\u003e#     mountPath: /es/certificates/\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e24\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"c\"\u003e#     readOnly: true\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e25\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"c\"\u003e# volumes:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e26\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"c\"\u003e#   - name: certificates\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e27\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"c\"\u003e#     secret:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e28\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"c\"\u003e#       secretName: quickstart-es-http-certs-public\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"3\"\u003e\n\u003cli\u003e\u003cstrong\u003ego-zero 每个服务的配置文件下添加Telemetry配置\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003eLog\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"nt\"\u003eServiceName\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eplatform-api\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"nt\"\u003eLevel\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003einfo\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"nt\"\u003eStat\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kc\"\u003efalse\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e5\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"nt\"\u003eTimeFormat\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"ld\"\u003e2006-01-02 15:04:05\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e参考资料：\u003c/strong\u003e\u003c/p\u003e","title":"Jaeger 部署与使用"},{"content":"使用精简的基础镜像 Alpine Alpine一个基于 musl libc 和 busybox、面向安全的轻量级 Linux 发行版，压缩体积只有 3M 左右，很多流行的镜像都有基于 alpine 的制作的基础镜像。\nscratch scratch 是一个空镜像，如果我们的应用是一个不依赖动态链接库的、包含所有依赖的二进制文件，则可以使用 scratch 作为基础镜像，此时镜像的体积差不多就是二进制文件的体积。\nbusybox 如果希望镜像里可以包含一些常用的 Linux 工具，busybox 镜像是个不错选择，它集成了一百多个最常用 Linux 命令和工具的软件工具箱，镜像压缩体积只有不到 1M，非常便于构建小镜像。\ndistroless distroless 镜像仅包含应用程序及其运行时依赖项。不包含包管理器、shell或任何其他程序。\n但因此如果黑客入侵了应用程序并获取了容器的访问权限，也无法造成太大的损害。\n生产环境中也不应该将 Shell附加到容器中进行调试，而应依靠正确的日志收集和监控。\n1FROM node:8 as build 2 3WORKDIR /app 4COPY package.json index.js ./ 5RUN npm install 6 7FROM gcr.io/distroless/nodejs 8 9COPY --from=build /app / 10EXPOSE 3000 11CMD [\u0026#34;index.js\u0026#34;] 清理包管理器缓存 在 Dockerfile 中使用包管理器安装依赖的软件包时，往往会产生一些缓存数据，可以清理掉以减少镜像体积。\nAlpine 如果使用 alpine 基础镜像，可以在用 apk add 安装软件包时加 \u0026ndash;no-cache\n1FROM alpine:latest 2 3RUN apk add --no-cache tzdata ca-certificates Ubuntu/Debian 1FROM ubuntu:latest 2 3RUN apt update -y \u0026amp;\u0026amp; apt install -y curl 4 5RUN apt-get clean autoclean \u0026amp;\u0026amp; \\ 6 apt-get autoremove --yes \u0026amp;\u0026amp; \\ 7 rm -rf /var/lib/{apt,dpkg,cache,log}/ 多阶段构建 Dockerfile 支持多阶段构建，即有多个 FROM 指令，最终构建出的镜像由由最后一个 FROM 之后的指令决定，通常可以把这之前的指令用作编译，之后的指令用作打包，打包阶段可以将编译阶段产生的文件拷贝过来，这样可以实现在最终镜像中只保留运行程序所需要的内容。\n以下例子使用 Golang 静态编译二进制文件，然后 COPY 到 scratch 镜像中。\n1FROM golang:latest AS build 2WORKDIR /workspace 3COPY . . 4# 静态编译二进制 5RUN CGO_ENABLED=0 go build -o app -ldflags \u0026#39;-w -extldflags \u0026#34;-static\u0026#34;\u0026#39; . 6 7FROM scratch 8# 拷贝二进制到空镜像 9COPY --from=build /workspace/app /usr/local/bin/app 10CMD [\u0026#34;app\u0026#34;] 参考资料 https://mp.weixin.qq.com/s/2kZnWXQ260bpyh148Z3W_g ","permalink":"/tech/docker/docker-%E7%B2%BE%E7%AE%80%E9%95%9C%E5%83%8F%E5%AE%9E%E8%B7%B5/","summary":"\u003ch1 id=\"使用精简的基础镜像\"\u003e使用精简的基础镜像\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eAlpine\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAlpine一个基于 musl libc 和 busybox、面向安全的轻量级 Linux 发行版，压缩体积只有 3M 左右，很多流行的镜像都有基于 alpine 的制作的基础镜像。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003escratch\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003escratch 是一个空镜像，如果我们的应用是一个不依赖动态链接库的、包含所有依赖的二进制文件，则可以使用 scratch 作为基础镜像，此时镜像的体积差不多就是二进制文件的体积。\u003c/p\u003e","title":"Docker 精简镜像实践"},{"content":"波特率 Baud Rate 波特率是发送数据位的速度。\nPLC 设备中使用的波特率的常见值包括：1200、9600、19200、38400。\n数据位 Data Bits 数据位是每帧中数据的位数。\nPLC 设备使用的常见值包括 7 或 8 个数据位。\n所有二进制协议都使用 8 个数据位；而ASCII 数据可以使用 7 或 8 位发送，例如 Modbus ASCII。\n停止位 Stop Bits 停止位是用于标记帧结束的位数。 PLC 设备使用的常见值为 1 或 2 个停止位。\n奇偶校验位 Parity 奇偶校验位提供错误检测功能。\nParity Description None No parity bit is added to the data. Even The parity bit is set to space (0) if the total number of data bits in the mark (1) state is even. Odd The parity bit is set to space (0) if the total number of data bits in the mark (1) state is odd. Mark The parity bit is set to mark (1). Space The parity bit is set to space (0). 其中，只有奇偶校验具有一定的错误检测能力。\n电信号 Electrical Signals 有许多串口类型定义了表示标记 (1) 位或空格 (0) 位的电信号：\nStandard Mode Mark Space RS-232 Single Ended -3v to -15v +3v to +15v RS-422 Differential 0v to -6v 0v to +6v RS-485 Differential -0.2v to -6v +0.2v to +6v 单端模式使用单线，测量相对于地的电压。差分模式使用一对电线，其中电压是两条电线之间的差值。\n单端模式可用于长达 15 米的短距离运行。差分模式工作距离可达 1500 米。\n参考资料 https://www.fernhillsoftware.com/help/drivers/serial-communication/index.html#:~:text=Baud%20Rate%20%2D%20the%20speed%20that,the%20end%20of%20a%20frame ","permalink":"/tech/iot/%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/","summary":"\u003ch1 id=\"波特率-baud-rate\"\u003e波特率 Baud Rate\u003c/h1\u003e\n\u003cp\u003e波特率是发送数据位的速度。\u003c/p\u003e\n\u003cp\u003ePLC 设备中使用的波特率的常见值包括：1200、9600、19200、38400。\u003c/p\u003e\n\u003ch1 id=\"数据位-data-bits\"\u003e数据位 Data Bits\u003c/h1\u003e\n\u003cp\u003e数据位是每帧中数据的位数。\u003c/p\u003e\n\u003cp\u003ePLC 设备使用的常见值包括 7 或 8 个数据位。\u003c/p\u003e","title":"常用串口通讯参数解析"},{"content":"问题描述 有 IP 地址为 172.24.x.xx/24 的服务器无法 ping 通，原因为 docker 默认网段 172.17.0.0/16 占用了服务器所在网段，导致外部请求无法访问到真实服务器。\n解决方案 查看路由信息 1ifconfig docker0 2 3docker0: flags=4099\u0026lt;UP,BROADCAST,MULTICAST\u0026gt; mtu 1500 4 inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255 5 ether 02:42:90:e0:c1:a0 txqueuelen 0 (Ethernet) 6 RX packets 0 bytes 0 (0.0 B) 7 RX errors 0 dropped 0 overruns 0 frame 0 8 TX packets 0 bytes 0 (0.0 B) 9 TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 可以看到，docker0 占用的网段为 172.17.0.1/16\n修改 docker 默认网段 1# 停止 docker 服务 2systemctl stop docker 3 4# 删除原有网桥 5ip link del docker0 down 6 7# 修改 docker 网段 8vim /etc/docker/daemon.json 9\u0026#34;bip\u0026#34;:\u0026#34;192.168.100.1/24\u0026#34; 10 11# 重启 docker 服务 12systemctl restart docker 此时再执行 ifconfig docker0 可以看到 docker 的网段已变更。\n参考资料：\nhttps://cloud.tencent.com/developer/article/2242559 ","permalink":"/tech/docker/docker-%E7%BD%91%E6%AE%B5%E4%B8%8E%E4%B8%BB%E6%9C%BA%E7%BD%91%E6%AE%B5%E5%86%B2%E7%AA%81%E5%AF%BC%E8%87%B4%E7%BD%91%E7%BB%9C%E4%B8%AD%E6%96%AD/","summary":"\u003ch2 id=\"问题描述\"\u003e问题描述\u003c/h2\u003e\n\u003cp\u003e有 IP 地址为 \u003ccode\u003e172.24.x.xx/24\u003c/code\u003e 的服务器无法 ping 通，原因为 docker 默认网段 \u003ccode\u003e172.17.0.0/16\u003c/code\u003e 占用了服务器所在网段，导致外部请求无法访问到真实服务器。\u003c/p\u003e\n\u003ch2 id=\"解决方案\"\u003e解决方案\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e查看路由信息\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003eifconfig docker0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003edocker0: \u003cspan class=\"nv\"\u003eflags\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e4099\u0026lt;UP,BROADCAST,MULTICAST\u0026gt;  mtu \u003cspan class=\"m\"\u003e1500\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003e        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e5\u003c/span\u003e\u003cspan class=\"cl\"\u003e        ether 02:42:90:e0:c1:a0  txqueuelen \u003cspan class=\"m\"\u003e0\u003c/span\u003e  \u003cspan class=\"o\"\u003e(\u003c/span\u003eEthernet\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e6\u003c/span\u003e\u003cspan class=\"cl\"\u003e        RX packets \u003cspan class=\"m\"\u003e0\u003c/span\u003e  bytes \u003cspan class=\"m\"\u003e0\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e0.0 B\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e7\u003c/span\u003e\u003cspan class=\"cl\"\u003e        RX errors \u003cspan class=\"m\"\u003e0\u003c/span\u003e  dropped \u003cspan class=\"m\"\u003e0\u003c/span\u003e  overruns \u003cspan class=\"m\"\u003e0\u003c/span\u003e  frame \u003cspan class=\"m\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e8\u003c/span\u003e\u003cspan class=\"cl\"\u003e        TX packets \u003cspan class=\"m\"\u003e0\u003c/span\u003e  bytes \u003cspan class=\"m\"\u003e0\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e0.0 B\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e9\u003c/span\u003e\u003cspan class=\"cl\"\u003e        TX errors \u003cspan class=\"m\"\u003e0\u003c/span\u003e  dropped \u003cspan class=\"m\"\u003e0\u003c/span\u003e overruns \u003cspan class=\"m\"\u003e0\u003c/span\u003e  carrier \u003cspan class=\"m\"\u003e0\u003c/span\u003e  collisions \u003cspan class=\"m\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e可以看到，docker0 占用的网段为 172.17.0.1/16\u003c/p\u003e","title":"Docker 网段与主机网段冲突导致网络中断"},{"content":" 查看网卡配置 1ip a 修改或添加 DNS 服务器 1vim /etc/sysconfig/network-scripts/ifcfg-eth0 1# 添加规则 2DNS1=114.114.114.114 3DNS2=8.8.8.8 重启网络使配置生效 1service network restart ","permalink":"/tech/linux/%E4%BF%AE%E6%94%B9-linux-dns-%E9%85%8D%E7%BD%AE/","summary":"\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e查看网卡配置\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003eip a\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e修改或添加 DNS 服务器\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003evim /etc/sysconfig/network-scripts/ifcfg-eth0\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 添加规则  \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003eDNS1\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e114.114.114.114  \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003eDNS2\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e8.8.8.8\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"3\"\u003e\n\u003cli\u003e\u003cstrong\u003e重启网络使配置生效\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003eservice network restart \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"修改 Linux DNS 配置"},{"content":"操作系统版本 AlmaLinux 9.3\n安装 dnf-utils 1sudo dnf install -y dnf-utils 添加 Docker CE 存储库 1sudo dnf config-manager --add-repo https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo 1yum-config-manager --add-repo https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo 添加过后，执行列出 Alma Linux上可用存储库的列表\n1sudo dnf repolist 把软件仓库地址替换为镜像站 1sed -i \u0026#39;s+https://download.docker.com+https://mirrors.tuna.tsinghua.edu.cn/docker-ce+\u0026#39; /etc/yum.repos.d/docker-ce.repo 安装 Docker CE 1sudo dnf install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 启动并启用 Docker 1sudo systemctl start docker 2sudo systemctl enable docker 配置国内镜像源 1{ 2 \u0026#34;registry-mirrors\u0026#34;: [ 3\t\u0026#34;https://docker.1panel.live\u0026#34; 4 ] 5} 1sudo systemctl daemon-reload 2sudo systemctl restart docker ","permalink":"/tech/docker/docker-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","summary":"\u003cp\u003e操作系统版本 AlmaLinux 9.3\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e安装 \u003ccode\u003ednf-utils\u003c/code\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003esudo dnf install -y dnf-utils\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e添加 Docker CE 存储库\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003esudo dnf config-manager --add-repo https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003eyum-config-manager --add-repo https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e添加过后，执行列出 Alma Linux上可用存储库的列表\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003esudo dnf repolist\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"3\"\u003e\n\u003cli\u003e\u003cstrong\u003e把软件仓库地址替换为镜像站\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003esed -i \u003cspan class=\"s1\"\u003e\u0026#39;s+https://download.docker.com+https://mirrors.tuna.tsinghua.edu.cn/docker-ce+\u0026#39;\u003c/span\u003e /etc/yum.repos.d/docker-ce.repo\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"4\"\u003e\n\u003cli\u003e\u003cstrong\u003e安装 Docker CE\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003esudo dnf install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"5\"\u003e\n\u003cli\u003e\u003cstrong\u003e启动并启用 Docker\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003esudo systemctl start docker\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003esudo systemctl \u003cspan class=\"nb\"\u003eenable\u003c/span\u003e docker\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"6\"\u003e\n\u003cli\u003e\u003cstrong\u003e配置国内镜像源\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"s2\"\u003e\u0026#34;registry-mirrors\u0026#34;\u003c/span\u003e: \u003cspan class=\"o\"\u003e[\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t    \u003cspan class=\"s2\"\u003e\u0026#34;https://docker.1panel.live\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"o\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e5\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003esudo systemctl restart docker\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"Docker 安装与配置"},{"content":"并发过高导致程序崩溃 1func main() { 2\tvar wg sync.WaitGroup 3\tfor i := 0; i \u0026lt; math.MaxInt32; i++ { 4\twg.Add(1) 5\tgo func(i int) { 6\tdefer wg.Done() 7\tfmt.Println(i) 8\ttime.Sleep(time.Second) 9\t}(i) 10\t} 11\twg.Wait() 12} 1goroutine 1489841 [running]: 2internal/poll.(*fdMutex).rwlock(0xc000130060, 0x0?) 3 /usr/local/go/src/internal/poll/fd_mutex.go:147 +0x11b 4internal/poll.(*FD).writeLock(...) 5 /usr/local/go/src/internal/poll/fd_mutex.go:239 6internal/poll.(*FD).Write(0xc000130060, {0xc0ca328a90, 0x8, 0x8}) 7 /usr/local/go/src/internal/poll/fd_unix.go:370 +0x72 8os.(*File).write(...) 9 /usr/local/go/src/os/file_posix.go:48 10os.(*File).Write(0xc00012e008, {0xc0ca328a90?, 0x8, 0xc0cd90b750?}) 11 /usr/local/go/src/os/file.go:175 +0x65 12fmt.Fprintln({0x4b7ff8, 0xc00012e008}, {0xc0cd90b790, 0x1, 0x1}) 13 /usr/local/go/src/fmt/print.go:305 +0x75 14fmt.Println(...) 15 /usr/local/go/src/fmt/print.go:314 16main.main.func1(0x0?) 17 /root/zhuangqf/Blank/cmd/main.go:16 +0x8f 18created by main.main 19 /root/zhuangqf/Blank/cmd/main.go:14 +0x3c 20panic: too many concurrent operations on a single file or socket (max 1048575) 1panic: too many concurrent operations on a single file or socket (max 1048575) 1 个 file/socket 的上并发操作个数超过了上限（1048575），简而言之，系统的资源被耗尽了。0xFFFFF = 1048575\n如果将 fmt.Printf 这行代码去掉，那程序很可能会因为内存不足而崩溃。每个协程至少需要消耗 2KB 的空间，设计算机的内存是 2GB，那么至多允许 2GB/2KB = 1M 个协程同时存在。那如果协程中还存在着其他需要分配内存的操作，那么允许并发执行的协程将会数量级地减少。\n解决方案 推荐解决方案：代码主动限制并发的协程数量。\nchannel 使用 channel 的缓冲区大小作为协程并发上限\n1package main 2 3import ( 4\t\u0026#34;log\u0026#34; 5\t\u0026#34;sync\u0026#34; 6\t\u0026#34;time\u0026#34; 7) 8 9func main() { 10\tvar wg sync.WaitGroup 11\tch := make(chan struct{}, 10) 12 13\tfor i := 0; i \u0026lt; 100; i++ { 14\twg.Add(1) 15\tch \u0026lt;- struct{}{} 16\tgo func(i int) { 17\tdefer wg.Done() 18\tlog.Println(i) 19\ttime.Sleep(time.Second * 2) 20\t\u0026lt;-ch 21\t}(i) 22\t} 23 24\twg.Wait() 25} 其中，\nmake(chan struct{}, 10) 创建缓冲区大小为 3 的 channel，在没有被接收的情况下，至多发送 10 个消息则被阻塞。 开启协程前，调用 ch \u0026lt;- struct{}{}，若缓存区满，则阻塞。 协程任务结束，调用 \u0026lt;-ch 释放缓冲区。 sync.WaitGroup 并不是必须的，例如 http 服务，每个请求天然是并发的，此时使用 channel 控制并发处理的任务数量，就不需要 sync.WaitGroup。 协程池 https://github.com/panjf2000/ants\n样例:\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;sync\u0026#34; 6\t\u0026#34;sync/atomic\u0026#34; 7 8\t\u0026#34;github.com/panjf2000/ants/v2\u0026#34; 9) 10 11var sum int32 12 13func myFunc(i interface{}) { 14\tn := i.(int32) 15\tatomic.AddInt32(\u0026amp;sum, n) 16\tfmt.Printf(\u0026#34;run with %d\\n\u0026#34;, n) 17} 18 19func main() { 20\tdefer ants.Release() 21 22\trunTimes := 1000 23\tvar wg sync.WaitGroup 24\t25\t// Use the pool with a function, 26\t// set 10 to the capacity of goroutine pool and 1 second for expired duration. 27\tp, _ := ants.NewPoolWithFunc(10, func(i interface{}) { 28\tmyFunc(i) 29\twg.Done() 30\t}) 31\tdefer p.Release() 32\t// Submit tasks one by one. 33\tfor i := 0; i \u0026lt; runTimes; i++ { 34\twg.Add(1) 35\t_ = p.Invoke(int32(i)) 36\t} 37\twg.Wait() 38\tfmt.Printf(\u0026#34;running goroutines: %d\\n\u0026#34;, p.Running()) 39\tfmt.Printf(\u0026#34;finish all tasks, result is %d\\n\u0026#34;, sum) 40\tif sum != 499500 { 41\tpanic(\u0026#34;the final result is wrong!!!\u0026#34;) 42\t} 43 44} 上述代码自定义了一个 size 为 10 的线程池，我们只需要往线程池提交任务就可以了。\n","permalink":"/tech/golang/golang-%E6%8E%A7%E5%88%B6%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%95%B0%E9%87%8F/","summary":"\u003ch1 id=\"并发过高导致程序崩溃\"\u003e并发过高导致程序崩溃\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"kd\"\u003evar\u003c/span\u003e \u003cspan class=\"nx\"\u003ewg\u003c/span\u003e \u003cspan class=\"nx\"\u003esync\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eWaitGroup\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"nx\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ei\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"nx\"\u003emath\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eMaxInt32\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nx\"\u003ewg\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eAdd\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 5\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"k\"\u003ego\u003c/span\u003e \u003cspan class=\"kd\"\u003efunc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ei\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"k\"\u003edefer\u003c/span\u003e \u003cspan class=\"nx\"\u003ewg\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eDone\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 7\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"nx\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ePrintln\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 8\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"nx\"\u003etime\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eSleep\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003etime\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eSecond\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 9\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"p\"\u003e}(\u003c/span\u003e\u003cspan class=\"nx\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e10\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e11\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003ewg\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWait\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e12\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 1\u003c/span\u003e\u003cspan class=\"cl\"\u003egoroutine 1489841 [running]:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 2\u003c/span\u003e\u003cspan class=\"cl\"\u003einternal/poll.(*fdMutex).rwlock(0xc000130060, 0x0?)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 3\u003c/span\u003e\u003cspan class=\"cl\"\u003e        /usr/local/go/src/internal/poll/fd_mutex.go:147 +0x11b\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 4\u003c/span\u003e\u003cspan class=\"cl\"\u003einternal/poll.(*FD).writeLock(...)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 5\u003c/span\u003e\u003cspan class=\"cl\"\u003e        /usr/local/go/src/internal/poll/fd_mutex.go:239\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 6\u003c/span\u003e\u003cspan class=\"cl\"\u003einternal/poll.(*FD).Write(0xc000130060, {0xc0ca328a90, 0x8, 0x8})\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 7\u003c/span\u003e\u003cspan class=\"cl\"\u003e        /usr/local/go/src/internal/poll/fd_unix.go:370 +0x72\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 8\u003c/span\u003e\u003cspan class=\"cl\"\u003eos.(*File).write(...)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 9\u003c/span\u003e\u003cspan class=\"cl\"\u003e        /usr/local/go/src/os/file_posix.go:48\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e10\u003c/span\u003e\u003cspan class=\"cl\"\u003eos.(*File).Write(0xc00012e008, {0xc0ca328a90?, 0x8, 0xc0cd90b750?})\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e11\u003c/span\u003e\u003cspan class=\"cl\"\u003e        /usr/local/go/src/os/file.go:175 +0x65\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e12\u003c/span\u003e\u003cspan class=\"cl\"\u003efmt.Fprintln({0x4b7ff8, 0xc00012e008}, {0xc0cd90b790, 0x1, 0x1})\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e13\u003c/span\u003e\u003cspan class=\"cl\"\u003e        /usr/local/go/src/fmt/print.go:305 +0x75\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e14\u003c/span\u003e\u003cspan class=\"cl\"\u003efmt.Println(...)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e15\u003c/span\u003e\u003cspan class=\"cl\"\u003e        /usr/local/go/src/fmt/print.go:314\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e16\u003c/span\u003e\u003cspan class=\"cl\"\u003emain.main.func1(0x0?)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e17\u003c/span\u003e\u003cspan class=\"cl\"\u003e        /root/zhuangqf/Blank/cmd/main.go:16 +0x8f\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e18\u003c/span\u003e\u003cspan class=\"cl\"\u003ecreated by main.main\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e19\u003c/span\u003e\u003cspan class=\"cl\"\u003e        /root/zhuangqf/Blank/cmd/main.go:14 +0x3c\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e20\u003c/span\u003e\u003cspan class=\"cl\"\u003epanic: too many concurrent operations on a single file or socket (max 1048575)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003epanic: too many concurrent operations on a single file or socket (max 1048575)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e1 个 file/socket 的上并发操作个数超过了上限（1048575），简而言之，系统的资源被耗尽了。0xFFFFF = 1048575\u003c/p\u003e","title":"Golang 控制协程并发数量"},{"content":"1. future/promise 1.1 单向接收 Channel 作为函数返回 sumSquares函数调用的两个实参请求并发进行。每个通道读取操作将阻塞到请求返回结果为止。\n1func longTimeRequest() \u0026lt;-chan int64 { 2\tr := make(chan int64) 3 4\tgo func() { 5\ttime.Sleep(time.Second * 3) // 模拟一个工作负载 6\tr \u0026lt;- rand.Int63n(100) 7\t}() 8 9\treturn r 10} 11 12func sumSquares(a, b int64) int64 { 13\treturn a*a + b*b 14} 15 16func main() { 17 18\ta, b := longTimeRequest(), longTimeRequest() 19\tfmt.Println(sumSquares(\u0026lt;-a, \u0026lt;-b)) 20} 1.2 单向发送 Channel 作为函数实参 sumSquares函数调用的两个实参的请求也是并发进行的。和上例不同的是longTimeRequest函数接收一个单向发送通道类型参数而不是返回一个单向接收通道结果。\n1func longTimeRequest(r chan\u0026lt;- int64) { 2\ttime.Sleep(time.Second * 3) // 模拟一个工作负载 3\tr \u0026lt;- rand.Int63n(100) 4} 5 6func sumSquares(a, b int64) int64 { 7\treturn a*a + b*b 8} 9 10func main() { 11 12\tra, rb := make(chan int64), make(chan int64) 13\tgo longTimeRequest(ra) 14\tgo longTimeRequest(rb) 15 16\tfmt.Println(sumSquares(\u0026lt;-ra, \u0026lt;-rb)) 17} 特别的，我们也可以只使用一个通道来接收回应结果，因为两个参数的作用是对等的。\n1... 2\tresults := make(chan int32, 2) // 缓冲与否不重要 3\tgo longTimeRequest(results) 4\tgo longTimeRequest(results) 5 6\tfmt.Println(sumSquares(\u0026lt;-results, \u0026lt;-results)) 7} 1.3 采用最快回应 本例是上例中只使用一个通道变种的增强。\n有时候，一份数据可能同时从多个数据源获取，这些数据源将返回相同的数据，因为各种因素，这些数据源的回应速度参差不一，甚至某个特定数据源的多次回应速度之间也可能相差很大。\n同时从多个数据源获取一份相同的数据可以有效保障低延迟。我们只需采用最快的回应并舍弃其它较慢回应。\n若有 N 个数据源，为了防止被舍弃的回应对应的协程永久阻塞，则传输数据用的通道必须为一个容量至少为 N-1 的缓冲通道。\n1func source(c chan\u0026lt;- int32) { 2\tra, rb := rand.Int31(), rand.Intn(3)+1 3\t// 随机睡眠1-3秒 4\ttime.Sleep(time.Duration(rb) * time.Second) 5\tc \u0026lt;- ra 6} 7 8func main() { 9\tstartTime := time.Now() 10\tc := make(chan int32, 5) // 必须用一个缓冲通道 11\tfor i := 0; i \u0026lt; cap(c); i++ { 12\tgo source(c) 13\t} 14\trnd := \u0026lt;-c // 只有第一个回应被使用了 15\tfmt.Println(time.Since(startTime)) 16\tfmt.Println(rnd) 17\t// 1.000202388s 18\t// 839171462 19} 2. 通知 通知，是一种特殊的请求/回应用例。\n在一个通知用例中，我们并不关心回应的值，我们只关心是否回应。因此，空结构体类型 struct{} 常被做为通道的元素类型，因为空结构体类型的尺寸为零，有效节省内存。\n2.1 单对单通知 如果一个通道中无值可接收，则此通道上的下一个接收操作将阻塞，直到另一个协程发送值到此通道为止。\n所以，一个协程可以向此通道发送一个值来通知另一个等待着从此通道接收数据的协程。\n在下面这个例子中，通道done被用来做为一个信号通道来实现单对单通知。\n1func main() { 2\tvalues := make([]byte, 32*1024*1024) 3\tif _, err := rand.Read(values); err != nil { 4\tfmt.Println(err) 5\tos.Exit(1) 6\t} 7 8\tdone := make(chan struct{}) // 也可以是缓冲的 9 10\t// 排序协程 11\tgo func() { 12\tsort.Slice(values, func(i, j int) bool { 13\treturn values[i] \u0026lt; values[j] 14\t}) 15\tdone \u0026lt;- struct{}{} // 通知排序已完成 16\t}() 17 18\t// 并发地做一些其它事情... 19 20\t\u0026lt;-done // 等待通知 21\tfmt.Println(values[0], values[len(values)-1]) 22} 2.2 多对单通知 在实践中，常使用 sync.WaitGroup 来实现多对单通知\n2.3 单对多/多对多通知 从一个已关闭的通道可以接收到无穷个值，我们可以利用这一特性，来使用关闭一个通道的方式实现单对多通知群发通知。\n以下代码展示了多对多和单对多的通知。\n1 2var wg sync.WaitGroup 3 4func worker(id int, ready \u0026lt;-chan struct{}) { 5\t\u0026lt;-ready // 阻塞在此，等待通知 6\tlog.Print(\u0026#34;Worker#\u0026#34;, id, \u0026#34;开始工作\u0026#34;) 7\ttime.Sleep(time.Second * time.Duration(id+1)) 8\tlog.Print(\u0026#34;Worker#\u0026#34;, id, \u0026#34;工作完成\u0026#34;) 9\twg.Done() 10} 11 12func main() { 13\tlog.SetFlags(0) 14 15\tready := make(chan struct{}) 16\tfor i := 0; i \u0026lt;= 2; i++ { 17\twg.Add(1) 18\tgo worker(i, ready) 19\t} 20 21\t// 模拟初始化过程 22\ttime.Sleep(time.Second * 3) 23 24\t// 单对多通知 25\tclose(ready) 26 27\t// 等待被多对单通知 28\twg.Wait() 29} 3. 限制协程并发数量 1func main() { 2\tvar wg sync.WaitGroup 3\tch := make(chan struct{}, 10) 4 5\tfor i := 0; i \u0026lt; 100; i++ { 6\twg.Add(1) 7\tch \u0026lt;- struct{}{} 8\tgo func(i int) { 9\tdefer wg.Done() 10\tlog.Println(i) 11\ttime.Sleep(time.Second * 2) 12\t\u0026lt;-ch 13\t}(i) 14\t} 15 16\twg.Wait() 17} 4. 使用 Channel 传送 Channel 一个通道类型的元素类型可以是另一个通道类型。\n在下面这个例子中， 单向发送通道类型chan\u0026lt;- int是另一个通道类型chan chan\u0026lt;- int的元素类型。\n1var counter = func(n int) chan\u0026lt;- chan\u0026lt;- int { 2\trequests := make(chan chan\u0026lt;- int) 3\tgo func() { 4\tfor request := range requests { 5\tif request == nil { 6\tn++ // 递增计数 7\t} else { 8\trequest \u0026lt;- n // 返回当前计数 9\t} 10\t} 11\t}() 12\treturn requests // 隐式转换到类型chan\u0026lt;- (chan\u0026lt;- int) 13}(0) 14 15func main() { 16\tincrease1000 := func(done chan\u0026lt;- struct{}) { 17\tfor i := 0; i \u0026lt; 1000; i++ { 18\tcounter \u0026lt;- nil 19\t} 20\tdone \u0026lt;- struct{}{} 21\t} 22 23\tdone := make(chan struct{}) 24\tgo increase1000(done) 25\tgo increase1000(done) 26\t\u0026lt;-done 27\t\u0026lt;-done 28 29\trequest := make(chan int, 1) 30\tcounter \u0026lt;- request 31\tfmt.Println(\u0026lt;-request) // 2000 32} 5. 使当前协程永久阻塞 一个无分支的 select 流程控制代码块使当前协程永久处于阻塞状态。这是select流程控制的最简单的应用。一般，select{}用在主协程中以防止程序退出。\n1func DoSomething() { 2\tfor { 3\t// 做点什么... 4\tfmt.Println(rand.Int31()) 5\ttime.Sleep(time.Second) 6\truntime.Gosched() // 防止本协程霸占CPU不放 7\t} 8} 9 10func main() { 11\tgo DoSomething() 12\tgo DoSomething() 13\tselect {} 14} 6. 尝试发送与接收 含有一个default分支和一个case分支的select代码块可以被用做一个尝试发送或者尝试接收操作，取决于case关键字后跟随的是一个发送操作还是一个接收操作。\n如果case关键字后跟随的是一个发送操作，则此select代码块为一个尝试发送操作。 如果case分支的发送操作是阻塞的，则default分支将被执行，发送失败；否则发送成功，case分支得到执行。 如果case关键字后跟随的是一个接收操作，则此select代码块为一个尝试接收操作。 如果case分支的接收操作是阻塞的，则default分支将被执行，接收失败；否则接收成功，case分支得到执行。 尝试发送和尝试接收代码块永不阻塞。\n标准编译器对尝试发送和尝试接收代码块做了特别的优化，使得它们的执行效率比多case分支的普通select代码块执行效率高得多。\n1type Book struct { 2\tid int 3} 4 5func main() { 6 7\tbookshelf := make(chan Book, 3) 8 9\tfor i := 0; i \u0026lt; cap(bookshelf)*2; i++ { 10\tselect { 11\tcase bookshelf \u0026lt;- Book{id: i}: 12\tfmt.Println(\u0026#34;成功将书放在书架上\u0026#34;, i) 13\tdefault: 14\tfmt.Println(\u0026#34;书架已经被占满了\u0026#34;) 15\t} 16\t} 17 18\tfor i := 0; i \u0026lt; cap(bookshelf)*2; i++ { 19\tselect { 20\tcase book := \u0026lt;-bookshelf: 21\tfmt.Println(\u0026#34;成功从书架上取下一本书\u0026#34;, book.id) 22\tdefault: 23\tfmt.Println(\u0026#34;书架上已经没有书了\u0026#34;) 24\t} 25\t} 26 27} 7. 无阻塞地检查 Channel 是否已经关闭 假设，我们可以保证没有任何协程会向一个通道发送数据，则我们可以使用下面的代码来（并发安全地）检查此通道是否已经关闭，此检查不会阻塞当前协程。\n1func IsClosed(c chan T) bool { 2\tselect { 3\tcase \u0026lt;-c: 4\treturn true 5\tdefault: 6\t} 7\treturn false 8} 此方法常用来查看某个期待中的通知是否已经来临。此通知将由另一个协程通过关闭一个通道来发送。\n8. 超时机制（timeout） 在一些请求/回应用例中，一个请求可能因为种种原因导致需要超出预期的时长才能得到回应，有时甚至永远得不到回应。 对于这样的情形，我们可以使用一个超时方案给请求者返回一个错误信息。使用 select 可以很轻松地实现这样的一个超时方案。\n1func requestWithTimeout(timeout time.Duration) (int, error) { 2\tc := make(chan int) 3\tgo doRequest(c) // 可能需要超出预期的时长回应 4 5\tselect { 6\tcase data := \u0026lt;-c: 7\treturn data, nil 8\tcase \u0026lt;-time.After(timeout): 9\treturn 0, errors.New(\u0026#34;超时了！\u0026#34;) 10\t} 11} 8.1 速率限制 速率限制常用来限制吞吐和确保在一段时间内的资源使用不会超标。\n下面的例子中，任何一分钟时段内处理的请求数不会超过200。\n也就是漏桶算法，但漏桶算法无法处理峰值情况。\n1type Request interface{} 2 3func handle(r Request) { 4\tfmt.Println(r.(int)) 5} 6 7const RateLimitPeriod = time.Minute 8const RateLimit = 5 // 任何一分钟内最多处理200个请求 9 10func handleRequests(requests \u0026lt;-chan Request) { 11\tquotas := make(chan time.Time, RateLimit) 12 13\tgo func() { 14\ttick := time.NewTicker(RateLimitPeriod / RateLimit) 15\tdefer tick.Stop() 16\tfor t := range tick.C { 17\tselect { 18\tcase quotas \u0026lt;- t: 19\tdefault: 20\t} 21\t} 22\t}() 23 24\tfor r := range requests { 25\t\u0026lt;-quotas 26\tgo handle(r) 27\t} 28} 29 30func main() { 31\trequests := make(chan Request) 32\tgo handleRequests(requests) 33\t// time.Sleep(time.Minute) 34\tfor i := 0; ; i++ { 35\trequests \u0026lt;- i 36\t} 37} ","permalink":"/tech/golang/golang-channel-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","summary":"\u003ch1 id=\"1-futurepromise\"\u003e1. future/promise\u003c/h1\u003e\n\u003ch2 id=\"11-单向接收-channel-作为函数返回\"\u003e1.1 单向接收 Channel 作为函数返回\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003esumSquares\u003c/code\u003e函数调用的两个实参请求并发进行。每个通道读取操作将阻塞到请求返回结果为止。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"nf\"\u003elongTimeRequest\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;-\u003c/span\u003e\u003cspan class=\"kd\"\u003echan\u003c/span\u003e \u003cspan class=\"kt\"\u003eint64\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003er\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"nb\"\u003emake\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kd\"\u003echan\u003c/span\u003e \u003cspan class=\"kt\"\u003eint64\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003ego\u003c/span\u003e \u003cspan class=\"kd\"\u003efunc\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 5\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nx\"\u003etime\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eSleep\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003etime\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eSecond\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 模拟一个工作负载\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\t\u003cspan class=\"nx\"\u003er\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;-\u003c/span\u003e \u003cspan class=\"nx\"\u003erand\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eInt63n\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e100\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 7\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e}()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 8\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 9\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003er\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e10\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e11\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e12\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"nf\"\u003esumSquares\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eb\u003c/span\u003e \u003cspan class=\"kt\"\u003eint64\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"kt\"\u003eint64\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e13\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003ea\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nx\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"nx\"\u003eb\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nx\"\u003eb\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e14\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e15\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e16\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e17\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e18\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eb\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"nf\"\u003elongTimeRequest\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"nf\"\u003elongTimeRequest\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e19\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ePrintln\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nf\"\u003esumSquares\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;-\u003c/span\u003e\u003cspan class=\"nx\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;-\u003c/span\u003e\u003cspan class=\"nx\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e20\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"12-单向发送-channel-作为函数实参\"\u003e1.2 单向发送 Channel 作为函数实参\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003esumSquares\u003c/code\u003e函数调用的两个实参的请求也是并发进行的。和上例不同的是\u003ccode\u003elongTimeRequest\u003c/code\u003e函数接收一个单向发送通道类型参数而不是返回一个单向接收通道结果。\u003c/p\u003e","title":"Golang Channel 使用场景"},{"content":"参考资料：\nhttps://go.dev/wiki/CodeReviewComments https://go.dev/wiki/CommonMistakes Review Comments 使用 gofmt 或者 goimports 自动格式化代码 记录声明的注释应该是完整的句子，注释应以所描述事物的名称开头并以句点结束。 1// Request represents a request to run a command. 2type Request struct { ... 3 4// Encode writes the JSON encoding of req to w. 5func Encode(w io.Writer, req *Request) { ... context.Context 类型的值携带跨 API 和进程边界的安全凭证、跟踪信息、截止日期和取消信号。Go 程序沿着从传入 RPC 和 HTTP 请求到传出请求的整个函数调用链显式传递上下文。大多数使用 Context 的函数都将它作为第一个参数： 1func F(ctx context.Context, /* other arguments */) {} 注意，不要将 Context 成员添加到结构类型中；而是向需要传递该类型的每个方法添加一个 ctx 参数。\n避免使用 math/rand 生成密钥。首先，如果不加种子，秘钥结果完全可以预测，即使使用 time.Nanoseconds() 作为种子，生成的秘钥也只有几位不同。推荐使用 crypto/rand 包中的 Read() 生成秘钥。 1import ( 2 \u0026#34;crypto/rand\u0026#34; 3 // \u0026#34;encoding/base64\u0026#34; 4 // \u0026#34;encoding/hex\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8func Key() string { 9 buf := make([]byte, 16) 10 _, err := rand.Read(buf) 11 if err != nil { 12 panic(err) // out of randomness, should never happen 13 } 14 return fmt.Sprintf(\u0026#34;%x\u0026#34;, buf) 15 // or hex.EncodeToString(buf) 16 // or base64.StdEncoding.EncodeToString(buf) 17} 以下两种声明切片的方式，前者声明了一个 nil 切片，而后者声明了空切片，两者的 len() 和 cap() 都为 0，通常情况下 nil 切片更好， nil 切片底层指针地址为 0 。 1var t []string 1t := []string{} 2t := make([]string, 0) 例外，在编码 JSON 对象时，推荐使用非 nil 但零长度的切片 ，nil 切片会被编码为 null，而 []string{} 会被编码为 JSON 数组 []。\n不要使用 panic 进行的错误处理， 而是使用 error 和多返回值。 生成协程时，请明确该协程是否结束、何时结束。 Goroutine 可能会因阻塞通道发送或接收而发生泄漏：即使阻塞的通道无法访问，GC 也不会终止 Goroutine。 除非出现重名情况，否则避免重命名 import。 大部分情况下的包名称不需要重命名，如果发生冲突，最好重命名本地或特定项目的 import 。 尽量使正常的代码路径保持最小的缩进，并缩进错误处理。例如： 不推荐：\n1if err != nil { 2 // error handling 3} else { 4 // normal code 5} 推荐：\n1if err != nil { 2 // error handling 3 return // or continue, etc. 4} 5// normal code 首字母缩写词，具有一致的大小写。 例如，\u0026ldquo;URL\u0026rdquo; 应写为\u0026quot;URL\u0026quot;或\u0026quot;url\u0026quot;，而不是\u0026quot;Url\u0026quot;；使用 \u0026ldquo;ServeHTTP\u0026rdquo; 而不是 \u0026ldquo;ServeHttp\u0026rdquo;；使用 \u0026ldquo;xmlHTTPRequest\u0026rdquo; 或\u0026quot;XMLHTTPRequest\u0026quot;；使用 \u0026ldquo;appID\u0026rdquo; 而不是 \u0026ldquo;appId\u0026rdquo;。由 protocol buffer 生成的代码不受此规则的约束。人类编写的代码比机器编写的代码具有更高的标准。\n根据实际情况确定函数返回格式。 例如当函数返回相同类型的 2 个或 3 个参数，或者返回值的含义较难区分，那么推荐在函数返回格式前添加变量名称。\n不推荐：\n1func (f *Foo) Location() (float64, float64, error) 推荐：\n1// Location returns f\u0026#39;s latitude and longitude. 2// Negative values mean south and west, respectively. 3func (f *Foo) Location() (lat, long float64, err error) 避免仅仅为了节省几个字节而将指针作为函数参数传递。 如果一个函数自始至终，仅将其参数 x 引用为 *x，那这个传入的参数不应该是指针而是值。将指针作为参数的情况例如：传递指向字符串的指针 *string 或指向接口值的指针 *io.Reader，这两个例子中，指针所指向的值本身是固定大小的，因此可以直接传递。但不适用于指针指向大型结构体，包括不适用于可能增长的小型结构体。\n方法接收器的命名应简短并保持一致：通常用 1 到 2 个字母缩写其类型（\u0026ldquo;client\u0026quot;缩写为\u0026quot;c\u0026quot;或\u0026quot;cl\u0026rdquo;）。不要使用通用名称，如 \u0026ldquo;me\u0026rdquo;、\u0026ldquo;this \u0026ldquo;或 \u0026ldquo;self\u0026rdquo;，这些面向对象语言的典型标识符会赋予方法特殊的含义，而在 Go 中，方法的接收器只是另一个参数。\n通常使用指针接收器，对于基本类型的值或者确定不变的小型结构体可以使用值接收器。\n如果接收者是一个map、func 或 chan，不要使用指向它们的指针；如果接收者是一个 slice 并且该方法不会重新切片或重新分配该 slice，则不要使用指向它的指针。 如果该方法需要改变接收者，则接收者必须是指针。 如果接收者是包含sync.Mutex或类似同步字段的结构，则接收者必须是指针，以避免复制。 如果接收器是大型结构体或数组，则指针接收器效率更高。 相比异步函数，推荐使用同步函数。 同步函数更容易推断函数中协程的生命周期，避免泄漏和数据竞争，也更易于测试：调用者可以传递输入并检查输出，而无需轮询或同步。 Common Mistakes 使用循环变量的引用 Go语言中，循环变量只是一个变量，在每次循环过程中被赋予不同的值。但如果使用不当可能会出现问题。\n1func main() { 2\tvar out []*int 3\tfor i := 0; i \u0026lt; 3; i++ { 4\tout = append(out, \u0026amp;i) 5\t} 6\tfmt.Println(\u0026#34;Values:\u0026#34;, *out[0], *out[1], *out[2]) 7\tfmt.Println(\u0026#34;Addresses:\u0026#34;, out[0], out[1], out[2]) 8} 输出结果为：\n1Values: 3 3 3 2Addresses: 0xc0000a0000 0xc0000a0000 0xc0000a0000 原因： 每次循环，Golang 将 i 的地址追加到切片 out 中，但自始至终只有一个 i ，所以循环结束后 i 上的值为最后一次循环赋给 i 的值。\n解决方法： 将循环变量赋值到新变量中。\n1for i := 0; i \u0026lt; 3; i++ { 2\ti := i 3\tout = append(out, \u0026amp;i) 4\t} 输出结果为：\n1Values: 0 1 2 2Addresses: 0xc00001a0b8 0xc00001a0c0 0xc00001a0c8 原因： i := i 将循环变量 i 复制到一个新变量中，该新变量的作用域为 for 循环主体块，也称为 i。每次循环迭代中都会创建这样一个新变量。\n虽然这个例子看起来有点明显，但在其他一些情况下，同样的意外行为可能会更加隐蔽。例如，循环变量可以是数组，而引用可以是片段：\n上述样例较为明显，实际情况下这种错误可能更加隐蔽，例如，循环变量为数组，其引用为切片。\n1func main() { 2\tvar out [][]int 3\tfor _, i := range [][1]int{{1}, {2}, {3}} { 4\tout = append(out, i[:]) 5\t} 6\tfmt.Println(\u0026#34;Values:\u0026#34;, out) 7} 输出结果为：\n1Values: [[3] [3] [3]] 当在 Goroutine 中使用循环变量时，也会出现同样的问题（下一节）。\n在循环变量上使用 goroutines 在 Go 中使用循环时，我们会尝试使用 goroutine 并行处理数据。例如可以使用闭包：\n1func main() { 2\tvalues := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} 3\tfor _, val := range values { 4\tgo func() { 5\tfmt.Println(val) 6\t}() 7\t} 8 9\t// wait 10 second 10\ttime.Sleep(10 * time.Second) 11} 上述代码不会按顺序打印的每个值，因为所有闭包函数都绑定了同一个变量，运行此代码时，因为 goroutine 可能要等到循环结束后才会开始执行，所以只会打印最后一个元素10。\n1$ go run test.go 210 310 410 510 610 710 810 910 1010 1110 编写闭包循环的正确方式是：\n1func main() { 2\tvalues := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} 3\tfor _, val := range values { 4\tgo func(v int) { 5\tfmt.Println(v) 6\t}(val) 7\t} 8 9\t// wait for goroutines to finish 10\tvar input string 11\tfmt.Scanln(\u0026amp;input) 12 13} 将 val 作为参数添加到闭包中，每次迭代时对 val 进行求值，并将其置于 goroutine 的堆栈中，因此每个切片元素在最终执行时可供 goroutine 使用。\n1$ go run test.go 24 31 42 53 67 75 86 98 109 1110 下列代码使用公共索引变量 i 创建单独的 val，也可以产生我们想要的结果：\n1func main() { 2\tvalues := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} 3\tfor i := range values { 4\tval := values[i] 5\tgo func() { 6\tfmt.Println(val) 7\t}() 8\t} 9 10\t// wait for goroutines to finish 11\tvar input string 12\tfmt.Scanln(\u0026amp;input) 13 14} 14 21 32 43 57 65 76 88 99 1010 注意，如果不将此闭包作为 goroutine 执行，代码将按预期运行。以下示例打印 1 到 10 之间的整数。\n1for i := 1; i \u0026lt;= 10; i++ { 2\tfunc() { 3\tfmt.Println(i) 4\t}() 5} 11 22 33 44 55 66 77 88 99 1010 其中，闭包函数会在变量i更改之前执行完毕，因此最终按顺序输出1到10。 https://go.dev/doc/faq#closures_and_goroutines\n","permalink":"/tech/golang/golang-code-review-comments/","summary":"\u003cp\u003e\u003cstrong\u003e参考资料：\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://go.dev/wiki/CodeReviewComments\"\u003ehttps://go.dev/wiki/CodeReviewComments\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://go.dev/wiki/CommonMistakes\"\u003ehttps://go.dev/wiki/CommonMistakes\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch1 id=\"review-comments\"\u003eReview Comments\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e使用 \u003cstrong\u003egofmt\u003c/strong\u003e 或者  goimports 自动格式化代码\u003c/li\u003e\n\u003cli\u003e记录声明的\u003cstrong\u003e注释应该是完整的句子\u003c/strong\u003e，注释应以所描述事物的名称开头并以句点结束。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-gdscript3\" data-lang=\"gdscript3\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e//\u003c/span\u003e \u003cspan class=\"n\"\u003eRequest\u003c/span\u003e \u003cspan class=\"n\"\u003erepresents\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"n\"\u003erequest\u003c/span\u003e \u003cspan class=\"n\"\u003eto\u003c/span\u003e \u003cspan class=\"n\"\u003erun\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"n\"\u003ecommand\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003etype\u003c/span\u003e \u003cspan class=\"n\"\u003eRequest\u003c/span\u003e \u003cspan class=\"n\"\u003estruct\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e//\u003c/span\u003e \u003cspan class=\"n\"\u003eEncode\u003c/span\u003e \u003cspan class=\"n\"\u003ewrites\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e \u003cspan class=\"n\"\u003eJSON\u003c/span\u003e \u003cspan class=\"n\"\u003eencoding\u003c/span\u003e \u003cspan class=\"n\"\u003eof\u003c/span\u003e \u003cspan class=\"n\"\u003ereq\u003c/span\u003e \u003cspan class=\"n\"\u003eto\u003c/span\u003e \u003cspan class=\"n\"\u003ew\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e5\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efunc\u003c/span\u003e \u003cspan class=\"n\"\u003eEncode\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ew\u003c/span\u003e \u003cspan class=\"n\"\u003eio\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eWriter\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ereq\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eRequest\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"3\"\u003e\n\u003cli\u003econtext.Context 类型的值携带跨 API 和进程边界的安全凭证、跟踪信息、截止日期和取消信号。Go 程序沿着从传入 RPC 和 HTTP 请求到传出请求的整个函数调用链显式传递上下文。\u003cstrong\u003e大多数使用 Context 的函数都将它作为第一个参数\u003c/strong\u003e：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"nf\"\u003eF\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ectx\u003c/span\u003e \u003cspan class=\"nx\"\u003econtext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eContext\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* other arguments */\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e注意，不要将 Context 成员添加到结构类型中；而是向需要传递该类型的每个方法添加一个 ctx 参数。\u003c/p\u003e","title":"Golang Code Review Comments"},{"content":"1. panic 与 error 1.1 panic panic 会中止程序执行进入异常处理逻辑，panic可以在当前函数或者调用链向上的任何一层被defer recover 捕获处理，没被捕获的panic会使程序打印堆栈后异常退出。\npanic很少在代码中出现，一般用来表示除0、内存不足、强制类型转换失败等语言层级的异常，如果出现意味着程序员本身的实现问题，所以程序员一般不会着重考虑和防御它们。\n1.2 error error会显得更平凡，所有满足error这个interface的值都可以当做一个合法的错误：\n1type error interface { 2 // 输出对该错误的文本描述 3 Error() string 4} 在Go语言中，error是一个值，运行时不会用特殊的逻辑对待它，不处理它不会让程序打印堆栈异常退出。\nerror会在代码中大量出现，表示连接超时、JSON解析失败、文件不存在等用户层级的错误，往往和业务直接相关，程序需要着重考虑它们。\n1.3 总结 panic：不着重考虑，没有明确的抛出位置； error：着重考虑，抛出位置固定而明显，只要函数返回值元组中最后一个是error类型，用户就需要考虑防御和处理。 换句话说，Go语言中error是值这个特征在鼓励用户考虑和处理每个错误，写出鲁棒的程序。\n2. “好”的错误 例如，有个天气API服务，它在收到请求时会先查询Redis中有没有对应缓存，如果没有缓存再请求外部服务，最后返回结果给调用方。\n有一天，调用方说接口不工作了，你查了日志，错误信息是 context deadline exceeded，这个错误意味着代码里有地方发生了超时，可是在哪里呢？是缓存还是外部API？\n好的错误是有根本原因和调用链上下文的错误，这样的错误容易排查，如果你看到的错误信息是这样的：\n1reading cache: redis GET: context deadline exceeded 或者带有调用堆栈的：\n1context deadline exceeded 2goroutine 1 [running]: 3main.Example(0x19010001) 4 /Users/hello/main.go 5 temp/main.go:8 +0x64 6main.main() 7 /Users/bill/main.go 8 temp/main.go:4 +0x32 那么排错工作都会容易得多。\n比起堆栈，人工添加的文本错误上下文更易于阅读，有着更高的信息密度，而且看到的人就算没有接触相关代码也有可能理解错误原因。\n3. 为错误提供文本上下文 Go 1.13中新增了fmt.Errorf()用于为错误提供上下文，errors标准库新增Is(), As(), Unwrap()用于便利化错误的鉴别和比较。\nfmt.Errorf()的用法如下：\n1reading cache: redis GET: context deadline exceeded 这个错误信息从左到右层层递进，每层fmt.Errorf()叙述自己想要做的事情，然后用:分隔下一层，下一层用%w指代。\n下面这段伪代码中，FindWeather()调用ReadCache()，请试想ReadCache()报错时，FindWeather()调用者收到的错误：\n1func FindWeather(city string) (weather string, err error) { 2\tweather, err = ReadCache(city) 3\tif err != nil { 4\terr = fmt.Errorf(\u0026#34;reading cache: %w\u0026#34;, err) 5\treturn 6\t} 7\t8\tif weather != \u0026#34;\u0026#34; { 9\t// cache hit 10\treturn 11\t} 12\t13\t// cache missed, query for data source and update cache 14\t// ... 15} 16 17func ReadCache(city string) (weather string, err error) { 18\tcacheKey := \u0026#34;city-\u0026#34; + city 19\tweather, err = cache.Get(cacheKey) 20\tif err == redis.Nil { 21\t// cache missed 22\terr = nil 23\treturn 24\t} else if err != nil { 25\terr = fmt.Errorf(\u0026#34;redis Get: %w\u0026#34;, err) 26\treturn 27\t} 28\t29\treturn 30} Go语言的静态分析工具能检查出代码中忘记处理的错误，不规范的错误上下文格式等（%d,%f, %v, %w, %x分不清），一般使用它们的合集版本golangci-lint.\n3.1 其他为错误添加上下文的方式 如果有必要，也可以使用其他为错误添加上下文的方案\n使用pkg/errors为错误添加堆栈； 如果是HTTP服务，使用panic和recover中间件，知乎的实现就是个例子，我猜想上下文也是以堆栈的方式呈现。 参考资料 https://nanmu.me/zh-cn/posts/2021/error-handling-in-go/ https://go.dev/blog/defer-panic-and-recover https://go.dev/blog/errors-are-values ","permalink":"/tech/golang/golang-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/","summary":"\u003ch1 id=\"1-panic-与-error\"\u003e1. panic 与 error\u003c/h1\u003e\n\u003ch2 id=\"11-panic\"\u003e1.1 panic\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003epanic 会中止程序执行进入异常处理逻辑\u003c/strong\u003e，panic可以在当前函数或者调用链向上的任何一层被defer recover 捕获处理，没被捕获的panic会使程序打印堆栈后异常退出。\u003c/p\u003e","title":"Golang 错误处理"}]