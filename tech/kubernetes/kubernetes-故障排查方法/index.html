<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Kubernetes 故障排查方法论 | xgbt&#39;s Blog</title>
<meta name="keywords" content="Kubernetes">
<meta name="description" content="问题导向&amp;排查
网络诊断

连通性测试：使用 ping、nc、telnet 等工具测试 Pod 间的网络连通性，或通过 curl 检查服务端口是否可达。
NetworkPolicy 检查：确认 NetworkPolicy 规则是否过于严格导致通信阻断，使用 kubectl get netpol 查看并分析现有策略。
CNI 插件排查：检查 CNI 插件（如 Calico、Flannel 等）的日志，排查网络配置或插件自身问题。

存储问题排查

PVC/PV 状态检查：使用 kubectl get pvc,pv 查看 PersistentVolumeClaim 和 PersistentVolume 的绑定状态与容量，确认是否存在未绑定、容量不足等问题。
存储日志与事件：检查存储插件（如 Local Volume、CSI Driver 等）日志，以及 PVC/PV 的事件信息，查找存储访问异常。
数据完整性验证：必要时，直接在宿主机上挂载存储卷，检查数据完整性和一致性。

资源调度与亲和性问题

节点资源分析：使用 kubectl top nodes 查看节点资源使用情况，判断是否存在资源瓶颈。
调度策略检查：确认 Deployments、StatefulSets 等资源的 .spec.template.spec.nodeSelector、.spec.affinity、.spec.tolerations 等调度相关字段配置，看是否限制了 Pod 的调度范围。
kube-scheduler 日志：分析 kube-scheduler 日志，了解调度决策过程，找出影响调度的因素。

认证授权与访问控制

RBAC 规则审查：使用 kubectl get rolebindings,clusterrolebindings 检查角色绑定关系，确保用户或服务账户具有正确的 API 访问权限。
API Server 访问日志：分析 kube-apiserver-audit.log，跟踪特定用户或账户的 API 请求与响应，排查授权问题。
网络代理与认证配置：检查 kubeconfig 文件、API Server 配置及网络代理（如 kube-proxy、ingress-nginx 等）的认证设置，确保访问路径无误。

不管是否初学者，大家一般都可以从现象识别到问题定位，再到深入排查与解决方案制定，形成一套完整的问题解决闭环。随着实践经验的积累，排查效率与解决问题的能力将不断提升。">
<meta name="author" content="">
<link rel="canonical" href="/tech/kubernetes/kubernetes-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.4b0be15b6b891613a91dad3a5279f108f18aa855a6dcb49a1e5ff9fade239870.css" integrity="sha256-SwvhW2uJFhOpHa06UnnxCPGKqFWm3LSaHl/5&#43;t4jmHA=" rel="preload stylesheet" as="style">
<link rel="icon" href="/assets/apple-icon.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="/tech/kubernetes/kubernetes-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><style>
@import url('https://fonts.cdnfonts.com/css/code-new-roman');
</style>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&family=LXGW+WenKai+TC&display=swap"
    rel="stylesheet"><meta property="og:title" content="Kubernetes 故障排查方法论" />
<meta property="og:description" content="问题导向&amp;排查
网络诊断

连通性测试：使用 ping、nc、telnet 等工具测试 Pod 间的网络连通性，或通过 curl 检查服务端口是否可达。
NetworkPolicy 检查：确认 NetworkPolicy 规则是否过于严格导致通信阻断，使用 kubectl get netpol 查看并分析现有策略。
CNI 插件排查：检查 CNI 插件（如 Calico、Flannel 等）的日志，排查网络配置或插件自身问题。

存储问题排查

PVC/PV 状态检查：使用 kubectl get pvc,pv 查看 PersistentVolumeClaim 和 PersistentVolume 的绑定状态与容量，确认是否存在未绑定、容量不足等问题。
存储日志与事件：检查存储插件（如 Local Volume、CSI Driver 等）日志，以及 PVC/PV 的事件信息，查找存储访问异常。
数据完整性验证：必要时，直接在宿主机上挂载存储卷，检查数据完整性和一致性。

资源调度与亲和性问题

节点资源分析：使用 kubectl top nodes 查看节点资源使用情况，判断是否存在资源瓶颈。
调度策略检查：确认 Deployments、StatefulSets 等资源的 .spec.template.spec.nodeSelector、.spec.affinity、.spec.tolerations 等调度相关字段配置，看是否限制了 Pod 的调度范围。
kube-scheduler 日志：分析 kube-scheduler 日志，了解调度决策过程，找出影响调度的因素。

认证授权与访问控制

RBAC 规则审查：使用 kubectl get rolebindings,clusterrolebindings 检查角色绑定关系，确保用户或服务账户具有正确的 API 访问权限。
API Server 访问日志：分析 kube-apiserver-audit.log，跟踪特定用户或账户的 API 请求与响应，排查授权问题。
网络代理与认证配置：检查 kubeconfig 文件、API Server 配置及网络代理（如 kube-proxy、ingress-nginx 等）的认证设置，确保访问路径无误。

不管是否初学者，大家一般都可以从现象识别到问题定位，再到深入排查与解决方案制定，形成一套完整的问题解决闭环。随着实践经验的积累，排查效率与解决问题的能力将不断提升。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/tech/kubernetes/kubernetes-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95/" /><meta property="article:section" content="tech" />
<meta property="article:published_time" content="2024-10-26T16:09:19+08:00" />
<meta property="article:modified_time" content="2024-10-26T16:09:19+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kubernetes 故障排查方法论"/>
<meta name="twitter:description" content="问题导向&amp;排查
网络诊断

连通性测试：使用 ping、nc、telnet 等工具测试 Pod 间的网络连通性，或通过 curl 检查服务端口是否可达。
NetworkPolicy 检查：确认 NetworkPolicy 规则是否过于严格导致通信阻断，使用 kubectl get netpol 查看并分析现有策略。
CNI 插件排查：检查 CNI 插件（如 Calico、Flannel 等）的日志，排查网络配置或插件自身问题。

存储问题排查

PVC/PV 状态检查：使用 kubectl get pvc,pv 查看 PersistentVolumeClaim 和 PersistentVolume 的绑定状态与容量，确认是否存在未绑定、容量不足等问题。
存储日志与事件：检查存储插件（如 Local Volume、CSI Driver 等）日志，以及 PVC/PV 的事件信息，查找存储访问异常。
数据完整性验证：必要时，直接在宿主机上挂载存储卷，检查数据完整性和一致性。

资源调度与亲和性问题

节点资源分析：使用 kubectl top nodes 查看节点资源使用情况，判断是否存在资源瓶颈。
调度策略检查：确认 Deployments、StatefulSets 等资源的 .spec.template.spec.nodeSelector、.spec.affinity、.spec.tolerations 等调度相关字段配置，看是否限制了 Pod 的调度范围。
kube-scheduler 日志：分析 kube-scheduler 日志，了解调度决策过程，找出影响调度的因素。

认证授权与访问控制

RBAC 规则审查：使用 kubectl get rolebindings,clusterrolebindings 检查角色绑定关系，确保用户或服务账户具有正确的 API 访问权限。
API Server 访问日志：分析 kube-apiserver-audit.log，跟踪特定用户或账户的 API 请求与响应，排查授权问题。
网络代理与认证配置：检查 kubeconfig 文件、API Server 配置及网络代理（如 kube-proxy、ingress-nginx 等）的认证设置，确保访问路径无误。

不管是否初学者，大家一般都可以从现象识别到问题定位，再到深入排查与解决方案制定，形成一套完整的问题解决闭环。随着实践经验的积累，排查效率与解决问题的能力将不断提升。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Tech",
      "item": "/tech/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Kubernetes 故障排查方法论",
      "item": "/tech/kubernetes/kubernetes-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kubernetes 故障排查方法论",
  "name": "Kubernetes 故障排查方法论",
  "description": "问题导向\u0026amp;排查 网络诊断 连通性测试：使用 ping、nc、telnet 等工具测试 Pod 间的网络连通性，或通过 curl 检查服务端口是否可达。 NetworkPolicy 检查：确认 NetworkPolicy 规则是否过于严格导致通信阻断，使用 kubectl get netpol 查看并分析现有策略。 CNI 插件排查：检查 CNI 插件（如 Calico、Flannel 等）的日志，排查网络配置或插件自身问题。 存储问题排查 PVC/PV 状态检查：使用 kubectl get pvc,pv 查看 PersistentVolumeClaim 和 PersistentVolume 的绑定状态与容量，确认是否存在未绑定、容量不足等问题。 存储日志与事件：检查存储插件（如 Local Volume、CSI Driver 等）日志，以及 PVC/PV 的事件信息，查找存储访问异常。 数据完整性验证：必要时，直接在宿主机上挂载存储卷，检查数据完整性和一致性。 资源调度与亲和性问题 节点资源分析：使用 kubectl top nodes 查看节点资源使用情况，判断是否存在资源瓶颈。 调度策略检查：确认 Deployments、StatefulSets 等资源的 .spec.template.spec.nodeSelector、.spec.affinity、.spec.tolerations 等调度相关字段配置，看是否限制了 Pod 的调度范围。 kube-scheduler 日志：分析 kube-scheduler 日志，了解调度决策过程，找出影响调度的因素。 认证授权与访问控制 RBAC 规则审查：使用 kubectl get rolebindings,clusterrolebindings 检查角色绑定关系，确保用户或服务账户具有正确的 API 访问权限。 API Server 访问日志：分析 kube-apiserver-audit.log，跟踪特定用户或账户的 API 请求与响应，排查授权问题。 网络代理与认证配置：检查 kubeconfig 文件、API Server 配置及网络代理（如 kube-proxy、ingress-nginx 等）的认证设置，确保访问路径无误。 不管是否初学者，大家一般都可以从现象识别到问题定位，再到深入排查与解决方案制定，形成一套完整的问题解决闭环。随着实践经验的积累，排查效率与解决问题的能力将不断提升。\n",
  "keywords": [
    "Kubernetes"
  ],
  "articleBody": "问题导向\u0026排查 网络诊断 连通性测试：使用 ping、nc、telnet 等工具测试 Pod 间的网络连通性，或通过 curl 检查服务端口是否可达。 NetworkPolicy 检查：确认 NetworkPolicy 规则是否过于严格导致通信阻断，使用 kubectl get netpol 查看并分析现有策略。 CNI 插件排查：检查 CNI 插件（如 Calico、Flannel 等）的日志，排查网络配置或插件自身问题。 存储问题排查 PVC/PV 状态检查：使用 kubectl get pvc,pv 查看 PersistentVolumeClaim 和 PersistentVolume 的绑定状态与容量，确认是否存在未绑定、容量不足等问题。 存储日志与事件：检查存储插件（如 Local Volume、CSI Driver 等）日志，以及 PVC/PV 的事件信息，查找存储访问异常。 数据完整性验证：必要时，直接在宿主机上挂载存储卷，检查数据完整性和一致性。 资源调度与亲和性问题 节点资源分析：使用 kubectl top nodes 查看节点资源使用情况，判断是否存在资源瓶颈。 调度策略检查：确认 Deployments、StatefulSets 等资源的 .spec.template.spec.nodeSelector、.spec.affinity、.spec.tolerations 等调度相关字段配置，看是否限制了 Pod 的调度范围。 kube-scheduler 日志：分析 kube-scheduler 日志，了解调度决策过程，找出影响调度的因素。 认证授权与访问控制 RBAC 规则审查：使用 kubectl get rolebindings,clusterrolebindings 检查角色绑定关系，确保用户或服务账户具有正确的 API 访问权限。 API Server 访问日志：分析 kube-apiserver-audit.log，跟踪特定用户或账户的 API 请求与响应，排查授权问题。 网络代理与认证配置：检查 kubeconfig 文件、API Server 配置及网络代理（如 kube-proxy、ingress-nginx 等）的认证设置，确保访问路径无误。 不管是否初学者，大家一般都可以从现象识别到问题定位，再到深入排查与解决方案制定，形成一套完整的问题解决闭环。随着实践经验的积累，排查效率与解决问题的能力将不断提升。\nK8s 常见故障案例 下面再给大家来些经典的故障案例及其排查方法：\n故障案例 1：服务间网络通信异常，表现为超时或连接失败 问题点： Kubernetes 集群内不同服务之间的网络通信出现异常，表现为请求超时、连接失败或响应缓慢。\n影响范围：\n直接影响：服务间依赖关系中断，导致依赖服务的功能不可用或性能下降。间接影响：可能波及整个微服务架构，引发连锁反应，造成系统整体不稳定。\n排查方法：\n验证服务状态： 使用 kubectl get svc 和 kubectl get po 确认涉及的服务和 Pod 是否正常运行。 测试网络连通性： 在出现问题的 Pod 内使用 ping、nc 或 curl 等工具测试与目标服务的网络连通性，包括 ClusterIP、NodePort 或 Headless Service 的 DNS 解析。 检查 NetworkPolicy 规则： 使用 kubectl get netpol 查看是否有 NetworkPolicy 规则限制了服务间的通信。 检查网络插件日志： 检查网络插件（如 Calico、Flannel 等）的日志，寻找可能的网络异常或配置问题。 排查 DNS 解析问题： 如果通过服务名访问出现问题，检查内部 DNS 服务（如 CoreDNS）日志，确认服务 DNS 记录是否正确。 故障案例 2：Pod 无法启动，状态持续为 ImagePullBackOff 问题点： Pod 在创建过程中无法成功拉取指定的容器镜像，状态持续显示为 ImagePullBackOff。\n影响范围：\n直接影响：该 Pod 无法启动，对应的服务或应用无法正常运行。 排查方法：\n查看 Pod 事件： 使用 kubectl describe pod 查看 Pod 的详细状态和事件列表，定位到与镜像拉取相关的事件，通常会包含具体的错误信息。 验证镜像名称与仓库： 确认提交的 Pod 定义（如 Deployment、StatefulSet 等）中使用的镜像名称、标签和仓库地址是否正确无误，且与实际存在的镜像匹配。 检查私有仓库访问： 如果镜像位于私有仓库，确认 Deployment 的 imagePullSecrets 是否已正确配置了仓库访问凭据，以及网络是否允许 Pod 访问仓库。 测试镜像拉取： 在集群内其他节点或同一节点上的另一个容器中尝试手动拉取镜像，以排除网络或仓库临时问题。 检查镜像仓库状态： 如果镜像仓库位于外部，检查仓库服务的运行状态和日志，确保服务正常且镜像可供下载。 故障案例 3：节点资源压力告警，触发 MemoryPressure 或 DiskPressure 问题点： Kubernetes 节点报告内存或磁盘资源压力，标记节点状态为 NotReady 或应用 MemoryPressure、DiskPressure 污点，导致调度器不再将新 Pod 调度到该节点。\n影响范围：\n直接影响：节点上的现有 Pod 可能因资源不足而性能下降或被系统强制终止。 间接影响：集群的整体资源利用率降低，新部署或扩缩容的操作受阻，可能导致服务容量不足或响应延迟。 排查方法：\n查看节点状态： 使用 kubectl get node 查看所有节点状态，重点关注 Conditions 列中的 MemoryPressure 和 DiskPressure 状态。 检查资源使用情况： 使用 kubectl top nodes 查看节点的实时资源使用率，对比节点的总资源容量，判断是否存在过度消耗。 分析资源消耗大户： 使用 kubectl top pods --all-namespaces --sort-by=memory 或 ``–sort-by=cpu` 查找占用资源最多的 Pod，分析其资源使用合理性。 检查磁盘使用情况： 对于 DiskPressure，使用 df -h 或 du -sh /*（在节点上执行）查看磁盘空间使用情况，定位占用空间大的目录。 清理资源或调整策略： 根据分析结果，可能需要清理无用数据、优化 Pod 资源请求/限制、调整日志留存策略、迁移部分工作负载到其他节点等。 故障案例 4：Ingress 资源更新后，外部访问未按预期生效 问题点： 修改或新增 Ingress 资源后，外部客户端通过 Ingress 的域名访问服务时，路由规则、TLS 配置等未按预期更新。\n影响范围：\n直接影响：外部客户端无法访问到最新部署的服务，或访问行为不符合更新后的 Ingress 规则。 间接影响：可能影响用户体验、业务流程或数据一致性，特别是在进行版本升级、功能切换等重要变更时。 排查方法：\n确认 Ingress 更新状态： 使用 kubectl get ingress -o yaml 查看 Ingress 资源的最新配置，确认更新已生效。 检查 Ingress Controller 日志： 查看负责处理 Ingress 的控制器（如 Nginx Ingress Controller、Traefik 等）的日志，查找与 Ingress 更新相关的事件和错误。 测试内部服务访问： 使用 kubectl exec 进入集群内其他 Pod，通过 ClusterIP 或 NodePort 直接访问服务，验证服务本身是否正常。 清理缓存或等待传播： 如果涉及 DNS 缓存问题，可能需要等待 DNS 记录在全球范围内更新，或者在客户端手动清理 DNS 缓存后再试。 检查负载均衡器配置： 对于云服务商托管的 LoadBalancer 类型 Ingress，检查云平台控制台中负载均衡器的配置是否已同步更新。 故障案例 5：Kubernetes API 服务器响应变慢或不可用 问题点： Kubernetes API 服务器响应时间明显增加，或出现无法连接、请求超时、返回错误等情况。\n影响范围：\n直接影响：所有依赖 Kubernetes API 的操作（如 kubectl 命令、CI/CD 流程、集群自动化管理等）都将受到影响。 间接影响：可能导致集群管理困难、应用部署延迟、监控数据丢失、故障响应不及时等问题，严重时可能影响整个系统的稳定运行。 排查方法：\n检查 API 服务器日志： 查看 API 服务器（kube-apiserver）的日志，查找异常消息、错误或警告，定位可能的问题根源。 监控 API 服务器性能指标： 监视 API 服务器的 CPU、内存使用率、请求数、错误率等性能指标，判断是否存在资源瓶颈或异常波动。 检查 etcd 状态： API 服务器依赖于 etcd 存储集群状态，使用 etcdctl 工具检查 etcd 集群的健康状况和响应时间。 排查网络问题： 检查 API 服务器所在节点的网络连接，确认与其他节点及客户端的网络通信是否正常。 审查近期变更： 回顾最近对集群进行的配置更改、版本升级、RBAC 规则调整等操作，判断是否引入了导致 API 性能下降的因素。 故障案例 6：Pod 间网络通信时断时续 问题点： Kubernetes 集群内不同 Pod 之间的网络通信出现间歇性中断或延迟严重，时好时坏，无明显规律。\n影响范围：\n直接影响：依赖网络通信的服务或应用可能出现短暂不可用、数据传输失败、请求超时等问题。 间接影响：可能导致业务流程中断、数据不一致、用户体验下降，严重时影响整个系统的稳定性和可用性。 排查方案：\n监控网络流量与延迟： 使用网络监控工具（如 Prometheus + Grafana、Netdata 等）监控 Pod 间的网络流量、丢包率和延迟，观察是否存在周期性波动或异常峰值。 深入抓包分析： 在受影响的 Pod 内使用 tcpdump 或 wireshark 抓取网络包进行分析，查找是否存在重传、乱序、RST 包等异常现象。 检查网络插件及底层网络设备： 查看网络插件（如 Calico、Flannel 等）的日志，以及宿主机网络设备（如网卡、交换机、路由器等）的状态和日志，排查可能的网络设备故障或配置问题。 分析网络拓扑与策略： 使用 kubectl get netpol 查看 NetworkPolicy 规则，确认是否存在过于严格的策略导致网络中断。检查网络拓扑结构，看是否存在可能导致路由不稳定的设计问题（如多路径、浮动 IP 等）。 排查外部干扰因素： 考虑是否存在外部网络环境变化（如云服务商网络调整、DDoS 攻击、网络维护等）影响集群内通信。如果可能，尝试更换网络环境或时间段观察问题是否重现。 故障案例 7：Kubernetes 控制平面组件间通信异常 问题点： Kubernetes 控制平面组件（如 API 服务器、etcd、控制器管理器、调度器等）之间通信异常，导致集群管理功能受限或失效。\n影响范围：\n直接影响：集群管理功能受限，如无法创建/更新资源、Pod 无法调度、状态更新延迟等。 间接影响：可能导致整个集群的稳定性下降，应用无法正常部署、扩展或恢复，数据一致性问题，严重的甚至可能导致集群完全不可用。 排查方案：\n检查控制平面组件状态： 使用 kubectl get componentstatuses 查看控制平面各组件的状态，关注是否有 Unhealthy 或 Unknown 的组件。 查看控制平面日志： 分别检查 API 服务器、etcd、控制器管理器、调度器等组件的日志，查找与通信异常相关的错误或警告。 检查 etcd 集群健康状况： 使用 etcdctl 工具检查 etcd 集群的健康状况、成员列表、领导者选举状态等，确认各成员间通信是否正常。 检查控制平面网络连接： 使用 netstat、ss 或 telnet 等工具检查控制平面组件之间的网络连接，确认端口是否可达、TCP 连接是否正常。 审查控制平面配置： 检查控制平面组件的配置文件（如 /etc/kubernetes/manifests 下的静态 Pod 清单），确认 API 服务器的 --etcd-servers、控制器管理器和调度器的 --master 参数等是否正确。 故障案例 8：StatefulSet 中 Pod 无法完成初始化或滚动更新 问题点： StatefulSet 中的 Pod 在创建或滚动更新过程中无法完成初始化，始终处于 Pending 或 ContainerCreating 状态，或反复重启。\n影响范围：\n直接影响：对应 StatefulSet 的服务无法按预期提供完整功能，数据一致性或可用性可能受到影响。 排查方案：\n查看 Pod 事件与状态： 使用 kubectl describe pod 查看 Pod 详细状态和事件列表，定位问题发生的具体阶段和原因。 检查存储卷关联与状态： 使用 kubectl get pvc 查看 PersistentVolumeClaim（PVC）的状态，确认 PVC 是否已绑定到合适的 PersistentVolume（PV），PV 是否正常。检查 PV 的详细信息，确认其状态、容量、访问模式等是否满足 StatefulSet 的要求。 检查存储服务日志与状态： 如果使用的是云服务商提供的存储服务（如 OSS、S3、Disk、NAS 等），检查其控制台或日志，确认存储服务本身无异常。 检查应用初始化脚本： 如果 StatefulSet 中的 Pod 在启动时执行了自定义的初始化脚本（如 initContainers），检查这些脚本的逻辑和输出，确认无误。 验证存储卷数据完整性： 如果怀疑存储卷数据损坏或不一致导致问题，尝试在其他节点上挂载该 PV，检查数据是否正确。必要时，从备份恢复数据。 故障案例 9：Helm 升级应用后部分功能异常 问题点： 使用 Helm 升级 Kubernetes 应用后，部分功能出现异常，如服务不可用、接口返回错误、数据不一致等。\n影响范围：\n直接影响：升级后的应用无法正常提供全部功能，可能影响用户访问、数据处理、业务流程等。 间接影响：可能导致信任度下降、运维复杂度增加、回滚成本增大。 排查方案：\n对比旧版与新版资源定义： 使用 helm get values 和 helm get manifest 获取升级前后的资源定义和配置值，对比差异，看是否有误删、误改的关键配置。 检查滚动更新策略： 使用 helm get all 查看 Helm Release 的详细信息，确认滚动更新策略（如 maxUnavailable、maxSurge）是否合理，是否可能导致服务中断。 检查应用日志与状态： 使用 kubectl logs 和 kubectl describe 查看升级后 Pod 的日志和状态，定位具体出错的服务或组件。 验证数据迁移或迁移脚本： 如果升级涉及数据迁移，检查迁移脚本或工具的执行结果，确认数据是否正确迁移。对于有状态应用，确认新旧版本能否正确共享存储。 回滚并逐步升级验证： 如果问题难以定位，可先回滚到旧版本，然后逐步升级部分组件或功能，观察问题是否重现，缩小排查范围。 故障案例 10：Kubernetes 集群频繁出现节点 NotReady 问题点： Kubernetes 集群中的节点频繁出现 NotReady 状态，即使自动恢复后不久又再次变为 NotReady。\n影响范围：\n直接影响：节点上运行的 Pod 可能被驱逐，导致服务中断、数据丢失或处理延迟。 间接影响：频繁的节点状态变化可能导致调度压力增大、资源利用率降低，影响集群整体稳定性和性能。 排查方案：\n监控节点资源使用： 使用 kubectl top nodes 和第三方监控工具（如 Prometheus + Grafana）持续监控节点的 CPU、内存、磁盘、网络等资源使用情况，查找是否有资源耗尽的迹象。 检查节点日志与系统状态： 登录到问题节点，检查系统日志（如 /var/log/messages、/var/log/syslog 等）、Docker（或 Containerd）日志、kubelet 日志，查找与节点状态变化相关的错误或警告。 排查硬件故障或网络问题： 检查节点的硬件状态（如 CPU、内存、磁盘健康状况），以及网络设备（如网卡、交换机）的状态和日志，看是否存在硬件故障或网络问题。 检查节点配置与污点： 使用 kubectl describe node 查看节点详细信息，确认节点配置（如标签、Taints）是否合理，是否被正确调度。 排查系统级软件问题： 检查节点的操作系统、内核、kubelet、Docker（或 Containerd）、CNI 插件等软件版本和配置，确认无已知问题或冲突。必要时，升级到稳定版本或重新安装。 ",
  "wordCount" : "5384",
  "inLanguage": "zh",
  "datePublished": "2024-10-26T16:09:19+08:00",
  "dateModified": "2024-10-26T16:09:19+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/tech/kubernetes/kubernetes-%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "xgbt's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/assets/apple-icon.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="xgbt&#39;s Blog (Alt + H)">xgbt&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="/search" title="🔍搜索">
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="/tags" title="🏷️标签">
                    <span>🏷️标签</span>
                </a>
            </li>
            <li>
                <a href="/archives" title="📦归档">
                    <span>📦归档</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="/">主页</a>&nbsp;»&nbsp;<a href="/tech/">Tech</a></div>
    <h1 class="post-title entry-hint-parent">
      Kubernetes 故障排查方法论
    </h1>
    <div class="post-meta"><span title='2024-10-26 16:09:19 +0800 CST'>十月 26, 2024</span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
        <div class="toc">
            <details  open>
                <summary accesskey="c" title="(Alt + C)">
                    <span class="details">目录</span>
                </summary>

                <div class="inner"><ul>
                        <li>
                            <a href="#%e9%97%ae%e9%a2%98%e5%af%bc%e5%90%91%e6%8e%92%e6%9f%a5" aria-label="问题导向&amp;排查">问题导向&amp;排查</a><ul>
                                    
                        <li>
                            <a href="#%e7%bd%91%e7%bb%9c%e8%af%8a%e6%96%ad" aria-label="网络诊断">网络诊断</a></li>
                        <li>
                            <a href="#%e5%ad%98%e5%82%a8%e9%97%ae%e9%a2%98%e6%8e%92%e6%9f%a5" aria-label="存储问题排查">存储问题排查</a></li>
                        <li>
                            <a href="#%e8%b5%84%e6%ba%90%e8%b0%83%e5%ba%a6%e4%b8%8e%e4%ba%b2%e5%92%8c%e6%80%a7%e9%97%ae%e9%a2%98" aria-label="资源调度与亲和性问题">资源调度与亲和性问题</a></li>
                        <li>
                            <a href="#%e8%ae%a4%e8%af%81%e6%8e%88%e6%9d%83%e4%b8%8e%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6" aria-label="认证授权与访问控制">认证授权与访问控制</a></li>
                        <li>
                            <a href="#k8s-%e5%b8%b8%e8%a7%81%e6%95%85%e9%9a%9c%e6%a1%88%e4%be%8b" aria-label="K8s 常见故障案例">K8s 常见故障案例</a><ul>
                                    
                        <li>
                            <a href="#%e6%95%85%e9%9a%9c%e6%a1%88%e4%be%8b-1%e6%9c%8d%e5%8a%a1%e9%97%b4%e7%bd%91%e7%bb%9c%e9%80%9a%e4%bf%a1%e5%bc%82%e5%b8%b8%e8%a1%a8%e7%8e%b0%e4%b8%ba%e8%b6%85%e6%97%b6%e6%88%96%e8%bf%9e%e6%8e%a5%e5%a4%b1%e8%b4%a5" aria-label="故障案例 1：服务间网络通信异常，表现为超时或连接失败">故障案例 1：服务间网络通信异常，表现为超时或连接失败</a></li>
                        <li>
                            <a href="#%e6%95%85%e9%9a%9c%e6%a1%88%e4%be%8b-2pod-%e6%97%a0%e6%b3%95%e5%90%af%e5%8a%a8%e7%8a%b6%e6%80%81%e6%8c%81%e7%bb%ad%e4%b8%ba-imagepullbackoff" aria-label="故障案例 2：Pod 无法启动，状态持续为 ImagePullBackOff">故障案例 2：Pod 无法启动，状态持续为 ImagePullBackOff</a></li>
                        <li>
                            <a href="#%e6%95%85%e9%9a%9c%e6%a1%88%e4%be%8b-3%e8%8a%82%e7%82%b9%e8%b5%84%e6%ba%90%e5%8e%8b%e5%8a%9b%e5%91%8a%e8%ad%a6%e8%a7%a6%e5%8f%91-memorypressure-%e6%88%96-diskpressure" aria-label="故障案例 3：节点资源压力告警，触发 MemoryPressure 或 DiskPressure">故障案例 3：节点资源压力告警，触发 MemoryPressure 或 DiskPressure</a></li>
                        <li>
                            <a href="#%e6%95%85%e9%9a%9c%e6%a1%88%e4%be%8b-4ingress-%e8%b5%84%e6%ba%90%e6%9b%b4%e6%96%b0%e5%90%8e%e5%a4%96%e9%83%a8%e8%ae%bf%e9%97%ae%e6%9c%aa%e6%8c%89%e9%a2%84%e6%9c%9f%e7%94%9f%e6%95%88" aria-label="故障案例 4：Ingress 资源更新后，外部访问未按预期生效">故障案例 4：Ingress 资源更新后，外部访问未按预期生效</a></li>
                        <li>
                            <a href="#%e6%95%85%e9%9a%9c%e6%a1%88%e4%be%8b-5kubernetes-api-%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%93%8d%e5%ba%94%e5%8f%98%e6%85%a2%e6%88%96%e4%b8%8d%e5%8f%af%e7%94%a8" aria-label="故障案例 5：Kubernetes API 服务器响应变慢或不可用">故障案例 5：Kubernetes API 服务器响应变慢或不可用</a></li>
                        <li>
                            <a href="#%e6%95%85%e9%9a%9c%e6%a1%88%e4%be%8b-6pod-%e9%97%b4%e7%bd%91%e7%bb%9c%e9%80%9a%e4%bf%a1%e6%97%b6%e6%96%ad%e6%97%b6%e7%bb%ad" aria-label="故障案例 6：Pod 间网络通信时断时续">故障案例 6：Pod 间网络通信时断时续</a></li>
                        <li>
                            <a href="#%e6%95%85%e9%9a%9c%e6%a1%88%e4%be%8b-7kubernetes-%e6%8e%a7%e5%88%b6%e5%b9%b3%e9%9d%a2%e7%bb%84%e4%bb%b6%e9%97%b4%e9%80%9a%e4%bf%a1%e5%bc%82%e5%b8%b8" aria-label="故障案例 7：Kubernetes 控制平面组件间通信异常">故障案例 7：Kubernetes 控制平面组件间通信异常</a></li>
                        <li>
                            <a href="#%e6%95%85%e9%9a%9c%e6%a1%88%e4%be%8b-8statefulset-%e4%b8%ad-pod-%e6%97%a0%e6%b3%95%e5%ae%8c%e6%88%90%e5%88%9d%e5%a7%8b%e5%8c%96%e6%88%96%e6%bb%9a%e5%8a%a8%e6%9b%b4%e6%96%b0" aria-label="故障案例 8：StatefulSet 中 Pod 无法完成初始化或滚动更新">故障案例 8：StatefulSet 中 Pod 无法完成初始化或滚动更新</a></li>
                        <li>
                            <a href="#%e6%95%85%e9%9a%9c%e6%a1%88%e4%be%8b-9helm-%e5%8d%87%e7%ba%a7%e5%ba%94%e7%94%a8%e5%90%8e%e9%83%a8%e5%88%86%e5%8a%9f%e8%83%bd%e5%bc%82%e5%b8%b8" aria-label="故障案例 9：Helm 升级应用后部分功能异常">故障案例 9：Helm 升级应用后部分功能异常</a></li>
                        <li>
                            <a href="#%e6%95%85%e9%9a%9c%e6%a1%88%e4%be%8b-10kubernetes-%e9%9b%86%e7%be%a4%e9%a2%91%e7%b9%81%e5%87%ba%e7%8e%b0%e8%8a%82%e7%82%b9-notready" aria-label="故障案例 10：Kubernetes 集群频繁出现节点 NotReady">故障案例 10：Kubernetes 集群频繁出现节点 NotReady</a>
                        </li>
                    </ul>
                    </li>
                    </ul>
                    </li>
                    </ul>
                </div>
            </details>
        </div>
    </aside>
    <script>
        let activeElement;
        let elements;

        document.addEventListener('DOMContentLoaded', function (event) {
            checkTocPosition();

            elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
            if (elements.length > 0) {
                
                activeElement = elements[0];
                const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
            }

            
            const topLink = document.getElementById('top-link');
            if (topLink) {
                topLink.addEventListener('click', (event) => {
                    
                    event.preventDefault();

                    
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                });
            }
        }, false);

        window.addEventListener('resize', function (event) {
            checkTocPosition();
        }, false);

        window.addEventListener('scroll', () => {
            
            const scrollPosition = window.pageYOffset || document.documentElement.scrollTop;

            
            if (scrollPosition === 0) {
                return;
            }

            
            if (elements && elements.length > 0) {
                
                activeElement = Array.from(elements).find((element) => {
                    if ((getOffsetTop(element) - scrollPosition) > 0 &&
                        (getOffsetTop(element) - scrollPosition) < window.innerHeight / 2) {
                        return element;
                    }
                }) || activeElement;

                elements.forEach(element => {
                    const id = encodeURI(element.getAttribute('id')).toLowerCase();
                    const tocLink = document.querySelector(`.inner ul li a[href="#${id}"]`);
                    if (element === activeElement) {
                        tocLink.classList.add('active');

                        
                        const tocContainer = document.querySelector('.toc .inner');
                        const linkOffsetTop = tocLink.offsetTop;
                        const containerHeight = tocContainer.clientHeight;
                        const linkHeight = tocLink.clientHeight;

                        
                        const scrollPosition = linkOffsetTop - (containerHeight / 2) + (linkHeight / 2);
                        tocContainer.scrollTo({ top: scrollPosition, behavior: 'smooth' });
                    } else {
                        tocLink.classList.remove('active');
                    }
                });
            }
        }, false);

        const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
        const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
        const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

        function checkTocPosition() {
            const width = document.body.scrollWidth;

            if (width - main - (toc * 2) - (gap * 4) > 0) {
                document.getElementById("toc-container").classList.add("wide");
            } else {
                document.getElementById("toc-container").classList.remove("wide");
            }
        }

        function getOffsetTop(element) {
            if (!element.getClientRects().length) {
                return 0;
            }
            let rect = element.getBoundingClientRect();
            let win = element.ownerDocument.defaultView;
            return rect.top + win.pageYOffset;
        }

    </script>
  <div class="post-content"><h1 id="问题导向排查">问题导向&amp;排查<a hidden class="anchor" aria-hidden="true" href="#问题导向排查">#</a></h1>
<h2 id="网络诊断">网络诊断<a hidden class="anchor" aria-hidden="true" href="#网络诊断">#</a></h2>
<ul>
<li><strong>连通性测试</strong>：使用 <code>ping</code>、<code>nc</code>、<code>telnet</code> 等工具测试 Pod 间的网络连通性，或通过 <code>curl</code> 检查服务端口是否可达。</li>
<li><strong>NetworkPolicy 检查</strong>：确认 NetworkPolicy 规则是否过于严格导致通信阻断，使用 <code>kubectl get netpol</code> 查看并分析现有策略。</li>
<li><strong>CNI 插件排查</strong>：检查 CNI 插件（如 Calico、Flannel 等）的日志，排查网络配置或插件自身问题。</li>
</ul>
<h2 id="存储问题排查">存储问题排查<a hidden class="anchor" aria-hidden="true" href="#存储问题排查">#</a></h2>
<ul>
<li><strong>PVC/PV 状态检查</strong>：使用 <code>kubectl get pvc,pv</code> 查看 <code>PersistentVolumeClaim</code> 和 <code>PersistentVolume</code> 的绑定状态与容量，确认是否存在未绑定、容量不足等问题。</li>
<li><strong>存储日志与事件</strong>：检查存储插件（如 Local Volume、CSI Driver 等）日志，以及 PVC/PV 的事件信息，查找存储访问异常。</li>
<li><strong>数据完整性验证</strong>：必要时，直接在宿主机上挂载存储卷，检查数据完整性和一致性。</li>
</ul>
<h2 id="资源调度与亲和性问题">资源调度与亲和性问题<a hidden class="anchor" aria-hidden="true" href="#资源调度与亲和性问题">#</a></h2>
<ul>
<li><strong>节点资源分析</strong>：使用 <code>kubectl top nodes</code> 查看节点资源使用情况，判断是否存在资源瓶颈。</li>
<li><strong>调度策略检查</strong>：确认 Deployments、StatefulSets 等资源的 <code>.spec.template.spec.nodeSelector</code>、<code>.spec.affinity</code>、<code>.spec.tolerations</code> 等调度相关字段配置，看是否限制了 Pod 的调度范围。</li>
<li><strong>kube-scheduler 日志</strong>：分析 kube-scheduler 日志，了解调度决策过程，找出影响调度的因素。</li>
</ul>
<h2 id="认证授权与访问控制">认证授权与访问控制<a hidden class="anchor" aria-hidden="true" href="#认证授权与访问控制">#</a></h2>
<ul>
<li><strong>RBAC 规则审查</strong>：使用 <code>kubectl get rolebindings,clusterrolebindings</code> 检查角色绑定关系，确保用户或服务账户具有正确的 API 访问权限。</li>
<li><strong>API Server 访问日志</strong>：分析 <code>kube-apiserver-audit.log</code>，跟踪特定用户或账户的 API 请求与响应，排查授权问题。</li>
<li><strong>网络代理与认证配置</strong>：检查 kubeconfig 文件、API Server 配置及网络代理（如 kube-proxy、ingress-nginx 等）的认证设置，确保访问路径无误。</li>
</ul>
<p>不管是否初学者，大家一般都可以从现象识别到问题定位，再到深入排查与解决方案制定，形成一套完整的问题解决闭环。随着实践经验的积累，排查效率与解决问题的能力将不断提升。</p>
<h2 id="k8s-常见故障案例">K8s 常见故障案例<a hidden class="anchor" aria-hidden="true" href="#k8s-常见故障案例">#</a></h2>
<p>下面再给大家来些经典的故障案例及其排查方法：</p>
<h3 id="故障案例-1服务间网络通信异常表现为超时或连接失败">故障案例 1：服务间网络通信异常，表现为超时或连接失败<a hidden class="anchor" aria-hidden="true" href="#故障案例-1服务间网络通信异常表现为超时或连接失败">#</a></h3>
<p><strong>问题点：</strong> Kubernetes 集群内不同服务之间的网络通信出现异常，表现为请求超时、连接失败或响应缓慢。</p>
<p><strong>影响范围：</strong></p>
<p>直接影响：服务间依赖关系中断，导致依赖服务的功能不可用或性能下降。间接影响：可能波及整个微服务架构，引发连锁反应，造成系统整体不稳定。</p>
<p><strong>排查方法：</strong></p>
<ol>
<li><strong>验证服务状态：</strong> 使用 kubectl get svc 和 kubectl get po 确认涉及的服务和 Pod 是否正常运行。</li>
<li><strong>测试网络连通性：</strong> 在出现问题的 Pod 内使用 ping、nc 或 curl 等工具测试与目标服务的网络连通性，包括 ClusterIP、NodePort 或 Headless Service 的 DNS 解析。</li>
<li><strong>检查 NetworkPolicy 规则：</strong> 使用 kubectl get netpol 查看是否有 NetworkPolicy 规则限制了服务间的通信。</li>
<li><strong>检查网络插件日志：</strong> 检查网络插件（如 Calico、Flannel 等）的日志，寻找可能的网络异常或配置问题。</li>
<li><strong>排查 DNS 解析问题：</strong> 如果通过服务名访问出现问题，检查内部 DNS 服务（如 CoreDNS）日志，确认服务 DNS 记录是否正确。</li>
</ol>
<h3 id="故障案例-2pod-无法启动状态持续为-imagepullbackoff">故障案例 2：Pod 无法启动，状态持续为 ImagePullBackOff<a hidden class="anchor" aria-hidden="true" href="#故障案例-2pod-无法启动状态持续为-imagepullbackoff">#</a></h3>
<p><strong>问题点：</strong> Pod 在创建过程中无法成功拉取指定的容器镜像，状态持续显示为 ImagePullBackOff。</p>
<p><strong>影响范围：</strong></p>
<ul>
<li>直接影响：该 Pod 无法启动，对应的服务或应用无法正常运行。</li>
</ul>
<p><strong>排查方法：</strong></p>
<ol>
<li><strong>查看 Pod 事件：</strong> 使用 <code>kubectl describe pod &lt;pod-name&gt;</code> 查看 Pod 的详细状态和事件列表，定位到与镜像拉取相关的事件，通常会包含具体的错误信息。</li>
<li><strong>验证镜像名称与仓库：</strong> 确认提交的 Pod 定义（如 Deployment、StatefulSet 等）中使用的镜像名称、标签和仓库地址是否正确无误，且与实际存在的镜像匹配。</li>
<li><strong>检查私有仓库访问：</strong> 如果镜像位于私有仓库，确认 Deployment 的 imagePullSecrets 是否已正确配置了仓库访问凭据，以及网络是否允许 Pod 访问仓库。</li>
<li><strong>测试镜像拉取：</strong> 在集群内其他节点或同一节点上的另一个容器中尝试手动拉取镜像，以排除网络或仓库临时问题。</li>
<li><strong>检查镜像仓库状态：</strong> 如果镜像仓库位于外部，检查仓库服务的运行状态和日志，确保服务正常且镜像可供下载。</li>
</ol>
<h3 id="故障案例-3节点资源压力告警触发-memorypressure-或-diskpressure">故障案例 3：节点资源压力告警，触发 MemoryPressure 或 DiskPressure<a hidden class="anchor" aria-hidden="true" href="#故障案例-3节点资源压力告警触发-memorypressure-或-diskpressure">#</a></h3>
<p><strong>问题点：</strong> Kubernetes 节点报告内存或磁盘资源压力，标记节点状态为 <code>NotReady</code> 或应用 <code>MemoryPressure</code>、<code>DiskPressure</code> 污点，导致调度器不再将新 Pod 调度到该节点。</p>
<p><strong>影响范围：</strong></p>
<ul>
<li>直接影响：节点上的现有 Pod 可能因资源不足而性能下降或被系统强制终止。</li>
<li>间接影响：集群的整体资源利用率降低，新部署或扩缩容的操作受阻，可能导致服务容量不足或响应延迟。</li>
</ul>
<p><strong>排查方法：</strong></p>
<ol>
<li><strong>查看节点状态：</strong> 使用 <code>kubectl get node</code> 查看所有节点状态，重点关注 <code>Conditions</code> 列中的 <code>MemoryPressure</code> 和 <code>DiskPressure</code> 状态。</li>
<li><strong>检查资源使用情况：</strong> 使用 <code>kubectl top nodes</code> 查看节点的实时资源使用率，对比节点的总资源容量，判断是否存在过度消耗。</li>
<li><strong>分析资源消耗大户：</strong> 使用 <code>kubectl top pods --all-namespaces --sort-by=memory</code> 或 ``&ndash;sort-by=cpu` 查找占用资源最多的 Pod，分析其资源使用合理性。</li>
<li><strong>检查磁盘使用情况：</strong> 对于 <code>DiskPressure</code>，使用 <code>df -h</code> 或 <code>du -sh /*</code>（在节点上执行）查看磁盘空间使用情况，定位占用空间大的目录。</li>
<li><strong>清理资源或调整策略：</strong> 根据分析结果，可能需要清理无用数据、优化 Pod 资源请求/限制、调整日志留存策略、迁移部分工作负载到其他节点等。</li>
</ol>
<h3 id="故障案例-4ingress-资源更新后外部访问未按预期生效">故障案例 4：Ingress 资源更新后，外部访问未按预期生效<a hidden class="anchor" aria-hidden="true" href="#故障案例-4ingress-资源更新后外部访问未按预期生效">#</a></h3>
<p><strong>问题点：</strong> 修改或新增 Ingress 资源后，外部客户端通过 Ingress 的域名访问服务时，路由规则、TLS 配置等未按预期更新。</p>
<p><strong>影响范围：</strong></p>
<ul>
<li>直接影响：外部客户端无法访问到最新部署的服务，或访问行为不符合更新后的 Ingress 规则。</li>
<li>间接影响：可能影响用户体验、业务流程或数据一致性，特别是在进行版本升级、功能切换等重要变更时。</li>
</ul>
<p><strong>排查方法：</strong></p>
<ol>
<li><strong>确认 Ingress 更新状态：</strong> 使用 <code>kubectl get ingress &lt;ingress-name&gt; -o yaml</code> 查看 Ingress 资源的最新配置，确认更新已生效。</li>
<li><strong>检查 Ingress Controller 日志：</strong> 查看负责处理 Ingress 的控制器（如 Nginx Ingress Controller、Traefik 等）的日志，查找与 Ingress 更新相关的事件和错误。</li>
<li><strong>测试内部服务访问：</strong> 使用 <code>kubectl exec</code> 进入集群内其他 Pod，通过 ClusterIP 或 NodePort 直接访问服务，验证服务本身是否正常。</li>
<li><strong>清理缓存或等待传播：</strong> 如果涉及 DNS 缓存问题，可能需要等待 DNS 记录在全球范围内更新，或者在客户端手动清理 DNS 缓存后再试。</li>
<li><strong>检查负载均衡器配置：</strong> 对于云服务商托管的 LoadBalancer 类型 Ingress，检查云平台控制台中负载均衡器的配置是否已同步更新。</li>
</ol>
<h3 id="故障案例-5kubernetes-api-服务器响应变慢或不可用">故障案例 5：Kubernetes API 服务器响应变慢或不可用<a hidden class="anchor" aria-hidden="true" href="#故障案例-5kubernetes-api-服务器响应变慢或不可用">#</a></h3>
<p><strong>问题点：</strong> Kubernetes API 服务器响应时间明显增加，或出现无法连接、请求超时、返回错误等情况。</p>
<p><strong>影响范围：</strong></p>
<ul>
<li>直接影响：所有依赖 Kubernetes API 的操作（如 kubectl 命令、CI/CD 流程、集群自动化管理等）都将受到影响。</li>
<li>间接影响：可能导致集群管理困难、应用部署延迟、监控数据丢失、故障响应不及时等问题，严重时可能影响整个系统的稳定运行。</li>
</ul>
<p><strong>排查方法：</strong></p>
<ol>
<li><strong>检查 API 服务器日志：</strong> 查看 API 服务器（kube-apiserver）的日志，查找异常消息、错误或警告，定位可能的问题根源。</li>
<li><strong>监控 API 服务器性能指标：</strong> 监视 API 服务器的 CPU、内存使用率、请求数、错误率等性能指标，判断是否存在资源瓶颈或异常波动。</li>
<li><strong>检查 etcd 状态：</strong> API 服务器依赖于 etcd 存储集群状态，使用 <code>etcdctl</code> 工具检查 etcd 集群的健康状况和响应时间。</li>
<li><strong>排查网络问题：</strong> 检查 API 服务器所在节点的网络连接，确认与其他节点及客户端的网络通信是否正常。</li>
<li><strong>审查近期变更：</strong> 回顾最近对集群进行的配置更改、版本升级、RBAC 规则调整等操作，判断是否引入了导致 API 性能下降的因素。</li>
</ol>
<h3 id="故障案例-6pod-间网络通信时断时续">故障案例 6：Pod 间网络通信时断时续<a hidden class="anchor" aria-hidden="true" href="#故障案例-6pod-间网络通信时断时续">#</a></h3>
<p><strong>问题点：</strong> Kubernetes 集群内不同 Pod 之间的网络通信出现间歇性中断或延迟严重，时好时坏，无明显规律。</p>
<p><strong>影响范围：</strong></p>
<ul>
<li>直接影响：依赖网络通信的服务或应用可能出现短暂不可用、数据传输失败、请求超时等问题。</li>
<li>间接影响：可能导致业务流程中断、数据不一致、用户体验下降，严重时影响整个系统的稳定性和可用性。</li>
</ul>
<p><strong>排查方案：</strong></p>
<ol>
<li><strong>监控网络流量与延迟：</strong> 使用网络监控工具（如 Prometheus + Grafana、Netdata 等）监控 Pod 间的网络流量、丢包率和延迟，观察是否存在周期性波动或异常峰值。</li>
<li><strong>深入抓包分析：</strong> 在受影响的 Pod 内使用 <code>tcpdump</code> 或 <code>wireshark</code> 抓取网络包进行分析，查找是否存在重传、乱序、RST 包等异常现象。</li>
<li><strong>检查网络插件及底层网络设备：</strong> 查看网络插件（如 Calico、Flannel 等）的日志，以及宿主机网络设备（如网卡、交换机、路由器等）的状态和日志，排查可能的网络设备故障或配置问题。</li>
<li><strong>分析网络拓扑与策略：</strong> 使用 <code>kubectl get netpol</code> 查看 NetworkPolicy 规则，确认是否存在过于严格的策略导致网络中断。检查网络拓扑结构，看是否存在可能导致路由不稳定的设计问题（如多路径、浮动 IP 等）。</li>
<li><strong>排查外部干扰因素：</strong> 考虑是否存在外部网络环境变化（如云服务商网络调整、DDoS 攻击、网络维护等）影响集群内通信。如果可能，尝试更换网络环境或时间段观察问题是否重现。</li>
</ol>
<h3 id="故障案例-7kubernetes-控制平面组件间通信异常">故障案例 7：Kubernetes 控制平面组件间通信异常<a hidden class="anchor" aria-hidden="true" href="#故障案例-7kubernetes-控制平面组件间通信异常">#</a></h3>
<p><strong>问题点：</strong> Kubernetes 控制平面组件（如 API 服务器、etcd、控制器管理器、调度器等）之间通信异常，导致集群管理功能受限或失效。</p>
<p><strong>影响范围：</strong></p>
<ul>
<li>直接影响：集群管理功能受限，如无法创建/更新资源、Pod 无法调度、状态更新延迟等。</li>
<li>间接影响：可能导致整个集群的稳定性下降，应用无法正常部署、扩展或恢复，数据一致性问题，严重的甚至可能导致集群完全不可用。</li>
</ul>
<p><strong>排查方案：</strong></p>
<ol>
<li><strong>检查控制平面组件状态：</strong> 使用 <code>kubectl get componentstatuses</code> 查看控制平面各组件的状态，关注是否有 <code>Unhealthy</code> 或 <code>Unknown</code> 的组件。</li>
<li><strong>查看控制平面日志：</strong> 分别检查 API 服务器、etcd、控制器管理器、调度器等组件的日志，查找与通信异常相关的错误或警告。</li>
<li><strong>检查 etcd 集群健康状况：</strong> 使用 <code>etcdctl</code> 工具检查 etcd 集群的健康状况、成员列表、领导者选举状态等，确认各成员间通信是否正常。</li>
<li><strong>检查控制平面网络连接：</strong> 使用 <code>netstat</code>、<code>ss</code> 或 <code>telnet</code> 等工具检查控制平面组件之间的网络连接，确认端口是否可达、TCP 连接是否正常。</li>
<li><strong>审查控制平面配置：</strong> 检查控制平面组件的配置文件（如 <code>/etc/kubernetes/manifests</code> 下的静态 Pod 清单），确认 API 服务器的 <code>--etcd-servers</code>、控制器管理器和调度器的 <code>--master</code> 参数等是否正确。</li>
</ol>
<h3 id="故障案例-8statefulset-中-pod-无法完成初始化或滚动更新">故障案例 8：StatefulSet 中 Pod 无法完成初始化或滚动更新<a hidden class="anchor" aria-hidden="true" href="#故障案例-8statefulset-中-pod-无法完成初始化或滚动更新">#</a></h3>
<p><strong>问题点：</strong> StatefulSet 中的 Pod 在创建或滚动更新过程中无法完成初始化，始终处于 <code>Pending</code> 或 <code>ContainerCreating</code> 状态，或反复重启。</p>
<p><strong>影响范围：</strong></p>
<ul>
<li>直接影响：对应 StatefulSet 的服务无法按预期提供完整功能，数据一致性或可用性可能受到影响。</li>
</ul>
<p><strong>排查方案：</strong></p>
<ol>
<li><strong>查看 Pod 事件与状态：</strong> 使用 <code>kubectl describe pod &lt;pod-name&gt;</code> 查看 Pod 详细状态和事件列表，定位问题发生的具体阶段和原因。</li>
<li><strong>检查存储卷关联与状态：</strong> 使用 <code>kubectl get pvc</code> 查看 PersistentVolumeClaim（PVC）的状态，确认 PVC 是否已绑定到合适的 PersistentVolume（PV），PV 是否正常。检查 PV 的详细信息，确认其状态、容量、访问模式等是否满足 StatefulSet 的要求。</li>
<li><strong>检查存储服务日志与状态：</strong> 如果使用的是云服务商提供的存储服务（如 OSS、S3、Disk、NAS 等），检查其控制台或日志，确认存储服务本身无异常。</li>
<li><strong>检查应用初始化脚本：</strong> 如果 StatefulSet 中的 Pod 在启动时执行了自定义的初始化脚本（如 <code>initContainers</code>），检查这些脚本的逻辑和输出，确认无误。</li>
<li><strong>验证存储卷数据完整性：</strong> 如果怀疑存储卷数据损坏或不一致导致问题，尝试在其他节点上挂载该 PV，检查数据是否正确。必要时，从备份恢复数据。</li>
</ol>
<h3 id="故障案例-9helm-升级应用后部分功能异常">故障案例 9：Helm 升级应用后部分功能异常<a hidden class="anchor" aria-hidden="true" href="#故障案例-9helm-升级应用后部分功能异常">#</a></h3>
<p><strong>问题点：</strong> 使用 Helm 升级 Kubernetes 应用后，部分功能出现异常，如服务不可用、接口返回错误、数据不一致等。</p>
<p><strong>影响范围：</strong></p>
<ul>
<li>直接影响：升级后的应用无法正常提供全部功能，可能影响用户访问、数据处理、业务流程等。</li>
<li>间接影响：可能导致信任度下降、运维复杂度增加、回滚成本增大。</li>
</ul>
<p><strong>排查方案：</strong></p>
<ol>
<li><strong>对比旧版与新版资源定义：</strong> 使用 <code>helm get values &lt;release-name&gt;</code> 和 <code>helm get manifest &lt;release-name&gt;</code> 获取升级前后的资源定义和配置值，对比差异，看是否有误删、误改的关键配置。</li>
<li><strong>检查滚动更新策略：</strong> 使用 <code>helm get all &lt;release-name&gt;</code> 查看 Helm Release 的详细信息，确认滚动更新策略（如 <code>maxUnavailable</code>、<code>maxSurge</code>）是否合理，是否可能导致服务中断。</li>
<li><strong>检查应用日志与状态：</strong> 使用 <code>kubectl logs</code> 和 <code>kubectl describe</code> 查看升级后 Pod 的日志和状态，定位具体出错的服务或组件。</li>
<li><strong>验证数据迁移或迁移脚本：</strong> 如果升级涉及数据迁移，检查迁移脚本或工具的执行结果，确认数据是否正确迁移。对于有状态应用，确认新旧版本能否正确共享存储。</li>
<li><strong>回滚并逐步升级验证：</strong> 如果问题难以定位，可先回滚到旧版本，然后逐步升级部分组件或功能，观察问题是否重现，缩小排查范围。</li>
</ol>
<h3 id="故障案例-10kubernetes-集群频繁出现节点-notready">故障案例 10：Kubernetes 集群频繁出现节点 NotReady<a hidden class="anchor" aria-hidden="true" href="#故障案例-10kubernetes-集群频繁出现节点-notready">#</a></h3>
<p><strong>问题点：</strong> Kubernetes 集群中的节点频繁出现 <code>NotReady</code> 状态，即使自动恢复后不久又再次变为 NotReady。</p>
<p><strong>影响范围：</strong></p>
<ul>
<li>直接影响：节点上运行的 Pod 可能被驱逐，导致服务中断、数据丢失或处理延迟。</li>
<li>间接影响：频繁的节点状态变化可能导致调度压力增大、资源利用率降低，影响集群整体稳定性和性能。</li>
</ul>
<p><strong>排查方案：</strong></p>
<ol>
<li><strong>监控节点资源使用：</strong> 使用 <code>kubectl top nodes</code> 和第三方监控工具（如 Prometheus + Grafana）持续监控节点的 CPU、内存、磁盘、网络等资源使用情况，查找是否有资源耗尽的迹象。</li>
<li><strong>检查节点日志与系统状态：</strong> 登录到问题节点，检查系统日志（如 <code>/var/log/messages</code>、<code>/var/log/syslog</code> 等）、Docker（或 Containerd）日志、kubelet 日志，查找与节点状态变化相关的错误或警告。</li>
<li><strong>排查硬件故障或网络问题：</strong> 检查节点的硬件状态（如 CPU、内存、磁盘健康状况），以及网络设备（如网卡、交换机）的状态和日志，看是否存在硬件故障或网络问题。</li>
<li><strong>检查节点配置与污点：</strong> 使用 <code>kubectl describe node &lt;node-name&gt;</code> 查看节点详细信息，确认节点配置（如标签、Taints）是否合理，是否被正确调度。</li>
<li><strong>排查系统级软件问题：</strong> 检查节点的操作系统、内核、kubelet、Docker（或 Containerd）、CNI 插件等软件版本和配置，确认无已知问题或冲突。必要时，升级到稳定版本或重新安装。</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/kubernetes/">Kubernetes</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="/tech/kubernetes/kubernetes-1.29.6-%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/">
    <span class="title">« 上一页</span>
    <br>
    <span>Kubernetes 1.29.6 高可用集群部署</span>
  </a>
  <a class="next" href="/tech/kubernetes/%E5%9F%BA%E4%BA%8E-kubeadm-%E6%89%8B%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%AF%81%E4%B9%A6/">
    <span class="title">下一页 »</span>
    <br>
    <span>基于 Kubeadm 手动更新证书</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="/">xgbt&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
