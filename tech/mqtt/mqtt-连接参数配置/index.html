<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>MQTT 连接参数配置 | xgbt&#39;s Blog</title>
<meta name="keywords" content="MQTT">
<meta name="description" content="MQTT 连接过程
MQTT 连接由客户端向服务器端发起。
任何运行了 MQTT 客户端库的程序或设备都是一个 MQTT 客户端，而 MQTT 服务器 负责接收客户端发起的连接，并将客户端发送的消息转发到另外一些符合条件的客户端。">
<meta name="author" content="">
<link rel="canonical" href="/tech/mqtt/mqtt-%E8%BF%9E%E6%8E%A5%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.4b0be15b6b891613a91dad3a5279f108f18aa855a6dcb49a1e5ff9fade239870.css" integrity="sha256-SwvhW2uJFhOpHa06UnnxCPGKqFWm3LSaHl/5&#43;t4jmHA=" rel="preload stylesheet" as="style">
<link rel="icon" href="/assets/apple-icon.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="/tech/mqtt/mqtt-%E8%BF%9E%E6%8E%A5%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><style>
@import url('https://fonts.cdnfonts.com/css/code-new-roman');
</style>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&family=LXGW+WenKai+TC&display=swap"
    rel="stylesheet"><meta property="og:title" content="MQTT 连接参数配置" />
<meta property="og:description" content="MQTT 连接过程
MQTT 连接由客户端向服务器端发起。
任何运行了 MQTT 客户端库的程序或设备都是一个 MQTT 客户端，而 MQTT 服务器 负责接收客户端发起的连接，并将客户端发送的消息转发到另外一些符合条件的客户端。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/tech/mqtt/mqtt-%E8%BF%9E%E6%8E%A5%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/" /><meta property="article:section" content="tech" />
<meta property="article:published_time" content="2024-03-22T16:09:19+08:00" />
<meta property="article:modified_time" content="2024-03-22T16:09:19+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="MQTT 连接参数配置"/>
<meta name="twitter:description" content="MQTT 连接过程
MQTT 连接由客户端向服务器端发起。
任何运行了 MQTT 客户端库的程序或设备都是一个 MQTT 客户端，而 MQTT 服务器 负责接收客户端发起的连接，并将客户端发送的消息转发到另外一些符合条件的客户端。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Tech",
      "item": "/tech/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "MQTT 连接参数配置",
      "item": "/tech/mqtt/mqtt-%E8%BF%9E%E6%8E%A5%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MQTT 连接参数配置",
  "name": "MQTT 连接参数配置",
  "description": "MQTT 连接过程 MQTT 连接由客户端向服务器端发起。\n任何运行了 MQTT 客户端库的程序或设备都是一个 MQTT 客户端，而 MQTT 服务器 负责接收客户端发起的连接，并将客户端发送的消息转发到另外一些符合条件的客户端。\n",
  "keywords": [
    "MQTT"
  ],
  "articleBody": "MQTT 连接过程 MQTT 连接由客户端向服务器端发起。\n任何运行了 MQTT 客户端库的程序或设备都是一个 MQTT 客户端，而 MQTT 服务器 负责接收客户端发起的连接，并将客户端发送的消息转发到另外一些符合条件的客户端。\n客户端与服务器建立网络连接后，需要先发送一个 CONNECT 数据包给服务器。\n服务器收到 CONNECT 包后会回复一个 CONNACK 给客户端，客户端收到 CONNACK 包后表示 MQTT 连接建立成功。\n如果客户端在超时时间内未收到服务器的 CONNACK 数据包，就会主动关闭连接。\n大多数场景下，MQTT 通过 TCP/IP 协议 进行网络传输，但是 MQTT 同时也支持通过 WebSocket 或者 UDP 进行网络传输。\nMQTT over TCP TCP/IP 应用广泛，是一种面向连接的、可靠的、基于字节流的传输层通信协议。它通过 ACK 确认和重传机制，能够保证发送的所有字节在接收时是完全一样的，并且字节顺序也是正确的。\nMQTT 通常基于 TCP 进行网络通信，它继承了 TCP 的很多优点，能稳定运行在低带宽、高延时、及资源受限的环境下。\nMQTT over WebSocket 很多物联网应用需要以 Web 的方式被使用，比如很多设备监控系统需要使用浏览器实时显示设备数据。但是浏览器是基于 HTTP 协议传输数据的，也就无法使用 MQTT over TCP。\nMQTT 协议在创建之初便考虑到了 Web 应用的重要性，它支持通过 MQTT over WebSocket 的方式进行 MQTT 通信。\nMQTT 连接参数 连接地址 MQTT 的连接地址通常包含 ：服务器 IP 或者域名、服务器端口、连接协议。\n基于 TCP 的 MQTT 连接 mqtt 是普通的 TCP 连接，端口一般为 1883。\nmqtts 是基于 TLS/SSL 的安全连接，端口一般为 8883。\n比如 mqtt://broker.emqx.io:1883 是一个基于普通 TCP 的 MQTT 连接地址。\n基于 WebSocket 的连接 ws 是普通的 WebSocket 连接，端口一般为 8083。\nwss 是基于 WebSocket 的安全连接，端口一般为 8084。\n当使用 WebSocket 连接时，连接地址还需要包含 Path，EMQX 默认配置的 Path 是 /mqtt。比如 ws://broker.emqx.io:8083/mqtt 是一个基于 WebSocket 的 MQTT 连接地址。\nClient ID MQTT 服务器使用 Client ID 识别客户端，连接到服务器的每个客户端都必须要有唯一的 Client ID。Client ID 的长度通常为 1 至 23 个字节的 UTF-8 字符串。\n如果客户端使用一个重复的 Client ID 连接至服务器，将会把已使用该 Client ID 连接成功的客户端踢下线。 g\nUsername \u0026 Password MQTT 协议基于用户名和密码来进行相关的认证和授权，但是如果此信息未加密，则用户名和密码将以明文方式传输。如果设置了用户名与密码认证，那么最好要使用 mqtts 或 wss 协议。\n大多数 MQTT 服务器默认为匿名认证，匿名认证时用户名与密码设置为空字符串即可。\nConnect Timeout 连接超时时长，收到服务器连接确认前的等待时间，等待时间内未收到连接确认则为连接失败。\nKeep Alive 保活周期，是一个以秒为单位的时间间隔。客户端在无报文发送时，将按 Keep Alive 设定的值定时向服务端发送心跳报文，确保连接不被服务端断开。\n在连接建立成功后，如果服务器没有在 Keep Alive 的 1.5 倍时间内收到来自客户端的任何包，则会认为和客户端之间的连接出现了问题，此时服务器便会断开和客户端的连接。\nClean Session Clean Session 为 false 时表示创建一个持久会话，在客户端断开连接时，会话仍然保持并保存离线消息，直到会话超时注销；为 true 时表示创建一个新的临时会话，在客户端断开时，会话自动销毁。\n持久会话避免了客户端掉线重连后消息丢失，也避免了客户端连接后重复的订阅开销。这一功能在带宽小，网络不稳定的物联网场景中非常实用。\n服务器为持久会话保存的消息数量取决于服务器的配置。\n注意： 持久会话恢复的前提是客户端使用固定的 Client ID 再次连接，如果 Client ID 是动态的，那么连接成功后将会创建一个新的持久会话。\nLast Will 遗嘱消息是 MQTT 为那些可能出现意外断线的设备提供的将遗嘱优雅地发送给其他客户端的能力。设置了遗嘱消息消息的 MQTT 客户端异常下线时，MQTT 服务器会发布该客户端设置的遗嘱消息。\n意外断线包括：因网络故障，连接被服务端关闭；设备意外掉电；设备尝试进行不被允许的操作而被服务端关闭连接等。\n遗嘱消息可以看作是一个简化版的 MQTT 消息，它也包含 Topic、Payload、QoS、Retain 等信息。\n当设备意外断线时，遗嘱消息将被发送至遗嘱 Topic； 遗嘱 Payload 是待发送的消息内容； 遗嘱 QoS 与普通 MQTT 消息的 QoS 一致。 遗嘱 Retain 为 true 时表明遗嘱消息是保留消息。MQTT 服务器会为每个主题存储最新一条保留消息，以方便消息发布后才上线的客户端在订阅主题时仍可以接收到该消息。 协议版本 使用较多的 MQTT 协议版本有 MQTT v3.1、MQTT v3.1.1 及 MQTT v5.0。\n目前，MQTT 5.0 已成为绝大多数物联网企业的首选协议，我们建议初次接触 MQTT 的开发者直接使用该版本。但是，paho.mqtt.golang 目前只支持v3.1.1。\n参考资料 https://www.emqx.com/zh/blog/how-to-set-parameters-when-establishing-an-mqtt-connection ",
  "wordCount" : "1748",
  "inLanguage": "zh",
  "datePublished": "2024-03-22T16:09:19+08:00",
  "dateModified": "2024-03-22T16:09:19+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/tech/mqtt/mqtt-%E8%BF%9E%E6%8E%A5%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "xgbt's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/assets/apple-icon.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="xgbt&#39;s Blog (Alt + H)">xgbt&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="/search" title="🔍搜索">
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="/tags" title="🏷️标签">
                    <span>🏷️标签</span>
                </a>
            </li>
            <li>
                <a href="/archives" title="📦归档">
                    <span>📦归档</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="/">主页</a>&nbsp;»&nbsp;<a href="/tech/">Tech</a></div>
    <h1 class="post-title entry-hint-parent">
      MQTT 连接参数配置
    </h1>
    <div class="post-meta"><span title='2024-03-22 16:09:19 +0800 CST'>三月 22, 2024</span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
        <div class="toc">
            <details  open>
                <summary accesskey="c" title="(Alt + C)">
                    <span class="details">目录</span>
                </summary>

                <div class="inner"><ul>
                        <li>
                            <a href="#mqtt-%e8%bf%9e%e6%8e%a5%e8%bf%87%e7%a8%8b" aria-label="MQTT 连接过程">MQTT 连接过程</a><ul>
                                    
                        <li>
                            <a href="#mqtt-over-tcp" aria-label="MQTT over TCP">MQTT over TCP</a></li>
                        <li>
                            <a href="#mqtt-over-websocket" aria-label="MQTT over WebSocket">MQTT over WebSocket</a></li></ul>
                        </li>
                        <li>
                            <a href="#mqtt-%e8%bf%9e%e6%8e%a5%e5%8f%82%e6%95%b0" aria-label="MQTT 连接参数">MQTT 连接参数</a><ul>
                                    
                        <li>
                            <a href="#%e8%bf%9e%e6%8e%a5%e5%9c%b0%e5%9d%80" aria-label="连接地址">连接地址</a><ul>
                                    
                        <li>
                            <a href="#%e5%9f%ba%e4%ba%8e-tcp-%e7%9a%84-mqtt-%e8%bf%9e%e6%8e%a5" aria-label="基于 TCP 的 MQTT 连接">基于 TCP 的 MQTT 连接</a></li>
                        <li>
                            <a href="#%e5%9f%ba%e4%ba%8e-websocket-%e7%9a%84%e8%bf%9e%e6%8e%a5" aria-label="基于 WebSocket 的连接">基于 WebSocket 的连接</a></li></ul>
                        </li>
                        <li>
                            <a href="#client-id" aria-label="Client ID">Client ID</a></li>
                        <li>
                            <a href="#username--password" aria-label="Username &amp; Password">Username &amp; Password</a></li>
                        <li>
                            <a href="#connect-timeout" aria-label="Connect Timeout">Connect Timeout</a></li>
                        <li>
                            <a href="#keep-alive" aria-label="Keep Alive">Keep Alive</a></li>
                        <li>
                            <a href="#clean-session" aria-label="Clean Session">Clean Session</a></li>
                        <li>
                            <a href="#last-will" aria-label="Last Will">Last Will</a></li>
                        <li>
                            <a href="#%e5%8d%8f%e8%ae%ae%e7%89%88%e6%9c%ac" aria-label="协议版本">协议版本</a></li></ul>
                        </li>
                        <li>
                            <a href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99" aria-label="参考资料">参考资料</a>
                        </li>
                    </ul>
                </div>
            </details>
        </div>
    </aside>
    <script>
        let activeElement;
        let elements;

        document.addEventListener('DOMContentLoaded', function (event) {
            checkTocPosition();

            elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
            if (elements.length > 0) {
                
                activeElement = elements[0];
                const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
            }

            
            const topLink = document.getElementById('top-link');
            if (topLink) {
                topLink.addEventListener('click', (event) => {
                    
                    event.preventDefault();

                    
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                });
            }
        }, false);

        window.addEventListener('resize', function (event) {
            checkTocPosition();
        }, false);

        window.addEventListener('scroll', () => {
            
            const scrollPosition = window.pageYOffset || document.documentElement.scrollTop;

            
            if (scrollPosition === 0) {
                return;
            }

            
            if (elements && elements.length > 0) {
                
                activeElement = Array.from(elements).find((element) => {
                    if ((getOffsetTop(element) - scrollPosition) > 0 &&
                        (getOffsetTop(element) - scrollPosition) < window.innerHeight / 2) {
                        return element;
                    }
                }) || activeElement;

                elements.forEach(element => {
                    const id = encodeURI(element.getAttribute('id')).toLowerCase();
                    const tocLink = document.querySelector(`.inner ul li a[href="#${id}"]`);
                    if (element === activeElement) {
                        tocLink.classList.add('active');

                        
                        const tocContainer = document.querySelector('.toc .inner');
                        const linkOffsetTop = tocLink.offsetTop;
                        const containerHeight = tocContainer.clientHeight;
                        const linkHeight = tocLink.clientHeight;

                        
                        const scrollPosition = linkOffsetTop - (containerHeight / 2) + (linkHeight / 2);
                        tocContainer.scrollTo({ top: scrollPosition, behavior: 'smooth' });
                    } else {
                        tocLink.classList.remove('active');
                    }
                });
            }
        }, false);

        const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
        const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
        const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

        function checkTocPosition() {
            const width = document.body.scrollWidth;

            if (width - main - (toc * 2) - (gap * 4) > 0) {
                document.getElementById("toc-container").classList.add("wide");
            } else {
                document.getElementById("toc-container").classList.remove("wide");
            }
        }

        function getOffsetTop(element) {
            if (!element.getClientRects().length) {
                return 0;
            }
            let rect = element.getBoundingClientRect();
            let win = element.ownerDocument.defaultView;
            return rect.top + win.pageYOffset;
        }

    </script>
  <div class="post-content"><h1 id="mqtt-连接过程">MQTT 连接过程<a hidden class="anchor" aria-hidden="true" href="#mqtt-连接过程">#</a></h1>
<p>MQTT 连接由客户端向服务器端发起。</p>
<p>任何运行了 MQTT 客户端库的程序或设备都是一个 MQTT 客户端，而 MQTT 服务器 负责接收客户端发起的连接，并将客户端发送的消息转发到另外一些符合条件的客户端。</p>
<p>客户端与服务器建立网络连接后，需要先发送一个 <code>CONNECT</code> 数据包给服务器。</p>
<p>服务器收到 <code>CONNECT</code> 包后会回复一个 <code>CONNACK</code> 给客户端，客户端收到 <code>CONNACK</code> 包后表示 MQTT 连接建立成功。</p>
<p>如果客户端在超时时间内未收到服务器的 <code>CONNACK</code> 数据包，就会主动关闭连接。</p>
<p>大多数场景下，MQTT 通过 <strong>TCP/IP 协议</strong> 进行网络传输，但是 MQTT 同时也支持通过 WebSocket 或者 UDP 进行网络传输。</p>
<h2 id="mqtt-over-tcp">MQTT over TCP<a hidden class="anchor" aria-hidden="true" href="#mqtt-over-tcp">#</a></h2>
<p>TCP/IP 应用广泛，是一种<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。它通过 <code>ACK</code> 确认和重传机制，能够保证发送的所有字节在接收时是完全一样的，并且字节顺序也是正确的。</p>
<p>MQTT 通常基于 TCP 进行网络通信，它继承了 TCP 的很多优点，能稳定运行在低带宽、高延时、及资源受限的环境下。</p>
<h2 id="mqtt-over-websocket">MQTT over WebSocket<a hidden class="anchor" aria-hidden="true" href="#mqtt-over-websocket">#</a></h2>
<p>很多物联网应用需要以 Web 的方式被使用，比如很多设备监控系统需要使用浏览器实时显示设备数据。但是浏览器是基于 HTTP 协议传输数据的，也就无法使用 MQTT over TCP。</p>
<p>MQTT 协议在创建之初便考虑到了 Web 应用的重要性，它支持通过 MQTT over WebSocket 的方式进行 MQTT 通信。</p>
<h1 id="mqtt-连接参数">MQTT 连接参数<a hidden class="anchor" aria-hidden="true" href="#mqtt-连接参数">#</a></h1>
<h2 id="连接地址">连接地址<a hidden class="anchor" aria-hidden="true" href="#连接地址">#</a></h2>
<p>MQTT 的连接地址通常包含 ：服务器 IP 或者域名、服务器端口、连接协议。</p>
<h3 id="基于-tcp-的-mqtt-连接">基于 TCP 的 MQTT 连接<a hidden class="anchor" aria-hidden="true" href="#基于-tcp-的-mqtt-连接">#</a></h3>
<p><code>mqtt</code> 是普通的 TCP 连接，端口一般为 1883。</p>
<p><code>mqtts</code> 是基于 TLS/SSL 的安全连接，端口一般为 8883。</p>
<p>比如 <code>mqtt://broker.emqx.io:1883</code> 是一个基于普通 TCP 的 MQTT 连接地址。</p>
<h3 id="基于-websocket-的连接">基于 WebSocket 的连接<a hidden class="anchor" aria-hidden="true" href="#基于-websocket-的连接">#</a></h3>
<p><code>ws</code> 是普通的 WebSocket 连接，端口一般为 8083。</p>
<p><code>wss</code> 是基于 WebSocket 的安全连接，端口一般为 8084。</p>
<p>当使用 WebSocket 连接时，连接地址还需要包含 Path，EMQX 默认配置的 Path 是 <code>/mqtt</code>。比如 <code>ws://broker.emqx.io:8083/mqtt</code> 是一个基于 WebSocket 的 MQTT 连接地址。</p>
<h2 id="client-id">Client ID<a hidden class="anchor" aria-hidden="true" href="#client-id">#</a></h2>
<p>MQTT 服务器使用 Client ID 识别客户端，连接到服务器的每个客户端都必须要有唯一的 Client ID。Client ID 的长度通常为 1 至 23 个字节的 UTF-8 字符串。</p>
<p><strong>如果客户端使用一个重复的 Client ID 连接至服务器，将会把已使用该 Client ID 连接成功的客户端踢下线。</strong>
g</p>
<h2 id="username--password">Username &amp; Password<a hidden class="anchor" aria-hidden="true" href="#username--password">#</a></h2>
<p>MQTT 协议基于用户名和密码来进行相关的认证和授权，但是如果此信息未加密，则用户名和密码将以明文方式传输。<strong>如果设置了用户名与密码认证，那么最好要使用 <code>mqtts</code> 或 <code>wss</code> 协议。</strong></p>
<p><strong>大多数 MQTT 服务器默认为匿名认证，匿名认证时用户名与密码设置为空字符串即可。</strong></p>
<h2 id="connect-timeout">Connect Timeout<a hidden class="anchor" aria-hidden="true" href="#connect-timeout">#</a></h2>
<p>连接超时时长，收到服务器连接确认前的等待时间，等待时间内未收到连接确认则为连接失败。</p>
<h2 id="keep-alive">Keep Alive<a hidden class="anchor" aria-hidden="true" href="#keep-alive">#</a></h2>
<p>保活周期，是一个以秒为单位的时间间隔。客户端在无报文发送时，将按 Keep Alive 设定的值定时向服务端发送心跳报文，确保连接不被服务端断开。</p>
<p>在连接建立成功后，如果服务器没有在 Keep Alive 的 1.5 倍时间内收到来自客户端的任何包，则会认为和客户端之间的连接出现了问题，此时服务器便会断开和客户端的连接。</p>
<h2 id="clean-session">Clean Session<a hidden class="anchor" aria-hidden="true" href="#clean-session">#</a></h2>
<p><code>Clean Session</code> 为 <code>false</code> 时表示创建一个<strong>持久会话</strong>，在客户端断开连接时，会话仍然保持并保存离线消息，直到会话超时注销；为 <code>true</code> 时表示创建一个新的临时会话，在客户端断开时，会话自动销毁。</p>
<p><strong>持久会话避免了客户端掉线重连后消息丢失，也避免了客户端连接后重复的订阅开销。这一功能在带宽小，网络不稳定的物联网场景中非常实用。</strong></p>
<p>服务器为持久会话保存的消息数量取决于服务器的配置。</p>
<blockquote>
<p><strong>注意：</strong> 持久会话恢复的前提是客户端使用固定的 Client ID 再次连接，如果 Client ID 是动态的，那么连接成功后将会创建一个新的持久会话。</p>
</blockquote>
<h2 id="last-will">Last Will<a hidden class="anchor" aria-hidden="true" href="#last-will">#</a></h2>
<p>遗嘱消息是 MQTT 为那些可能出现<strong>意外断线</strong>的设备提供的将<strong>遗嘱</strong>优雅地发送给其他客户端的能力。设置了遗嘱消息消息的 MQTT 客户端异常下线时，MQTT 服务器会发布该客户端设置的遗嘱消息。</p>
<blockquote>
<p><strong>意外断线包括</strong>：因网络故障，连接被服务端关闭；设备意外掉电；设备尝试进行不被允许的操作而被服务端关闭连接等。</p>
</blockquote>
<p>遗嘱消息可以看作是一个简化版的 MQTT 消息，它也包含 Topic、Payload、QoS、Retain 等信息。</p>
<ul>
<li>当设备意外断线时，遗嘱消息将被发送至遗嘱 Topic；</li>
<li>遗嘱 Payload 是待发送的消息内容；</li>
<li>遗嘱 QoS 与普通 MQTT 消息的 QoS 一致。</li>
<li>遗嘱 Retain 为 <code>true</code> 时表明遗嘱消息是保留消息。MQTT 服务器会为每个主题存储最新一条保留消息，以方便消息发布后才上线的客户端在订阅主题时仍可以接收到该消息。</li>
</ul>
<h2 id="协议版本">协议版本<a hidden class="anchor" aria-hidden="true" href="#协议版本">#</a></h2>
<p>使用较多的 MQTT 协议版本有 MQTT v3.1、MQTT v3.1.1 及 MQTT v5.0。</p>
<p>目前，MQTT 5.0 已成为绝大多数物联网企业的首选协议，我们建议初次接触 MQTT 的开发者直接使用该版本。但是，<code>paho.mqtt.golang</code> 目前只支持v3.1.1。</p>
<h1 id="参考资料">参考资料<a hidden class="anchor" aria-hidden="true" href="#参考资料">#</a></h1>
<ul>
<li><a href="https://www.emqx.com/zh/blog/how-to-set-parameters-when-establishing-an-mqtt-connection">https://www.emqx.com/zh/blog/how-to-set-parameters-when-establishing-an-mqtt-connection</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/mqtt/">MQTT</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="/tech/kubernetes/k8s-%E5%90%AF%E7%94%A8-ipvs-%E6%A8%A1%E5%BC%8F/">
    <span class="title">« 上一页</span>
    <br>
    <span>K8s 启用 ipvs 模式</span>
  </a>
  <a class="next" href="/tech/kubernetes/k8s-%E4%BF%AE%E6%94%B9-nodeport-%E9%BB%98%E8%AE%A4%E8%8C%83%E5%9B%B4/">
    <span class="title">下一页 »</span>
    <br>
    <span>K8s 修改 NodePort 默认范围</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="/">xgbt&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
